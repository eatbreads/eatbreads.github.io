<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>介绍一下cpu中的yuv转rgb和opengl中的yuv转rgb和直接nv12转rbg方法</title>
      <link href="/posts/f4cc5b12.html"/>
      <url>/posts/f4cc5b12.html</url>
      
        <content type="html"><![CDATA[<h1 id="YUV-NV12到RGB的转换方案"><a href="#YUV-NV12到RGB的转换方案" class="headerlink" title="YUV/NV12到RGB的转换方案"></a>YUV/NV12到RGB的转换方案</h1><h2 id="CPU中的YUV转RGB"><a href="#CPU中的YUV转RGB" class="headerlink" title="CPU中的YUV转RGB"></a>CPU中的YUV转RGB</h2><h3 id="FFmpeg方案"><a href="#FFmpeg方案" class="headerlink" title="FFmpeg方案"></a>FFmpeg方案</h3><ul><li>FFmpeg解码默认输出YUV格式</li><li>使用<code>sws_getCachedContext</code>进行格式转换</li><li>转换目标格式为<code>AV_PIX_FMT_RGBA</code></li><li>适合简单场景，但CPU消耗较大<br><img src="https://cdn-a.markji.com/files/67efabbae940a885d8a18beb_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Dr3M6vI51akx8UsbYqxDKiHGGYY=" alt="图片1"><h2 id="OpenGL中的YUV转RGB方案"><a href="#OpenGL中的YUV转RGB方案" class="headerlink" title="OpenGL中的YUV转RGB方案"></a>OpenGL中的YUV转RGB方案</h2></li></ul><h3 id="方案一：RGB纹理渲染"><a href="#方案一：RGB纹理渲染" class="headerlink" title="方案一：RGB纹理渲染"></a>方案一：RGB纹理渲染</h3><p><img src="https://cdn-a.markji.com/files/67efabe2e940a885d8a18ea2_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:jqDoEHl78m5YLERVbYFjI-pErow=" alt="图片1"></p><ol><li><p>继承关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayImage</span> : <span class="keyword">public</span> QOpenGLWidget, <span class="keyword">public</span> QOpenGLFunctions_3_3_Core</span><br></pre></td></tr></table></figure></li><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializeGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并绑定VAO/VBO/IBO</span></span><br><span class="line">    <span class="comment">// 编译连接着色器程序</span></span><br><span class="line">    <span class="comment">// 启用顶点属性数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像更新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 垂直翻转(OpenGL纹理Y轴相反)</span></span><br><span class="line">    m_texture = <span class="keyword">new</span> <span class="built_in">QOpenGLTexture</span>(image.<span class="built_in">mirrored</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>渲染</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定着色器程序</span></span><br><span class="line">    <span class="comment">// 绑定纹理</span></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    <span class="built_in">glDrawElements</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="方案二：直接YUV渲染"><a href="#方案二：直接YUV渲染" class="headerlink" title="方案二：直接YUV渲染"></a>方案二：直接YUV渲染</h3><p><img src="https://cdn-a.markji.com/files/67efac311137c8f4e5af9cb9_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:BvYuGOTK2QfpMlTtQ5sb0X1BJoA=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67efac3fe940a885d8a19690_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MFIybXXJT39g33YdPqRPOs2KGFA=" alt="图片1"></p><ol><li>数据传递</li></ol><ul><li>直接使用<code>AVFrame</code>传递解码数据</li><li>使用<code>BlockingQueuedConnection</code>确保数据安全</li></ul><ol><li><p>信号槽配置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册AVFrame用于信号传递</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(AVFrame)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接信号槽</span></span><br><span class="line"><span class="built_in">connect</span>(m_readThread, &amp;ReadThread::repaint,</span><br><span class="line">        playImage, &amp;PlayImage::repaint,</span><br><span class="line">        Qt::BlockingQueuedConnection);</span><br></pre></td></tr></table></figure></li><li><p>纹理处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个纹理对应YUV分量</span></span><br><span class="line">QOpenGLTexture *m_texY, *m_texU, *m_texV;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置纹理单元</span></span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_y&quot;</span>, <span class="number">0</span>);</span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_u&quot;</span>, <span class="number">1</span>);</span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_v&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>渲染实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_texY-&gt;<span class="built_in">bind</span>(<span class="number">0</span>);</span><br><span class="line">    m_texU-&gt;<span class="built_in">bind</span>(<span class="number">1</span>);</span><br><span class="line">    m_texV-&gt;<span class="built_in">bind</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行绘制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="OpenGL中直接处理NV12"><a href="#OpenGL中直接处理NV12" class="headerlink" title="OpenGL中直接处理NV12"></a>OpenGL中直接处理NV12</h2><p><img src="https://cdn-a.markji.com/files/67efac7c1137c8f4e5afa991_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FoRKl2CActfg1Z33Ow7avwu4Sdc=" alt="图片1"></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>避免CPU中的格式转换</li><li>性能提升约1/3</li><li>直接在GPU中完成转换</li></ul><h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><ol><li>使用<code>av_hwframe_map</code>替代<code>av_hwframe_transfer_data</code></li><li>移除<code>sws_scale</code>相关代码</li><li>直接返回硬件帧</li></ol><h3 id="格式适配"><a href="#格式适配" class="headerlink" title="格式适配"></a>格式适配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据输入格式选择初始化方式</span></span><br><span class="line">    <span class="keyword">if</span> (format == AV_PIX_FMT_NV12) &#123;</span><br><span class="line">        <span class="built_in">initializeNV12</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">initializeYUV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_format == AV_PIX_FMT_NV12) &#123;</span><br><span class="line">        <span class="comment">// NV12渲染流程</span></span><br><span class="line">        <span class="built_in">bindNV12Textures</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// YUV渲染流程</span></span><br><span class="line">        <span class="built_in">bindYUVTextures</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行绘制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><ol><li><p>CPU转换方案</p><ul><li>实现简单</li><li>CPU占用高</li><li>适合简单场景</li></ul></li><li><p>OpenGL YUV方案</p><ul><li>中等复杂度</li><li>GPU处理</li><li>性能较好</li></ul></li><li><p>OpenGL NV12方案</p><ul><li>实现较复杂</li><li>性能最优</li><li>适合高性能需求<br>```</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> FFmpeg </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频软硬解码流程详解</title>
      <link href="/posts/2c4a1d51.html"/>
      <url>/posts/2c4a1d51.html</url>
      
        <content type="html"><![CDATA[<h1>音视频解码流程详解</h1><h2 id="软解码基础流程">软解码基础流程</h2><ol><li>打开输入文件</li><li>读取媒体文件信息</li><li>查询视频流</li><li>获取解码器</li><li>获取解码器上下文</li><li>使用视频流的codecpar为解码器上下文赋值</li><li>打开解码器</li><li>获取原始数据帧</li><li>将数据发送给解码器</li><li>从解码器读取解码后的数据</li><li>获取图像转换上下文</li><li>将解码的图像格式转换成QImage</li></ol><h2 id="硬解码流程">硬解码流程</h2><h3 id="基础步骤">基础步骤</h3><ol><li>打开输入文件<ul><li><code>avformat_open_input</code></li></ul></li><li>读取媒体文件信息<ul><li><code>avformat_find_stream_info</code></li></ul></li><li>查询视频流<ul><li><code>av_find_best_stream</code></li></ul></li><li>获取解码器<ul><li><code>avcodec_find_decoder</code></li></ul></li><li>获取解码器上下文<ul><li><code>avcodec_alloc_context3</code></li></ul></li><li>使用视频流的codecpar赋值<ul><li><code>avcodec_parameters_to_context</code></li></ul></li></ol><h3 id="硬件加速相关步骤">硬件加速相关步骤</h3><ol><li>检索编解码器支持的硬件配置<ul><li><code>avcodec_get_hw_config</code></li></ul></li><li>遍历支持的编解码器设备类型<ul><li><code>av_hwdevice_iterate_types</code></li><li>在构造函数中记录支持的类型到数组</li></ul></li><li>打开指定类型的编解码器设备<ul><li><code>av_hwdevice_ctx_create</code></li></ul></li><li>注册硬件像素格式回调<ul><li><code>m_codecContext-&gt;get_format = get_hw_format</code></li></ul></li></ol><h3 id="解码步骤">解码步骤</h3><ol><li>打开解码器<ul><li><code>avcodec_open2</code></li></ul></li><li>读取原始数据帧<ul><li><code>av_read_frame</code></li></ul></li><li>发送数据到解码器<ul><li><code>avcodec_send_packet</code></li></ul></li><li>读取解码后的数据<ul><li><code>avcodec_receive_frame</code></li></ul></li><li>GPU数据拷贝到CPU<ul><li><code>av_hwframe_transfer_data</code></li><li><code>av_hwframe_map(m_frameHW, m_frame, 0)</code></li></ul></li><li>获取图像转换上下文<ul><li><code>sws_getCachedContext</code></li></ul></li><li>转换为QImage格式<ul><li><code>sws_scale</code></li></ul></li></ol><h2 id="软解码显示实现-PlayImage类">软解码显示实现(PlayImage类)</h2><h3 id="基于QWidget">基于QWidget</h3><ol><li>接收图像信号并响应updateImage槽函数</li><li>转换为QPixmap</li><li>调用update触发重绘</li><li>paintEvent中绘制</li></ol><h3 id="YUV转RGB">YUV转RGB</h3><ul><li>FFmpeg默认解码为YUV格式</li><li>使用<code>sws_getCachedContext</code>转换为RGB(AV_PIX_FMT_RGBA)</li></ul><h2 id="OpenGL渲染优化">OpenGL渲染优化</h2><h3 id="软解码-OpenGL-YUV-RGB">软解码+OpenGL(YUV-&gt;RGB)</h3><ol><li>继承QOpenGLWidget和QOpenGLFunctions</li><li>initializeGL中设置VAO/VBO/IBO</li><li>updateImage中处理纹理</li><li>paintGL中执行绘制</li></ol><h3 id="软解码-OpenGL-直接YUV">软解码+OpenGL(直接YUV)</h3><ol><li>使用AVFrame直接传递</li><li>使用三个纹理处理YUV数据</li><li>在GPU中完成格式转换</li></ol><h3 id="硬解码-OpenGL-NV12">硬解码+OpenGL(NV12)</h3><ol><li>使用<code>av_hwframe_map</code>替代transfer_data</li><li>根据格式选择初始化方式</li><li>直接在GPU中完成NV12到RGB的转换</li></ol><h2 id="摄像头采集">摄像头采集</h2><ol><li>注册设备<ul><li><code>avdevice_register_all</code></li></ul></li><li>查询输入设备<ul><li><code>av_find_input_format</code></li></ul></li><li>执行标准解码流程</li><li>OpenGL中完成YUV转RGB</li></ol><h2 id="视频录制流程">视频录制流程</h2><ol><li>创建输出上下文<ul><li><code>avformat_alloc_output_context2</code></li></ul></li><li>初始化IO上下文<ul><li><code>avio_open</code></li></ul></li><li>配置编码器</li><li>创建视频流</li><li>写入头信息</li><li>编码循环</li><li>写入尾信息</li></ol>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> OpenGL </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg命令行和API使用指南</title>
      <link href="/posts/66a36265.html"/>
      <url>/posts/66a36265.html</url>
      
        <content type="html"><![CDATA[<h1>FFmpeg使用指南</h1><h2 id="命令行参数">命令行参数</h2><h3 id="基础参数">基础参数</h3><ul><li><code>-a/vn</code>: 去掉音频或视频</li><li><code>-a/vcodec</code>: 指定音视频编码器<ul><li><code>copy</code>: 不重新编码</li><li>可指定为h264或aac等</li></ul></li></ul><h3 id="常用命令">常用命令</h3><h4 id="1-获取视频信息">1. 获取视频信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i video.avi</span><br></pre></td></tr></table></figure><h4 id="2-音视频流处理">2. 音视频流处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去掉视频流</span></span><br><span class="line">ffmpeg -i input.mp4 -an -vcodec copy output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频重编码为AAC</span></span><br><span class="line">ffmpeg -i input.mp4 -acodec aac output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为WAV格式</span></span><br><span class="line">ffmpeg -i input.mp4 -acodec pcm_s16le output.wav</span><br></pre></td></tr></table></figure><h4 id="3-视频截图">3. 视频截图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -ss 10 -frames:v 1 -s 1920x1080 output.jpg</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-ss &lt;时间&gt;</code>: 指定起始时间</li><li><code>-s &lt;宽度x高度&gt;</code>: 调整图片大小</li><li><code>-frames:v 1</code>: 只截取一帧</li></ul><h4 id="4-添加水印">4. 添加水印</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片水印</span></span><br><span class="line">ffmpeg -i input.mp4 -i logo.png -filter_complex <span class="string">&quot;overlay=10:10&quot;</span> output.mp4</span><br></pre></td></tr></table></figure><p>位置参数：</p><ul><li>左上角: <code>overlay=10:10</code></li><li>右上角: <code>overlay=W-w-10:10</code></li><li>左下角: <code>overlay=10:H-h-10</code></li><li>右下角: <code>overlay=W-w-10:H-h-10</code></li></ul><p>其中：</p><ul><li>W: 视频宽度</li><li>H: 视频高度</li><li>w: 水印宽度</li><li>h: 水印高度</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文字水印</span></span><br><span class="line">ffmpeg -i input.flv -vf <span class="string">&quot;drawtext=fontfile=simhei.ttf: text=&#x27;抖音&#x27;:x=100:y=10:fontsize=24:fontcolor=yellow:shadowy=2&quot;</span> drawtext.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># GIF水印</span></span><br><span class="line">ffmpeg -y -i test2.mp4 -ignore_loop 0 -i test.gif -filter_complex overlay=0:H-h test_out2.mp4</span><br></pre></td></tr></table></figure><h4 id="5-视频旋转">5. 视频旋转</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -vf <span class="string">&quot;transpose=1&quot;</span> out.mp4  <span class="comment"># 顺时针旋转90°</span></span><br></pre></td></tr></table></figure><h2 id="API使用">API使用</h2><h3 id="视频播放流程">视频播放流程</h3><h4 id="1-格式上下文-AVFormatContext">1. 格式上下文(AVFormatContext)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *pFormatCtx;</span><br><span class="line">pFormatCtx = <span class="built_in">avformat_alloc_context</span>();  <span class="comment">// 分配格式上下文</span></span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, filePath.<span class="built_in">toUtf8</span>().<span class="built_in">constData</span>(), <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 初始化上下文</span></span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>);  <span class="comment">// 获取流信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找视频流索引</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        streamIndex = i;</span><br><span class="line">        isVideo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-解码器设置">2. 解码器设置</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *pAVctx;  <span class="comment">// 解码器上下文</span></span><br><span class="line">AVCodec *pCodec;         <span class="comment">// 实际解码器</span></span><br><span class="line"></span><br><span class="line">pAVctx = <span class="built_in">avcodec_alloc_context3</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">avcodec_parameters_to_context</span>(pAVctx, pFormatCtx-&gt;streams[streamIndex]-&gt;codecpar);</span><br><span class="line">pCodec = <span class="built_in">avcodec_find_decoder</span>(pAVctx-&gt;codec_id);</span><br><span class="line"><span class="built_in">avcodec_open2</span>(pAVctx, pCodec, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="3-数据包和帧处理">3. 数据包和帧处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AVPacket *pAVpkt = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">AVFrame *pAVframe = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">AVFrame *pAVframeRGB = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像转换上下文</span></span><br><span class="line">SwsContext *pSwsCtx = <span class="built_in">sws_getContext</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">av_read_frame</span>(pFormatCtx, pAVpkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">avcodec_send_packet</span>(pAVctx, pAVpkt);</span><br><span class="line">    <span class="built_in">avcodec_receive_frame</span>(pAVctx, pAVframe);</span><br><span class="line">    <span class="built_in">sws_scale</span>(...);  <span class="comment">// 图像转换</span></span><br><span class="line">    <span class="comment">// 显示到窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音频录制流程">音频录制流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">avdevice_register_all</span>();</span><br><span class="line"><span class="type">const</span> AVInputFormat *fmt = <span class="built_in">av_find_input_format</span>(FMT_NAME);</span><br><span class="line"><span class="built_in">avformat_open_input</span>(...);  <span class="comment">// 打开麦克风</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 录制循环</span></span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    <span class="built_in">av_read_frame</span>(ctx, &amp;pkt);  <span class="comment">// 读取PCM数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束处理</span></span><br><span class="line"><span class="built_in">writeWavHeader</span>(outputFile, <span class="number">44100</span>, <span class="number">2</span>, <span class="number">16</span>);  <span class="comment">// 更新WAV头部</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> FFmpeg </tag>
            
            <tag> 命令行工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频基础知识总结</title>
      <link href="/posts/1a7c13c3.html"/>
      <url>/posts/1a7c13c3.html</url>
      
        <content type="html"><![CDATA[<h1>音视频基础知识</h1><h2 id="基本概念">基本概念</h2><h3 id="码率-比特率">码率/比特率</h3><ul><li>单位时间内传输的数据量，单位为kbps(千位每秒)</li><li>分类：<ul><li>恒定码率(CBR)</li><li>动态码率(VBR)</li></ul></li></ul><h3 id="分辨率">分辨率</h3><ol><li>视频分辨率<ul><li>宽×高，如1080P、2K等</li></ul></li><li>屏幕分辨率<ul><li>单位是ppi(每英寸像素数)</li></ul></li><li>位分辨率<ul><li>每个像素点存储信息的位数</li><li>如8位、16位色彩等</li></ul></li></ol><h3 id="帧率">帧率</h3><ol><li>视频帧率<ul><li>由视频本身决定</li><li>FPS(每秒显示帧数)</li></ul></li><li>显示帧率<ul><li>由显示器决定</li><li>显示器刷新率</li></ul></li></ol><h3 id="像素格式">像素格式</h3><ol><li>RGBA<ul><li>红绿蓝和Alpha透明度</li><li>类似于已完成的成品</li></ul></li><li>YUV<ul><li>Y：亮度</li><li>U：色度</li><li>V：对比度</li><li>注：视频常用YUV，因为RGBA占用内存太大</li><li>压缩后转为h264(通过编码器)</li></ul></li></ol><h3 id="音频格式">音频格式</h3><ol><li>PCM<ul><li>原始数据</li><li>压缩后转为AAC帧(通过AAC编码器)</li></ul></li></ol><h2 id="画质相关">画质相关</h2><h3 id="画质要素">画质要素</h3><ol><li>清晰度：细节纹理和边界的清晰程度</li><li>锐度：图像边缘的锐利程度</li><li>解析度<ul><li>像素点数量</li><li>分辨率越高解析度越高</li></ul></li><li>色彩纯度：三原色在色彩中的百分比，越高越鲜艳</li></ol><h3 id="色域与HDR">色域与HDR</h3><ul><li>色域：能表达的颜色范围区域</li><li>HDR：高动态范围，可超出普通[0,1]范围</li></ul><h2 id="封装与编码">封装与编码</h2><h3 id="封装格式">封装格式</h3><p>视频封装格式就像一个包装盒，包含：</p><ol><li>格式头：类似快递单号，包含文件元数据</li><li>媒体信息：包括时长、格式、比特率等</li><li>音视频轨：实际的音频、视频、字幕数据</li><li>视频轨索引：指示播放器数据存储位置<br>常见格式：MP4、MKV、MOV等</li></ol><h3 id="编码协议">编码协议</h3><ul><li>是压缩原始视频数据的方式</li><li>h265压缩率更高但解码要求更高</li></ul><h3 id="音频相关">音频相关</h3><ol><li>采样率：每秒采样次数(人耳感知范围20Hz~20kHz)</li><li>声道：独立音频信号的采集/回放位置</li><li>音频封装格式：mp3、wav、aac等</li><li>音频编码协议：mp3、aac等</li></ol><h2 id="H264编码原理">H264编码原理</h2><h3 id="码流文件分层">码流文件分层</h3><ol><li>VAL(视频编码层)<ul><li>压缩编码后的视频数据序列</li></ul></li><li>NAL(网络提取层)<ul><li>负责网络传输打包</li><li>本地和网络播放都需要</li><li>本质是打包并按序发送给解码器</li></ul></li></ol><h3 id="帧类型">帧类型</h3><ol><li>I帧：完整压缩帧</li><li>P帧：只编码与前帧差异</li><li>B帧：参考前后帧</li><li>IDR帧：特殊I帧，用于GOP重置</li><li>GOP组：图像组，关键帧间隔</li></ol>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> 编解码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决云服务器Docker仓库访问问题</title>
      <link href="/posts/f4beb750.html"/>
      <url>/posts/f4beb750.html</url>
      
        <content type="html"><![CDATA[<h1>云服务器运行Superset遇到的问题及解决方案</h1><h2 id="Docker镜像下载问题">Docker镜像下载问题</h2><h3 id="初始尝试">初始尝试</h3><p>在使用docker-compose部署Superset时，遇到镜像无法下载的问题。虽然通过在<code>/etc/docker/daemon.json</code>中添加国内镜像代理成功下载了redis、postgresql等镜像，但Superset本体镜像始终无法下载。</p><h3 id="解决方案">解决方案</h3><p>采用本地打包上传的方式解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地打包镜像</span></span><br><span class="line">docker save -o apache-superset.tar apachesuperset.docker.scarf.sh/apache/superset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传到服务器</span></span><br><span class="line">scp apache-superset.tar ubuntu@43.138.190.230:/home/ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器端加载镜像</span></span><br><span class="line">docker load -i /home/ubuntu/apache-superset.tar</span><br></pre></td></tr></table></figure><h2 id="访问连接问题">访问连接问题</h2><h3 id="遇到的情况">遇到的情况</h3><ol><li>直接通过公网IP访问无响应</li><li>VSCode远程连接并端口转发后，可以通过localhost:8088访问</li><li>Postman测试显示502 Bad Gateway</li></ol><h3 id="解决步骤">解决步骤</h3><ol><li>检查并配置服务器防火墙</li><li>配置后成功通过Postman连接</li><li>Superset web界面也可以正常访问<br><img src="https://cdn-a.markji.com/files/67efcd9ae940a885d8a48f83_hd.png?e=1744033979105&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:C0FkwH4dORtyDjhWTd4laK_13UU=" alt="图片1"></li></ol><h2 id="MySQL部署问题">MySQL部署问题</h2><p>同样遇到了VSCode连接问题，但最终也得到解决。</p><h2 id="总结经验">总结经验</h2><ol><li>国内环境下可能需要使用镜像打包传输的方式</li><li>注意检查防火墙配置</li><li>端口转发可以作为临时的调试方案</li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 云服务器 </tag>
            
            <tag> Superset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL的GLSL语法基础</title>
      <link href="/posts/f4cb9256.html"/>
      <url>/posts/f4cb9256.html</url>
      
        <content type="html"><![CDATA[<h1>OpenGL GLSL语法基础</h1><h2 id="基本类型">基本类型</h2><h3 id="sampler">sampler</h3><p>采样器类型，作为访问纹理图像的不透明句柄。</p><h3 id="类型转换">类型转换</h3><p>GLSL中变量的类型转换非常严格，没有隐式类型转换，比C++的要求更严格。不同类型间的转换需要使用类似构造函数的语法。</p><h2 id="向量和矩阵">向量和矩阵</h2><h3 id="向量特性">向量特性</h3><ul><li>向量不是数组（例如<code>float coeff[3]</code>才是数组）</li><li>OpenGL的向量使用列主序，与C/C++不同，相当于斜对角镜像</li><li>向量默认是float类型，如vec2/3/4，mat2/3/4或mat2x3，mat3x4</li><li>整型向量使用ivec前缀</li><li>布尔向量使用bvec前缀</li></ul><h3 id="矩阵表示">矩阵表示</h3><p>mat3x4表示三列四行的矩阵，对应C++中的[4][3]矩阵</p><h2 id="限定符">限定符</h2><h3 id="布局限定符-layout">布局限定符(layout)</h3><ul><li>只能用于顶点着色器的输入</li><li>顶点着色器的输出和片段着色器不可使用</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> vPosition;  <span class="comment">// 指定输入变量vPosition的绑定位置为0</span></span><br></pre></td></tr></table></figure><h3 id="数据传输">数据传输</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将顶点数组传入着色器向量</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, vVertices);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活对应位置的向量</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="类型限定符">类型限定符</h3><h4 id="in">in</h4><p>用于声明着色器的输入变量</p><h4 id="out">out</h4><p>声明着色器阶段的输出变量，这些变量会传递到下一个着色器阶段</p><h4 id="invariant">invariant</h4><p>确保多道渲染时着色器计算结果的一致性，避免因计算顺序等因素导致的误差</p><h4 id="uniform">uniform</h4><ul><li>指定uniform类型变量，其值在绘制调用间保持不变</li><li>操作uniform的方法：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(programId);</span><br><span class="line"><span class="built_in">glUniform2f</span>(offsetLocationId, fXOffset, fYOffset);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图形编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> GLSL </tag>
            
            <tag> 图形编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt+OpenGL+FFmpeg实现GPU硬解码视频播放</title>
      <link href="/posts/f4071fe9.html"/>
      <url>/posts/f4071fe9.html</url>
      
        <content type="html"><![CDATA[<h1>OpenGL+FFmpeg实现GPU硬解码视频播放</h1><h2 id="OpenGL渲染流程">OpenGL渲染流程</h2><h3 id="1-着色器准备">1. 着色器准备</h3><p>需要准备:</p><ul><li>顶点着色器代码</li><li>片段着色器代码</li><li>顶点数组</li><li>索引缓冲对象(IBO)数组</li></ul><h3 id="2-缓冲区设置">2. 缓冲区设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并绑定VAO</span></span><br><span class="line">GLuint VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并绑定VBO和IBO</span></span><br><span class="line">GLuint VBO, IBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;IBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入数据</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, IBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="3-着色器编译与链接">3. 着色器编译与链接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译着色器</span></span><br><span class="line">program.<span class="built_in">addShaderFromSourceCode</span>(QOpenGLShader::Vertex, vertexShaderSource);</span><br><span class="line">program.<span class="built_in">addShaderFromSourceCode</span>(QOpenGLShader::Fragment, fragmentShaderSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接程序</span></span><br><span class="line">program.<span class="built_in">link</span>();</span><br><span class="line">program.<span class="built_in">bind</span>();</span><br></pre></td></tr></table></figure><h3 id="4-属性指针设置">4. 属性指针设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应着色器中的layout (location = 0)</span></span><br><span class="line">program.<span class="built_in">enableAttributeArray</span>(<span class="number">0</span>);  <span class="comment">// 顶点位置</span></span><br><span class="line">program.<span class="built_in">enableAttributeArray</span>(<span class="number">1</span>);  <span class="comment">// 纹理坐标</span></span><br></pre></td></tr></table></figure><h3 id="5-矩阵变换">5. 矩阵变换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置MVP矩阵</span></span><br><span class="line">QMatrix4x4 model, view, projection;</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br></pre></td></tr></table></figure><h2 id="FFmpeg硬解码部分">FFmpeg硬解码部分</h2><h3 id="1-初始化硬解码器">1. 初始化硬解码器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找硬解码器</span></span><br><span class="line"><span class="type">const</span> AVCodec *codec = <span class="built_in">avcodec_find_decoder_by_name</span>(<span class="string">&quot;h264_cuvid&quot;</span>); <span class="comment">// NVIDIA GPU</span></span><br><span class="line"><span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">    codec = <span class="built_in">avcodec_find_decoder_by_name</span>(<span class="string">&quot;h264_qsv&quot;</span>);  <span class="comment">// Intel GPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-解码并传输到GPU">2. 解码并传输到GPU</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解码后直接得到GPU纹理</span></span><br><span class="line">AVFrame *frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="built_in">avcodec_send_packet</span>(codecContext, packet);</span><br><span class="line"><span class="built_in">avcodec_receive_frame</span>(codecContext, frame);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OpenGL纹理</span></span><br><span class="line">GLuint texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><h2 id="渲染循环">渲染循环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清空缓冲</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定程序和纹理</span></span><br><span class="line">    program.<span class="built_in">bind</span>();</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67ea86de8e36ed84184859cb_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:a8msW1EK2bX_E-38bWanGWW4DcI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea87b4205d5713c0bf8b46_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5JY2dB8a0x_1kstKpMmOT5jajaw=" alt="图片1"></p><h2 id="注意事项">注意事项</h2><ol><li><p>硬解码支持:</p><ul><li>需要确保GPU支持对应格式的硬解码</li><li>需要正确安装GPU驱动</li></ul></li><li><p>性能优化:</p><ul><li>使用PBO(Pixel Buffer Object)进行异步传输</li><li>考虑使用多重缓冲</li></ul></li><li><p>同步处理:</p><ul><li>注意音视频同步</li><li>控制帧率</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> OpenGL </tag>
            
            <tag> FFmpeg </tag>
            
            <tag> GPU加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt5+FFmpeg实现视频软解码播放</title>
      <link href="/posts/fd1aef76.html"/>
      <url>/posts/fd1aef76.html</url>
      
        <content type="html"><![CDATA[<h1>Qt5+FFmpeg实现视频软解码播放</h1><h2 id="基本流程">基本流程</h2><ol><li>使用FFmpeg解封装获取视频流</li><li>对视频流进行解码得到原始数据</li><li>将解码后的数据转换为Qt可显示的格式</li><li>使用Qt组件显示视频画面</li></ol><h2 id="主要步骤">主要步骤</h2><h3 id="1-初始化FFmpeg">1. 初始化FFmpeg</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册所有组件</span></span><br><span class="line"><span class="built_in">av_register_all</span>();</span><br><span class="line"><span class="comment">// 打开视频文件</span></span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;formatContext, filename, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 获取流信息</span></span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(formatContext, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h3 id="2-查找视频解码器">2. 查找视频解码器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取视频流索引</span></span><br><span class="line">videoIndex = <span class="built_in">av_find_best_stream</span>(formatContext, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取解码器</span></span><br><span class="line">AVCodec *codec = <span class="built_in">avcodec_find_decoder</span>(formatContext-&gt;streams[videoIndex]-&gt;codecpar-&gt;codec_id);</span><br></pre></td></tr></table></figure><h3 id="3-解码并显示">3. 解码并显示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取视频帧</span></span><br><span class="line"><span class="built_in">av_read_frame</span>(formatContext, packet);</span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="built_in">avcodec_send_packet</span>(codecContext, packet);</span><br><span class="line"><span class="built_in">avcodec_receive_frame</span>(codecContext, frame);</span><br><span class="line"><span class="comment">// 转换为RGB格式</span></span><br><span class="line"><span class="built_in">sws_scale</span>(swsContext, frame-&gt;data, frame-&gt;linesize, <span class="number">0</span>, codecContext-&gt;height,</span><br><span class="line">          frameRGB-&gt;data, frameRGB-&gt;linesize);</span><br><span class="line"><span class="comment">// 显示画面</span></span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(frameRGB-&gt;data[<span class="number">0</span>], codecContext-&gt;width, codecContext-&gt;height, </span></span></span><br><span class="line"><span class="params"><span class="function">             QImage::Format_RGB32)</span></span>;</span><br><span class="line">label-&gt;<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br></pre></td></tr></table></figure><h2 id="部分代码图片">部分代码图片</h2><p><img src="https://cdn-a.markji.com/files/67ea4ced8e36ed841840aef9_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:0oKoHUP8QToYpe52ZzlRFuDU4fI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea4d4c205d5713c0b740e2_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ArjYpTLoeAf_jD2eYls8bfegURI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea4e4a8e36ed841840da6a_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:p9GWgo9KlxiCFrWDpwrGFFEOcb8=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea5167205d5713c0b7d299_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:pnGhA5vUgjOD2j1jeIcako17Ku0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea51ea205d5713c0b7e150_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:kYBdJwcbpc9hzbyzsEt6QVNkaNQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54818e36ed8418422ffe_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:31FoxGoEK8vYqAJKDGWXS35mbSQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54af8e36ed8418423956_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:M65_RmAy6Z3G-i1E-F1oQbEpEDA=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54d68e36ed8418423ff2_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:dl3u7WCx1V5fZlwBV1tIqEvo9vs=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea56d7205d5713c0b887a0_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:wULFepBr_NTRnAr1AFkRYQDWsrk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea5a08205d5713c0b92436_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Eo7PAY6RNuLrWE9awS8bpV4Mcrc=" alt="图片1"></p>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Qt </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Qt中使用FFmpeg</title>
      <link href="/posts/9b502338.html"/>
      <url>/posts/9b502338.html</url>
      
        <content type="html"><![CDATA[<h1 id="在Qt中使用FFmpeg实现播放和录音"><a href="#在Qt中使用FFmpeg实现播放和录音" class="headerlink" title="在Qt中使用FFmpeg实现播放和录音"></a>在Qt中使用FFmpeg实现播放和录音</h1><h2 id="初始尝试"><a href="#初始尝试" class="headerlink" title="初始尝试"></a>初始尝试</h2><p>从CSDN中找到了对应的库并进行修改，最终编译成功。但运行时发现没有对应的输入声音设备。</p><h2 id="查看设备"><a href="#查看设备" class="headerlink" title="查看设备"></a>查看设备</h2><p>使用FFmpeg命令查看可用设备:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -list_devices <span class="literal">true</span> -f dshow -i dummy</span><br></pre></td></tr></table></figure><br><img src="https://cdn-a.markji.com/files/67e7e6c2205d5713c080d12b_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:HlFFCuvBB0KSVXRTfKUfHs_zWYY=" alt="图片1"></p><h2 id="录制测试"><a href="#录制测试" class="headerlink" title="录制测试"></a>录制测试</h2><p>尝试直接使用FFmpeg命令录制:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f dshow -i audio=<span class="string">&quot;麦克风阵列 (Realtek(R) Audio)&quot;</span> -t 5 test.wav</span><br></pre></td></tr></table></figure><br>录制失败，最后发现是没有打开麦克风权限。解决权限问题后成功录制音频。<br><img src="https://cdn-a.markji.com/files/67e7f6222f58dfdf11a28259_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:P57m6HSucCpw477ZThLl9ycR9sE=" alt="图片1"></p><h2 id="音频播放实现"><a href="#音频播放实现" class="headerlink" title="音频播放实现"></a>音频播放实现</h2><p>在论坛找到播放代码，发现使用的是<code>&lt;QAudioFormat&gt;</code>中的<code>QAudioOutput</code>。但在Qt6中它已被<code>QAudioSink</code>取代。</p><h2 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h2><p>添加头文件后仍然报错，最终在CMakeLists.txt中添加:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Qt6::Multimedia</span><br></pre></td></tr></table></figure><br>才解决了头文件找不到的问题。<br><img src="https://cdn-a.markji.com/files/67e7fa65205d5713c08396ca_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:UVepqCC-P2xPFN7e-CcqjiRjrEU=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e80df9205d5713c086279e_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:LkbnqLWkqBpgs5XhdSxMzqpyeRk=" alt="图片1"></p><h2 id="重采样问题"><a href="#重采样问题" class="headerlink" title="重采样问题"></a>重采样问题</h2><p>重采样相关的代码编译一直不通过。</p><p>即使参考官方文档的示例也无法运行，最终不得不寻找其他解决方案。<br> <img src="https://cdn-a.markji.com/files/67e812cf205d5713c086a286_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Iidek_AwIhs3x_vdFwJcPRHMIvg=" alt="图片1"><br> <img src="https://cdn-a.markji.com/files/67e816252f58dfdf11a68af8_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:vz8s-IeSIVWjNEB1jsY88wphH1o=" alt="图片1"></p>]]></content>
      
      
      <categories>
          
          <category> Qt开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Qt </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装一个好用的C++20协程</title>
      <link href="/posts/5950a8c.html"/>
      <url>/posts/5950a8c.html</url>
      
        <content type="html"><![CDATA[<h1>封装C++20协程</h1><h2 id="基本概念">基本概念</h2><p>在C++20中,只要函数返回值是Task类型,并使用co_return返回,该函数就自动成为一个协程函数。</p><p>Task不仅仅是一个&quot;配置文件&quot;,它还承担着协程的核心管理职责。<br><img src="https://cdn-a.markji.com/files/67e5149181bdefd1be1b48a1_hd.png?e=1743071911923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:qD4gzPadJ_pcN2NUgOz7CfrLvuA=" alt="图片1"></p><h2 id="核心原理">核心原理</h2><h3 id="协程的执行控制">协程的执行控制</h3><p>一个返回Task的函数本身就是协程,其内部代码会在以下情况下异步执行:</p><ul><li>co_await 语句控制</li><li>co_return 语句控制</li></ul><h3 id="恢复协程的两种方式">恢复协程的两种方式</h3><ol><li>内部恢复:</li></ol><ul><li>通过handle.resume()</li><li>由异步等待操作触发(如Delay的await_suspend)</li></ul><ol start="2"><li>外部恢复:</li></ol><ul><li>通过task2.resume()显式调用</li><li>主动从外部恢复协程执行</li></ul><p>这两种方式都会立即恢复协程并从挂起点继续执行,最终到达co_return。</p><h2 id="实践发现">实践发现</h2><p>在实际使用中发现一个有趣的现象:</p><ul><li>注释掉handle.resume()不影响程序运行</li><li>但注释掉main函数中的resume()会导致程序卡住<br><img src="https://cdn-a.markji.com/files/67e50d7bd5e9e782bf746323_hd.png?e=1743071911923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Bqc5H0LAPJjBWn_d_qcFVY0rLxk=" alt="图片1"></li></ul><h2 id="编译命令">编译命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> -std=c++20 test.cpp</span><br></pre></td></tr></table></figure><h2 id="完整头文集">完整头文集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        T value_;</span><br><span class="line">        std::exception_ptr exception_;</span><br><span class="line"></span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">            value_ = std::<span class="built_in">move</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            exception_ = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Awaiter 支持</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存当前等待的协程句柄</span></span><br><span class="line">        waiting_handle_ = handle;</span><br><span class="line">        <span class="comment">// 恢复当前任务的执行</span></span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_) &#123;</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(handle_.<span class="built_in">promise</span>().value_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">handle_</span>(handle) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(Task&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">handle_</span>(other.handle_) &#123;</span><br><span class="line">        other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(Task&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">            handle_ = other.handle_;</span><br><span class="line">            other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_)</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(handle_.<span class="built_in">promise</span>().value_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle_.<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; handle_;</span><br><span class="line">    <span class="keyword">mutable</span> std::coroutine_handle&lt;&gt; waiting_handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化 void 类型的 Task</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        std::exception_ptr exception_;</span><br><span class="line"></span><br><span class="line">        <span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Task</span>&lt;<span class="type">void</span>&gt;(std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            exception_ = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Awaiter 支持</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        waiting_handle_ = handle;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_) &#123;</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">handle_</span>(handle) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(Task&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">handle_</span>(other.handle_) &#123;</span><br><span class="line">        other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(Task&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">            handle_ = other.handle_;</span><br><span class="line">            other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_)</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle_.<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; handle_;</span><br><span class="line">    <span class="keyword">mutable</span> std::coroutine_handle&lt;&gt; waiting_handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCoroutine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例: 延迟执行的awaiter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delay</span> &#123;</span><br><span class="line">    std::chrono::milliseconds duration_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Delay</span><span class="params">(std::chrono::milliseconds duration)</span> : duration_(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">thread</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(duration_);</span><br><span class="line">            <span class="comment">//handle.resume();</span></span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始执行任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">42</span>;  <span class="comment">// 直接返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 带延迟的异步任务</span></span><br><span class="line"><span class="function">Task&lt;std::string&gt; <span class="title">delayed_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始延迟任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">Delay</span><span class="params">(std::chrono::milliseconds(<span class="number">4000</span>))</span></span>;  <span class="comment">// 等待1秒</span></span><br><span class="line">    <span class="keyword">co_return</span> <span class="string">&quot;完成&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3: 组合多个异步任务</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">combined_tasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result1 = <span class="keyword">co_await</span> <span class="built_in">simple_task</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个任务结果: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">delayed_task</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第二个任务结果: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行简单任务</span></span><br><span class="line">    <span class="keyword">auto</span> task1 = <span class="built_in">simple_task</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">1.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">1.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;简单任务结果: &quot;</span> &lt;&lt; task<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行延迟任务</span></span><br><span class="line">    <span class="keyword">auto</span> task2 = <span class="built_in">delayed_task</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">2.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">2.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;延迟任务结果: &quot;</span> &lt;&lt; task<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行组合任务</span></span><br><span class="line">    <span class="keyword">auto</span> task3 = <span class="built_in">combined_tasks</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">3.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">3.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    task<span class="number">3.</span><span class="built_in">get</span>();  <span class="comment">// 对于void类型的Task，仍然需要调用get()来检查异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>## 注意事项1. 协程函数必须:   - 返回Task类型   - 使用co_return返回值2. 恢复机制选择:   - 内部恢复适合自动触发的场景   - 外部恢复适合需要手动控制的场景3. 性能考虑:   - 协程切换有一定开销   - 适合IO密集型任务   - 不适合CPU密集型计算</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 协程 </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回调地狱和解决方法</title>
      <link href="/posts/f3d7b43c.html"/>
      <url>/posts/f3d7b43c.html</url>
      
        <content type="html"><![CDATA[<h1>回调地狱及其解决方案</h1><h2 id="什么是回调地狱">什么是回调地狱</h2><p>回调地狱(Callback Hell)一般指的是回调函数层层嵌套的现象,这种代码结构会导致:</p><ul><li>代码难以理解</li><li>维护成本高</li><li>调试困难</li></ul><h2 id="常见场景">常见场景</h2><p>回调地狱常见于异步编程中,特别是:</p><ol><li>事件驱动模型</li><li>基于回调的异步操作</li><li>网络请求</li><li>文件读取</li><li>定时任务</li></ol><h2 id="主要问题">主要问题</h2><h3 id="1-状态传递困难">1. 状态传递困难</h3><p>多层嵌套的回调需要在不同层级间传递各种状态,导致:</p><ul><li>代码难以调试</li><li>错误追踪困难</li><li>状态管理复杂</li></ul><h3 id="2-事件依赖链">2. 事件依赖链</h3><p>典型例子是处理EPOLLIN事件时需要等待其他异步事件完成,形成复杂的事件依赖关系。<br><img src="https://cdn-a.markji.com/files/67e4f7d681bdefd1be164eb2_hd.png?e=1743071664551&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:S7s8WGObEQ7yLIBHFVNx3hy0zQ0=" alt="图片1"></p><h3 id="3-框架局限">3. 框架局限</h3><p>即使是现代框架如Qt的信号槽机制,在处理复杂的异步流程时也可能遇到类似问题。</p><h2 id="解决方案">解决方案</h2><h3 id="1-有限状态机">1. 有限状态机</h3><p>使用状态机可以:</p><ul><li>清晰地定义状态转换</li><li>简化事件处理逻辑</li><li>提高代码可维护性<br><img src="https://cdn-a.markji.com/files/67e4f9ae81bdefd1be16b2e6_hd.png?e=1743071674079&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4qWtJeXCFx8d5jW3lGtTV0QP2fY=" alt="图片1"></li></ul><h3 id="2-协程">2. 协程</h3><p>协程提供了更优雅的解决方案:</p><ul><li>可以暂停执行中的线程</li><li>类似于给线程添加了goto能力</li><li>代码结构更清晰易读</li><li>接近同步代码的写法</li><li>避免了显式的回调嵌套</li></ul><p>协程相比传统回调的优势:</p><ul><li>线性的代码结构</li><li>更好的错误处理</li><li>更容易的状态管理</li><li>更接近人类思维方式</li></ul><h2 id="总结">总结</h2><p>回调地狱是异步编程中的常见问题,通过合适的设计模式(如状态机)或现代语言特性(如协程)可以有效避免这个问题。选择哪种解决方案需要根据具体场景和需求来决定。</p>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步编程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器压力测试</title>
      <link href="/posts/1c2eabf7.html"/>
      <url>/posts/1c2eabf7.html</url>
      
        <content type="html"><![CDATA[<h1>服务器性能测试</h1><h2 id="测试类型">测试类型</h2><p>服务器性能测试主要分为两类:</p><ul><li>连接吞吐测试: 测试TCP的连接建立和断开性能</li><li>数据吞吐测试: 测试数据收发能力<br><img src="https://cdn-a.markji.com/files/67e41be2d5e9e782bf5d5c27_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:gXwKTAIzYWZ958RV0rFgeQY-lkA=" alt="图片1"></li></ul><h2 id="测试工具尝试">测试工具尝试</h2><h3 id="1-hping3测试">1. hping3测试</h3><p>hping3主要用于TCP/UDP/ICMP测试,可以用于简单的TCP并发连接测试。</p><p>测试命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S -p 8080 -c 200 --fast 127.0.0.1</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>-S：发送SYN包(建立TCP连接)</li><li>-p 8080：目标端口8080</li><li>-c 200：发送200个连接</li><li>–fast：快速发送请求</li></ul><h3 id="2-测试问题">2. 测试问题</h3><p>hping3存在问题:只发送SYN包而不完成完整的三次握手。</p><p>尝试使用nping:</p><ul><li>可以同时发送SYN和ACK</li><li>但服务器直接返回RST拒绝连接</li><li>可能是因为同时发送导致的问题</li></ul><h3 id="3-wrk测试">3. wrk测试</h3><p>最后尝试使用http测试工具wrk:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t4 -c1000 -d10s http://127.0.0.1:8082/</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>4个线程</li><li>1000并发连接</li><li>持续10秒</li></ul><p>测试结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Running 10s test @ http://127.0.0.1:8082/</span><br><span class="line">  4 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     0.00us    0.00us   0.00us    -nan%</span><br><span class="line">    Req/Sec     0.00      0.00     0.00      -nan%</span><br><span class="line">  0 requests in 10.10s, 0.00B read</span><br><span class="line">  Socket errors: connect 0, read 221412, write 0, timeout 0</span><br><span class="line">Requests/sec:      0.00</span><br><span class="line">Transfer/sec:       0.00B</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67e4230481bdefd1be044f9c_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5xzRSXgWiCCrw0kE2d6C8Niiro4=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e423d9d5e9e782bf5f4193_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:KqAiU6anLcQmrkLlipX43k-OgLs=" alt="图片1"></p><h3 id="4-最终方案">4. 最终方案</h3><p>虽然wrk需要解析HTTP协议会带来额外开销,但考虑到测试的完整性,最终还是选择了:</p><ul><li>使用简单的HTTP响应</li><li>通过自定义client.cpp进行压力测试</li></ul><p><img src="https://cdn-a.markji.com/files/67e4e82681bdefd1be142474_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MsZPuHpePJdsXpwEhq9FlnU0bak=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e4e8f981bdefd1be1437e8_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Sgon3GxsCZKhCSOoiSfadNtK3qo=" alt="图片1"></p>]]></content>
      
      
      <categories>
          
          <category> c++开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> 性能测试 </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++20协程学习笔记</title>
      <link href="/posts/c8e6cc4a.html"/>
      <url>/posts/c8e6cc4a.html</url>
      
        <content type="html"><![CDATA[<h1>C++20协程学习笔记</h1><h2 id="协程基本概念">协程基本概念</h2><p>C++20引入了协程支持,提供了三个关键字:</p><h3 id="co-await">co_await</h3><p>用于等待一个异步操作完成。当遇到co_await时,协程会暂停执行并让出控制权,直到异步操作完成。</p><h3 id="co-return">co_return</h3><p>协程的返回语句,用于返回一个值并结束协程的执行。与普通函数的return不同,co_return会触发协程的清理流程。</p><h3 id="co-yield">co_yield</h3><p>暂停协程执行并返回一个值,但不会结束协程。当协程重新恢复执行时,会从co_yield的下一条语句继续执行。</p><h2 id="图片展示">图片展示</h2><p><img src="https://cdn-a.markji.com/files/67e3b3bed5e9e782bf4c5f5e_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:dm0hXEqtu0m3aIkrwD090-GKEM0=" alt="协程原理图1"></p><p><img src="https://cdn-a.markji.com/files/67e3b4c181bdefd1bef23aff_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:tiu4RI3FO9Ow1wjPMSnHm-9EJMQ=" alt="协程示例代码"></p><p><img src="https://cdn-a.markji.com/files/67e3e413d5e9e782bf530102_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:WQQWDUaan3U5TF1Q0MN4TgzVg9E=" alt="协程执行流程"></p><p><img src="https://cdn-a.markji.com/files/67e3e614d5e9e782bf533eae_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cBWMwkhuLg6n7m2K_L-bFA9lE3w=" alt="协程执行流程"></p>]]></content>
      
      
      <categories>
          
          <category> C++开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 协程 </tag>
            
            <tag> 异步编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTSP客户端</title>
      <link href="/posts/78dc036a.html"/>
      <url>/posts/78dc036a.html</url>
      
        <content type="html"><![CDATA[<h1>RTSP客户端实现</h1><h2 id="客户端类型">客户端类型</h2><p>有两种实现方式:</p><ul><li>拉流客户端</li><li>推流客户端</li></ul><p>之前的实现都是直接使用ffmpeg来推流到服务器。</p><h2 id="拉流命令">拉流命令</h2><h3 id="从RTSP拉流">从RTSP拉流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -rtsp_transport tcp -i rtsp://your_rtsp_url -c copy output.mp4</span><br></pre></td></tr></table></figure><h3 id="从RTMP拉流">从RTMP拉流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp://your_rtmp_url -c copy output.mp4</span><br></pre></td></tr></table></figure><h2 id="推流命令">推流命令</h2><h3 id="RTMP推流">RTMP推流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c:v libx264 -b:v 1M -c:a aac -b:a 128k -f flv rtmp://your_rtmp_server/live/stream</span><br></pre></td></tr></table></figure><h3 id="RTSP推流">RTSP推流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c:v libx264 -preset ultrafast -tune zerolatency -c:a aac -f rtsp rtsp://your_rtsp_server/live</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67e260cb05df26320832127d_hd.png?e=1742892963667&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:fHVoxBdXPEl4Ehy3Ogstwn8RE4g=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e261a805df263208322f45_hd.png?e=1742892963667&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:TWRdSVs2UbebpQEXk77sb2q_Dz4=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e2653e81bdefd1bec96919_hd.png?e=1742892963667&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:TsjvUR8TDJ9YzdWxpiwBxCBZMEQ=" alt="图片1"></p>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流媒体 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Qt中调用摄像头</title>
      <link href="/posts/41c91819.html"/>
      <url>/posts/41c91819.html</url>
      
        <content type="html"><![CDATA[<h1>Qt摄像头调用</h1><p><img src="https://cdn-a.markji.com/files/67e26e0f81bdefd1becac53f_hd.png?e=1742896807580&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:KKLRNxPYIsoAeyZ33CtujgoMhWE=" alt="图片1"></p><h2 id="视频帧处理">视频帧处理</h2><p>Qt 6 采集的视频帧是 QVideoFrame 格式,需要转换为 QImage 才能进行进一步处理,比如编码成 H.264 并保存为 MP4 文件。</p><h2 id="编码支持">编码支持</h2><p>Qt 本身不包含 H.264 或 AAC 编码功能，因此需要使用 FFmpeg 来进行编码和存储。<br><img src="https://cdn-a.markji.com/files/67e2727d81bdefd1becb7101_hd.png?e=1742896807580&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2o3jMUjyoQgaZdwiXwvZkYSel-o=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e273c005df263208355b7b_hd.png?e=1742896807580&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:XGfhJX89CRDkfaNyUkLwZ8uoVjM=" alt="图片1"></p><h2 id="extern关键字说明">extern关键字说明</h2><ul><li>extern主要用来告知编译器去外部查找定义,表示这里只是声明而没有定义,常用于头文件中声明全局变量</li><li>extern &quot;C&quot;用于告诉编译器这些引入的内容是C语言代码,不需要按照C++的命名规则来解析符号,避免解析错误</li></ul>]]></content>
      
      
      <categories>
          
          <category> Qt开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AAC音频解码</title>
      <link href="/posts/4aa94b70.html"/>
      <url>/posts/4aa94b70.html</url>
      
        <content type="html"><![CDATA[<h1>AAC音频解码</h1><p><img src="https://cdn-a.markji.com/files/67e113fc4e1cf4bdf4de9b84_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:jrtlGiHKozQdoQswVZm1Z4IsCJ0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e115d84e1cf4bdf4dedd66_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:XozHbjRj5GhfN44zC1HRMKtnk74=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e118ab8d016adbb48d03ce_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:xHd469LPFP1CY2K6iv9cMipU45k=" alt="图片1"><br>本质和h264封装进RTP数据包差不多,这里是把AAC封装进RTP数据包中进行传输。</p><h2 id="应用场景">应用场景</h2><p>此时就可以实现从客户端上传到服务器,然后服务器执行播放功能。<br><img src="https://cdn-a.markji.com/files/67e11ab44e1cf4bdf4dfbcf0_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:bfm5HqgqC3YcfPDerCySHvwLGow=" alt="图片1"></p><h2 id="播放命令">播放命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i rtsp://127.0.0.1:8554</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频中同时传输h264和aac</title>
      <link href="/posts/f5f059ad.html"/>
      <url>/posts/f5f059ad.html</url>
      
        <content type="html"><![CDATA[<h1>音视频同步传输</h1><h2 id="实现原理">实现原理</h2><p><img src="https://cdn-a.markji.com/files/67e123a54e1cf4bdf4e16b2c_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:hljxLZt4MgMKbfZllhhTpnKHXX4=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e1255a8d016adbb48f30ae_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cflNaN-tUpP_17v5oxghxc8X8Wk=" alt="图片1"><br>本质上是创建了两个线程,然后分别处理视频和音频的传输:</p><ul><li>一个线程负责h264视频数据的传输</li><li>另一个线程负责aac音频数据的传输</li></ul><p>通过多线程实现音视频的并行传输。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>h264封装到RTP数据包进行传输</title>
      <link href="/posts/5b7142ef.html"/>
      <url>/posts/5b7142ef.html</url>
      
        <content type="html"><![CDATA[<h1>h264封装到RTP数据包进行传输</h1><h2 id="RTP数据包结构">RTP数据包结构</h2><p>报文下面的数据称为有效载荷(payload)</p><h2 id="h264编码原理">h264编码原理</h2><p>h264是一种视频压缩技术,主要包含三种帧:</p><ul><li>i帧(关键帧): 不借助其他帧的独立完整帧</li><li>p帧: 需要参考前面帧的预测帧</li><li>b帧: 需要参考前后帧的双向预测帧</li></ul><p>使用GOP(Group Of Pictures)组来防止丢包。因为p帧这种全部参考前面帧的,一旦丢包后面就都会乱掉。</p><h2 id="h264结构">h264结构</h2><p>h264分为两层:</p><ul><li>网络提取层(NAL)</li><li>视讯编码层(VCL)</li></ul><p>编码后的数据流在网络提取层中传输。例如一个由100张图片组成的视频,每张图片压缩后都会得到一个独立的NAL单元(总共100个NAL)。</p><p>NAL的第一个字节用于标识当前帧类型(i/p/b帧)。</p><h2 id="IDR帧">IDR帧</h2><p>IDR帧是一种特殊的I帧:</p><ul><li>I帧是关键帧,可以独立解码</li><li>当IDR帧出现时会清空之前的参考帧(即时刷新Refresh)</li></ul><h2 id="MP4与h264">MP4与h264</h2><p>使用ffmpeg可以将MP4解析成h264文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -codec copy -bsf:h264 mp4toannexb -f h264 test.h264</span><br></pre></td></tr></table></figure><p>PS: MP4本质上是在h264基础上添加了头尾信息的封装格式,所以解封装过程主要是数据拷贝。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTSP协议</title>
      <link href="/posts/9577f504.html"/>
      <url>/posts/9577f504.html</url>
      
        <content type="html"><![CDATA[<h1>RTSP协议</h1><h2 id="协议组成">协议组成</h2><p>包括RTSP、RTP、RTCP三个协议：</p><ul><li>RTSP: 负责建立连接通道</li><li>RTP(Real Time Transport Protocol 实时传输协议): 负责传输数据</li><li>RTCP: 负责传输质量控制</li></ul><h2 id="传输协议要求">传输协议要求</h2><ul><li>RTSP需要使用TCP协议</li><li>RTP和RTCP既可以使用TCP也可以使用UDP<br><img src="https://cdn-a.markji.com/files/67dfde4b63fe6caddd0ed86a_hd.png?e=1742731753507&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:nANoNala-Z_7NOgpyiexGRAhdq8=" alt="图片1"></li></ul><h2 id="SDP描述">SDP描述</h2><p>SDP包含两个层次的描述:</p><ul><li>会话级描述</li><li>媒体级描述(比如同时存在视频和音频就会有两个媒体级别)<br><img src="https://cdn-a.markji.com/files/67dfe27f5e2541566caed143_hd.png?e=1742731753507&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:wwCw9QuKdbiHiMfo2S64WUdijew=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67dfe43263fe6caddd0f8543_hd.png?e=1742731753507&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:8nsOtckGYkk8m6-wYgBJTcupiLU=" alt="图片1"></li></ul><h2 id="端口分配">端口分配</h2><ul><li>RTP使用低端口号</li><li>RTCP使用高端口号</li></ul><h2 id="实现说明">实现说明</h2><p>在实际代码实现中并没有真正建立两个通道,因为使用TCP时可以直接合并RTP和RTCP。<br><img src="https://cdn-a.markji.com/files/67dfe5715e2541566caf4522_hd.png?e=1742731753507&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:q9x1WpsovlA-kT3z1bqaXDniV_g=" alt="图片1"></p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
            <tag> 流媒体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程八股</title>
      <link href="/posts/706f5e8.html"/>
      <url>/posts/706f5e8.html</url>
      
        <content type="html"><![CDATA[<h2 id="实现">实现</h2><p>这是一个基于 <code>ucontext</code> 的轻量级协程库，实现了 <strong>用户态上下文切换</strong>，支持 <strong>非抢占式协程调度</strong>。核心包括 <strong>协程管理（Routine）</strong> 和 <strong>调度器（Schedule）</strong>，采用 <strong>FIFO 调度策略</strong>，协程通过 <code>resume()</code> 切换到运行态，<code>yield()</code> 挂起并交回调度器。</p><ul><li>利用 <code>swapcontext()</code> 进行 <strong>寄存器和栈的上下文切换</strong>，避免线程切换的内核态开销。</li><li>支持 <strong>动态栈管理</strong>，通过 <strong>栈快照（<code>memcpy</code> 保存栈数据）</strong> 实现挂起与恢复。</li><li>适用于 <strong>高并发 IO 场景</strong>，可扩展为 <strong><code>epoll</code> 事件驱动</strong> 结合 <strong>异步 IO</strong>。</li></ul><h3 id="后续优化方向：">后续优化方向：</h3><ul><li><strong>多线程支持（work-stealing）</strong></li><li><strong>使用 <code>boost::context </code> 提升可移植性</strong></li><li><strong>优化调度算法</strong></li></ul><hr><h2 id="亮点">亮点</h2><ul><li><strong>纯用户态调度，低开销，高效执行</strong><ul><li><code>swapcontext()</code> 仅涉及 <strong>寄存器和栈切换</strong>，比 <code>std::thread</code> 的调度更轻量。</li></ul></li><li><strong>使用非抢占式调度，确保任务可控</strong></li><li><strong>采用栈快照（<code>memcpy</code> 备份数据）</strong><ul><li>在 <code>yield()</code> 时存储当前执行状态，<code>resume()</code> 时恢复。</li><li>避免 <code>setjmp/longjmp</code> 传统方法的局限性，提高灵活性和可维护性。</li></ul></li><li><strong>比线程池更轻量</strong><ul><li>避免大量线程带来的上下文切换和同步开销。</li></ul></li></ul><hr><h2 id="难点与解决方案">难点与解决方案</h2><h3 id="1-yield-需要保存协程的执行状态，否则恢复时会丢失现场">1. <code>yield()</code> 需要保存协程的执行状态，否则恢复时会丢失现场</h3><blockquote><p><strong>挑战</strong>：栈是动态增长的，如何正确地保存 &amp; 恢复执行环境？</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>使用 <code>memcpy</code> 备份协程栈</strong><ul><li>在 <code>yield()</code> 时，计算栈使用空间，并将数据拷贝到堆中，防止被覆盖。</li></ul></li><li><strong>动态分配存储空间</strong><ul><li>如果 <code>yield()</code> 时的栈大小变大，重新分配存储，确保数据完整性。</li></ul></li><li><strong>在 <code>resume()</code> 时恢复栈数据</strong><ul><li>然后调用 <code>swapcontext()</code> 切回协程。</li></ul></li></ul><h3 id="2-ucontext-API-兼容性问题">2. <code>ucontext</code> API 兼容性问题</h3><blockquote><p><strong>问题</strong>：未来的 Linux 可能移除 <code>ucontext</code>，如何保持代码的可移植性？</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>切换到 <code>Boost.Context</code></strong></li><li><strong>使用 Linux <code>swapcontext()</code> 替代方案</strong>，如 <code>fibers</code> 或 <code>libco</code>。</li></ul><h3 id="3-协程调度优化">3. 协程调度优化</h3><blockquote><p><strong>问题</strong>：目前是单线程 FIFO 调度，如果协程数量过多，可能出现某些协程长期得不到执行的问题。</p></blockquote><p><strong>优化方案：</strong></p><ul><li><strong>使用时间片调度</strong><ul><li>让 <code>yield()</code> 也能由调度器主动调用，防止某些任务长期占用 CPU。</li></ul></li><li><strong>基于优先级的调度</strong><ul><li>例如高优先级的协程可以优先执行（可结合任务权重机制）。</li></ul></li><li><strong>多线程 Work-Stealing</strong><ul><li>不同线程管理自己的协程池，当某个线程空闲时，可以从别的线程窃取任务，提升 CPU 资源利用率。</li></ul></li></ul><h3 id="4-如何让多个线程安全地调度协程？">4. 如何让多个线程安全地调度协程？</h3><blockquote><p><strong>问题</strong>：目前是单线程，但很多高并发场景需要多个线程并行执行协程。</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>多线程调度器（Work-Stealing）</strong><ul><li>每个线程有自己的 <code>Schedule</code>，但可以从别的线程偷取任务。</li></ul></li><li><strong>使用 <code>std::mutex</code> + <code>std::queue</code> 共享任务队列</strong><ul><li>当某个线程空闲时，可以从公共队列取任务。</li></ul></li><li><strong>无锁队列优化（如 MPSC Queue）</strong><ul><li>减少锁的开销，提高并发度。</li></ul></li></ul><hr><h2 id="总结">总结</h2><p>本协程库基于 <code>ucontext</code>，采用 <strong>非抢占式调度</strong>，支持 <strong>栈快照</strong>，适用于高并发 IO 场景。未来可以扩展多线程 <code>work-stealing</code> 以及更优的调度策略，提高整体性能。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协程 </tag>
            
            <tag> ucontext </tag>
            
            <tag> 异步IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 vcpkg 运行 redis++ 遇到的问题</title>
      <link href="/posts/be1ef227.html"/>
      <url>/posts/be1ef227.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>使用 vcpkg 安装 redis++ 库后，发现该库并没有 <code>.cmake</code> 文件，导致 <code>find_package</code> 无法找到它。</p><h2 id="现象分析">现象分析</h2><p>通过 <code>ls</code> 命令查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /root/vcpkg/installed/x64-linux/lib</span><br></pre></td></tr></table></figure><p>可以确认 redis++ 确实已经安装，并且在代码中可以跳转到对应的定义文件。但由于缺少 CMake 配置文件，只能手动指定路径进行连接。<br><img src="https://cdn-a.markji.com/files/67d9717eb49cc95a6c0f4ea3_hd.png?e=1742368508911&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:44busKLsAaG2t2U6WGRFo4uQL4s=" alt="图片1"></p><h2 id="解决尝试">解决尝试</h2><p>尝试手动指定库路径，但在链接时遇到错误，提示找不到某些函数定义，怀疑是动态库和静态库混用的问题。然而最终仍然没有找到具体原因。</p><h2 id="结果总结">结果总结</h2><ol><li><strong>好消息</strong>：redis++ 通过手动指定路径找到了。</li><li><strong>坏消息</strong>：仍然无法正确链接，可能与库的静态/动态方式混用有关。</li></ol><p>最后还是没能解决这个问题，先摆烂了 😭。</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> vcpkg </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis++ </tag>
            
            <tag> vcpkg </tag>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 C++ 运行 Kafka 和 Elasticsearch</title>
      <link href="/posts/b71a46cc.html"/>
      <url>/posts/b71a46cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="Elasticsearch-处理方式">Elasticsearch 处理方式</h2><p>Elasticsearch 通常直接使用 HTTP 报文通信，因此不需要额外下载 C++ 库，直接通过 HTTP 请求即可进行操作。</p><h2 id="Kafka-处理方式">Kafka 处理方式</h2><p>Kafka 我使用的是 vcpkg 提供的包，但和之前遇到的问题一样，<code>find_package</code> 无法直接找到，所以还是手动加入了库的路径。<br><img src="https://cdn-a.markji.com/files/67da545476d0a5611b7c05e6_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:OVEEkK8mOAmVOjHyA1CWapEMpvM=" alt="图片1"></p><h2 id="遇到的问题">遇到的问题</h2><ol><li><p><strong>AI 帮的倒忙</strong><br>在调用某个接口时，AI 生成的代码少了两个参数，导致无法正常执行。最后还是我自己手动跳转到定义里查看并修正了。</p></li><li><p><strong>Docker Compose 启动多个容器</strong><br>我使用 <code>docker-compose</code> 一键启动了多个服务，包括 Redis、Kafka 等，但在尝试运行时，Kafka 无法正确收到消息，导致程序无法正常工作。<br><img src="https://cdn-a.markji.com/files/67da6357b49cc95a6c2923c7_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:O71hPvwIkVaNim_dDLTqxlJhPos=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67da644fb49cc95a6c293c85_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:j5hKpx7807ueI8nBNuZ3yhQu3SA=" alt="图片1"></p></li><li><p><strong>最终解决方案</strong><br>去 CSDN 找了代码，终于能正常执行了，AI 这次还是不行 😓。</p></li></ol><h2 id="总结">总结</h2><ul><li>Elasticsearch 直接用 HTTP 通信，无需额外的 C++ 库。</li><li>Kafka 需要手动指定路径才能使用。</li><li><code>docker-compose</code> 方便管理多个容器，但 Kafka 运行过程中可能遇到无法接收消息的问题。</li><li>代码有问题时，AI 可能会犯病，还是要多检查文档和源码。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Kafka </category>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcpkg </tag>
            
            <tag> Docker </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列的基础编写</title>
      <link href="/posts/be5c987b.html"/>
      <url>/posts/be5c987b.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-任务封装">1. 任务封装</h2><p>首先实现了 <code>Task</code> 类，这是一个简单的包裹类，仅包含任务的 <strong>名称</strong> 和 <strong>参数列表</strong>，用于封装任务信息。</p><h2 id="2-任务处理器设计">2. 任务处理器设计</h2><p>为了让任务处理更加模块化，我设计了 <strong>任务处理器抽象基类</strong>，所有具体任务处理方法都需要继承该基类，并重写 <code>process</code> 函数，以实现具体任务的处理逻辑。</p><h2 id="3-处理器注册机制">3. 处理器注册机制</h2><p>然后实现了 <strong>处理器注册类</strong>，用于管理不同任务处理器的映射关系：</p><ul><li><strong>Key</strong>：任务名称</li><li><strong>Value</strong>：对应的任务处理器类</li></ul><p>当需要处理 <code>Task</code> 时，会从注册类中获取与 <code>Task</code> 名称对应的处理器，并传入 <code>Task</code> 进行执行。</p><p><strong>示例流程：</strong><br>如果 <code>Task</code> 是 <strong>A 类型</strong>，注册类会找到 <strong>A 处理器</strong>，然后将 <code>Task</code> 传入处理器以获取参数列表并执行。</p><h2 id="4-单元测试">4. 单元测试</h2><p>代码编写完成后，学习并使用 <strong>Google Test（GTest）</strong> 进行单元测试，以验证任务队列的正确性。</p><hr><h2 id="总结">总结</h2><ul><li><code>Task</code> 作为基础封装类，仅存储名称和参数列表。</li><li>任务处理器通过继承基类实现 <code>process</code> 方法。</li><li>处理器注册类维护任务名称到处理器的映射，实现动态调用。</li><li>使用 Google Test 进行单元测试，提高代码的可靠性</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 任务队列 </tag>
            
            <tag> Google Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 基础知识总结</title>
      <link href="/posts/d00def19.html"/>
      <url>/posts/d00def19.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Kafka-应用场景">1. Kafka 应用场景</h2><p>Kafka 作为一款高吞吐的分布式消息系统，适用于多种应用场景：</p><ul><li><strong>消息队列</strong>：用于解耦生产者和消费者，提高系统的伸缩性。</li><li><strong>日志收集</strong>：集中存储和处理系统日志，方便分析和监控。</li><li><strong>流计算</strong>：处理实时数据流，将数据传输给实时计算系统进行计算。</li><li><strong>事件溯源</strong>：记录事件发生的历史，以便后续回溯和分析。</li><li><strong>Metrics 采集</strong>：收集和存储系统的监控指标数据。</li></ul><hr><h2 id="2-Kafka-组件介绍">2. Kafka 组件介绍</h2><p>Kafka 由多个核心组件组成：</p><ul><li><p><strong>生产者（Producer）</strong>：负责将消息发送到 Kafka。</p></li><li><p><strong>消费者（Consumer）</strong>：从 Kafka 读取消息进行处理。</p></li><li><p><strong>消息代理（Broker）</strong>：存储和管理消息，负责接收、存储和转发数据。</p></li><li><p><strong>协调器（Zookeeper）</strong>：提供分布式协调和管理任务。</p></li><li><p><strong>主题（Topic）</strong>：类似广播频道，生产者将消息发送到指定的 <code>Topic</code>，消费者从 <code>Topic</code> 读取消息。</p><p>创建 Topic 命令示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 3 --topic my-topic</span><br></pre></td></tr></table></figure></li><li><p><strong>分区（Partition）</strong>：一个 <code>Topic</code> 进一步分为多个 <code>Partition</code>，可以提高数据局部性、支持并行处理，实现负载均衡。</p></li></ul><hr><h2 id="3-Kafka-消息有序性">3. Kafka 消息有序性</h2><p>Kafka 的消息处理方式：</p><ul><li><strong>不同分区的消息是并行处理的</strong>，因此 Kafka <strong>全局上不保证消息的有序性</strong>。</li><li><strong>同一分区内的消息是严格有序的</strong>，消费者会按照 <code>offset</code> 依次消费。</li></ul><hr><h2 id="4-Offset（偏移量）">4. Offset（偏移量）</h2><ul><li>Kafka 中的每条消息都有唯一的 <strong>Offset</strong>（偏移量），从 <code>0</code> 开始递增。</li><li>Offset 用于追踪消息消费进度，每个消费者组都会维护自己的 Offset。</li></ul><hr><h2 id="5-Consumer-Group（消费者组）">5. Consumer Group（消费者组）</h2><ul><li><p><strong>一个分区（Partition）只能由一个组员消费</strong>，保证分区数据不会被组内多个消费者重复消费。</p></li><li><p><strong>多个 Consumer Group 可以同时消费同一个 Topic</strong>，不同组之间不会相互影响。例如：</p><ul><li><code>Group A</code> 读取 <code>Topic X</code> 的消息一次。</li><li><code>Group B</code> 也可以独立读取 <code>Topic X</code> 的消息一次。</li></ul></li></ul><p>这样，每个组都可以独立处理相同的消息，实现多用途消费。</p><hr><h2 id="6-总结">6. 总结</h2><ul><li>Kafka 适用于消息队列、日志收集、流计算、事件溯源等场景。</li><li>核心组件包括 Producer、Consumer、Broker、Zookeeper、Topic、Partition 等。</li><li>消息的全局有序性无法保证，但 <strong>同一分区内是有序的</strong>。</li><li>Offset 记录消息的消费进度，每个 Consumer Group 维护自己的 Offset。</li><li>通过 Consumer Group 机制，可以控制消息的分发和重复消费。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> 实时流处理 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker一点小记录</title>
      <link href="/posts/bc68fe1f.html"/>
      <url>/posts/bc68fe1f.html</url>
      
        <content type="html"><![CDATA[<h1>Docker 基础使用</h1><h2 id="1-Docker-组件">1. Docker 组件</h2><p>Docker 主要由以下三个核心组件组成：</p><ul><li><strong>镜像（Image）</strong>：类似于软件的 <strong>蓝图</strong>，定义了容器运行所需的环境。</li><li><strong>容器（Container）</strong>：基于镜像创建的 <strong>实例</strong>，可以运行应用。</li><li><strong>引擎（Engine）</strong>：Docker 的 <strong>核心管理组件</strong>，负责容器的创建、运行、管理等。</li></ul><hr><h2 id="2-如何构建镜像（Blueprint）">2. 如何构建镜像（Blueprint）</h2><ol><li><strong>编写 <code>Dockerfile</code></strong> 定义镜像构建过程。</li><li><strong>构建镜像</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my_image .</span><br></pre></td></tr></table></figure></li><li><strong>发布镜像</strong>：<ul><li>登录 Docker Hub：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></li><li>推送镜像：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push my_image</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>使用镜像</strong>：<ul><li>运行容器：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my_container my_image</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="使用-Docker-执行-CI-CD">使用 Docker 执行 CI/CD</h2><p>Docker 可与 <strong>Jenkins</strong>、<strong>GitHub Actions</strong> 结合使用，实现 CI/CD：</p><ul><li><strong>Jenkins</strong> + Docker：用于企业级 CI/CD 自动化部署。</li><li><strong>GitHub Actions</strong>（适用于个人小项目/免费方案）。</li></ul><hr><h2 id="3-查看容器日志">3. 查看容器日志</h2><p>使用 <code>docker logs</code> 命令查看容器日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs my_container</span><br></pre></td></tr></table></figure><p>支持多种日志模式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f my_container  <span class="comment"># 持续查看日志（实时刷新）</span></span><br><span class="line">docker logs --<span class="built_in">tail</span> 100 my_container  <span class="comment"># 查看最后100行日志</span></span><br><span class="line">docker logs --since 10m my_container  <span class="comment"># 查看最近10分钟的日志</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-Docker-数据卷（Volume）">4. Docker 数据卷（Volume）</h2><p>Docker <strong>数据卷</strong> 主要用于持久化存储数据，容器销毁时数据不会丢失。</p><h3 id="1-创建数据卷">1. 创建数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my_data</span><br></pre></td></tr></table></figure><h3 id="2-运行容器并挂载数据卷">2. 运行容器并挂载数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my_container -v my_data:/app/data nginx</span><br></pre></td></tr></table></figure><h3 id="3-多个容器共享数据卷">3. 多个容器共享数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name container1 -v my_data:/app/data nginx</span><br><span class="line">docker run -d --name container2 -v my_data:/app/data alpine</span><br></pre></td></tr></table></figure><h3 id="4-查看数据卷信息">4. 查看数据卷信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect my_data</span><br></pre></td></tr></table></figure><hr><h2 id="5-Docker-网络">5. Docker 网络</h2><p>Docker 提供多种 <strong>网络模式</strong>，用于管理容器间的通信：</p><h3 id="1-Bridge（桥接模式）">1. <strong>Bridge（桥接模式）</strong></h3><ul><li><strong>默认模式</strong>，适用于多个容器之间的通信。</li><li>在相同桥接网络的容器可以通过<strong>容器名</strong>互相访问。</li><li>创建桥接网络并将容器连接到该网络：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create my_bridge</span><br><span class="line">docker run -d --name container1 --network my_bridge_network nginx</span><br><span class="line">docker run -d --name container2 --network my_bridge</span><br></pre></td></tr></table></figure></li><li>使用 <strong>Docker Compose</strong> 可以自动创建共享网络，提供<strong>基础的服务发现功能</strong>。</li></ul><h3 id="2-Host（主机模式）">2. <strong>Host（主机模式）</strong></h3><ul><li>容器直接使用 <strong>宿主机的网络</strong>，不做隔离，具有更高的网络性能。</li></ul><h3 id="3-None（无网络）">3. <strong>None（无网络）</strong></h3><ul><li>容器没有任何网络连接，适用于需要完全隔离的环境。</li></ul><h3 id="4-Overlay-网络">4. <strong>Overlay 网络</strong></h3><ul><li>用于 <strong>Docker Swarm</strong> 集群，使多个主机上的容器可相互通信。</li></ul><h3 id="5-Macvlan-模式">5. <strong>Macvlan 模式</strong></h3><ul><li>允许容器直接与宿主机的网络通信，适用于需要独立 <strong>IP 地址</strong> 的场景。</li></ul><hr><h2 id="6-如何优化-Docker-启动时间">6. 如何优化 Docker 启动时间</h2><ol><li><strong>使用较小的基础镜像</strong>（如 <code>alpine</code> 代替 <code>ubuntu</code>）。</li><li><strong>利用构建缓存</strong>：避免每次 <code>docker build</code> 都从头开始构建。</li><li><strong>减少容器层数</strong>：使用多阶段构建来减少镜像大小。</li><li><strong>本地缓存镜像</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull my_image</span><br></pre></td></tr></table></figure></li><li><strong>优化应用启动方式</strong>：如 <strong>多阶段构建</strong>，减少不必要的运行时依赖。</li></ol><hr><h2 id="6-使用-docker-compose">6. 使用 <code>docker-compose</code></h2><p><code>docker-compose</code> 允许用 <strong>YAML 配置文件</strong> 定义多个容器，并通过一个命令启动所有容器：</p><ol><li><strong>编写 <code>docker-compose.yml</code> 文件</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>docker-compose</code> 启动容器</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="6-使用多阶段构建优化镜像体积">6. 使用多阶段构建优化镜像体积</h2><p>多阶段构建可减少最终镜像的大小：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：构建应用</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.18</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：创建更小的最终镜像</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /app/mybinary .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./mybinary&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li><strong>第一阶段</strong>：使用完整的 Golang 环境构建二进制文件。</li><li><strong>第二阶段</strong>：使用 <code>alpine</code> 作为基础镜像，仅复制最终生成的二进制文件，减少体积。</li></ul><hr><h2 id="6-Docker-Swarm（集群）">6. Docker Swarm（集群）</h2><p>Docker Swarm 是 Docker 官方提供的 <strong>轻量级容器编排工具</strong>：</p><ul><li>允许将多个 Docker 主机集合成一个<strong>虚拟</strong> Docker 主机。</li><li>适用于 <strong>轻量级的集群管理</strong>，相比 Kubernetes 更加简单易用。</li></ul><hr><h2 id="7-总结">7. 总结</h2><ul><li>Docker 提供了<strong>镜像、容器、网络</strong>等组件，简化应用的<strong>打包、分发、部署</strong>。</li><li>通过 <strong>Dockerfile</strong> 构建自定义镜像，并使用 <strong>Docker Hub</strong> 分发。</li><li>利用 <strong>Docker + CI/CD 工具</strong>（如 <strong>Jenkins</strong>、<strong>GitHub Actions</strong>），可实现自动化部署。</li><li>通过 <strong>Docker Compose</strong> 快速启动多容器应用，简化管理。</li><li>使用 <strong>多阶段构建</strong> 可 <strong>优化镜像体积</strong>，提高拉取与启动速度。</li><li><strong>优化启动时间</strong> 可以通过：<ul><li>选择较小的基础镜像。</li><li>减少不必要的层数。</li><li>使用本地缓存提高构建效率。</li></ul></li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis八股文</title>
      <link href="/posts/c74dfdcd.html"/>
      <url>/posts/c74dfdcd.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Redis 基础使用</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 进入 Redis 终端</span></span><br><span class="line">使用 <span class="code">`redis-cli`</span> 进入 Redis 交互终端。</span><br><span class="line"></span><br><span class="line"><span class="section">## Redis 支持的数据类型</span></span><br><span class="line">Redis 支持五种数据类型：</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**String**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Hash**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**List**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Set**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Sorted Set（有序集合）**</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1. String</span></span><br><span class="line"><span class="code">```sh</span></span><br><span class="line"><span class="code">set name mike</span></span><br><span class="line"><span class="code">get name</span></span><br><span class="line"><span class="code">del name</span></span><br></pre></td></tr></table></figure><h3 id="2-Hash">2. Hash</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset user name Alice</span><br><span class="line">hget user name</span><br><span class="line">hgetall user</span><br><span class="line">hdel user name</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> <code>user</code> 在这里是表名，<code>name</code> 是 key。</p></blockquote><h3 id="3-List">3. List</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lpush queue task</span><br><span class="line">rpush queue task</span><br><span class="line">lpop queue</span><br><span class="line">rpop queue</span><br><span class="line">lrange queue 0 -1</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> <code>-1</code> 表示倒数第一个，<code>lrange queue 0 -1</code> 表示遍历从 <code>0</code> 到最后一个元素。</p></blockquote><h3 id="4-Set">4. Set</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd myset a</span><br><span class="line">sadd myset b</span><br><span class="line">sadd myset c</span><br><span class="line">smembers myset</span><br><span class="line">srem myset a</span><br></pre></td></tr></table></figure><h3 id="5-Sorted-Set">5. Sorted Set</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zadd scores 100 Alice</span><br><span class="line">zadd scores 200 Bob</span><br><span class="line">zrange scores 0 -1 withscores</span><br><span class="line">zrevrange scores 0 -1 withscores</span><br><span class="line">zrem scores Alice</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> 有序集合插入时需要提供权重值，<code>withscores</code> 表示按照权重遍历。</p></blockquote><hr><h2 id="配置文件位置">配置文件位置</h2><ul><li>配置文件路径：<code>/etc/redis/redis.conf</code></li><li>修改配置后需要重启 Redis：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart redis</span><br></pre></td></tr></table></figure></li><li>该配置文件可用于编辑 <strong>持久化</strong> 设置。</li></ul><hr><h2 id="Redis-持久化">Redis 持久化</h2><h3 id="1-RDB-快照持久化（保存数据到磁盘）">1. RDB 快照持久化（保存数据到磁盘）</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1   <span class="comment"># 900 秒（15 分钟）至少有 1 次写入操作，就保存 RDB</span></span><br><span class="line">save 300 10  <span class="comment"># 300 秒（5 分钟）至少有 10 次写入操作，就保存 RDB</span></span><br><span class="line">save 60 10000 <span class="comment"># 60 秒内有 10000 次写入操作，就保存 RDB</span></span><br></pre></td></tr></table></figure><h3 id="2-AOF-日志持久化">2. AOF 日志持久化</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span>   <span class="comment"># 启用 AOF</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>  <span class="comment"># AOF 文件名</span></span><br></pre></td></tr></table></figure><hr><h2 id="Redis-使用场景">Redis 使用场景</h2><ol><li><p><strong>缓存</strong></p><ul><li>存储常用数据，如页面渲染等。</li></ul></li><li><p><strong>实时系统</strong></p><ul><li>统计网站点击率、实时排行榜、点赞功能等。</li></ul></li><li><p><strong>消息队列</strong></p><ul><li>使用 <code>List</code> 和 <code>Pub/Sub</code> 可实现轻量级消息队列。</li></ul></li><li><p><strong>分布式锁</strong></p><ul><li>本质上与消息队列功能类似，可用于分布式环境下的锁管理。</li></ul></li><li><p><strong>计数器</strong></p><ul><li>Redis 具有原子操作能力，适合作为计数器，例如在线人数统计等。</li></ul></li></ol><hr><h2 id="Redis-为什么这么快？">Redis 为什么这么快？</h2><ol><li><strong>数据存储在内存</strong>（而非磁盘）。</li><li><strong>使用高效的数据结构</strong> 进行数据存储和查找。</li><li><strong>单线程 + I/O 多路复用</strong>，避免了多线程的上下文切换，提高性能。</li></ol><hr><h2 id="为什么-Redis-采用单线程？">为什么 Redis 采用单线程？</h2><ul><li>Redis 的瓶颈不在 <strong>CPU</strong>，而在 <strong>网络 I/O 和键值对操作</strong>，因此使用单线程处理请求。</li><li>持久化等操作由后台线程完成，并不会影响主线程的处理性能。</li></ul><hr><h2 id="Redis-跳表实现">Redis 跳表实现</h2><p>（略）</p><hr><h2 id="Redis-和-Memcached-的区别">Redis 和 Memcached 的区别</h2><table><thead><tr><th>特性</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>数据类型</td><td>丰富（String、Hash、List、Set、Sorted Set）</td><td>仅支持键值对（K-V）</td></tr><tr><td>持久化</td><td>支持（RDB、AOF）</td><td>不支持</td></tr><tr><td>事务</td><td>支持（但不支持回滚）</td><td>不支持</td></tr><tr><td>内存占用</td><td>较高</td><td>较低</td></tr><tr><td>速度</td><td>快</td><td>更快</td></tr><tr><td>使用场景</td><td>多种（缓存、队列、分布式锁等）</td><td>主要用于缓存</td></tr></tbody></table><hr><h2 id="Redis-事务-vs-MySQL-事务">Redis 事务 vs MySQL 事务</h2><ul><li>Redis 事务本质上是 <strong>多个命令的原子性执行</strong>，执行期间不会被打断。</li><li>但 Redis <strong>不支持事务回滚</strong>，一旦执行，无法撤销。</li></ul><hr><blockquote><p><strong>PS:</strong> <code>-1</code> 表示倒数第一个，范围遍历 <code>0</code> 到最后一个元素。<br><strong>PS:</strong> <code>user</code> 在这里是表名，<code>name</code> 是 key。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux一些好用的操作</title>
      <link href="/posts/83cfdf8d.html"/>
      <url>/posts/83cfdf8d.html</url>
      
        <content type="html"><![CDATA[<h1>Linux 知识整理</h1><h2 id="软硬链接的区别">软硬链接的区别</h2><h3 id="硬链接">硬链接</h3><p>硬链接更像是创建出了 <code>shared_ptr</code> 智能指针，原链接和硬链接都变成智能指针，删除其中一个不会使得文件失效。但是：</p><ul><li><strong>不能跨文件系统</strong></li><li><strong>不能链接目录</strong></li></ul><p><strong>创建硬链接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> file.txt file_link.txt</span><br></pre></td></tr></table></figure><h3 id="软链接">软链接</h3><p>软链接就像是原来文件的引用，删除原文件就会导致变成空悬链接（Dangling Link）。</p><p><strong>创建软链接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s file.txt file_link.txt</span><br></pre></td></tr></table></figure><hr><h2 id="使用-crontab">使用 <code>crontab</code></h2><p><code>crontab</code> 可用于定时执行任务，常见操作如下：</p><hr><h2 id="查看某个进程的使用情况">查看某个进程的使用情况</h2><h3 id="使用-ps-命令"><strong>使用 <code>ps</code> 命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p 1234 -o %mem,%cpu,vsz,rss</span><br></pre></td></tr></table></figure><ul><li><code>%mem</code>：查看进程使用的内存占比</li><li><code>%cpu</code>：查看进程占用的 CPU</li><li><code>vsz</code>：查看虚拟内存大小</li><li><code>rss</code>：查看常驻内存大小</li></ul><h3 id="使用-top-命令"><strong>使用 <code>top</code> 命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 1234</span><br></pre></td></tr></table></figure><ul><li><code>PR</code>：进程优先级</li><li><code>NI</code>：进程 Nice 值</li><li><code>VIRT</code>：虚拟内存总量</li><li><code>RES</code>：物理内存</li><li><code>SHR</code>：共享内存</li><li><code>S</code>：进程状态</li><li><code>COMMAND</code>：执行的具体命令</li></ul><hr><h2 id="改变用户权限">改变用户权限</h2><p>使用 <code>chmod</code> 命令修改文件权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 /project/hello.sh</span><br></pre></td></tr></table></figure><ul><li><strong>第一个数字（7）</strong>：文件所有者（可读、可写、可执行）</li><li><strong>第二个数字（5）</strong>：同组用户（可读、可执行）</li><li><strong>第三个数字（5）</strong>：其他用户（可读、可执行）</li></ul><hr><h2 id="查找某个目录下包含特定字符串的文件">查找某个目录下包含特定字符串的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rl <span class="string">&quot;特定字符串&quot;</span> /path/to/directory</span><br></pre></td></tr></table></figure><ul><li><code>-r</code>：递归查找</li><li><code>-l</code>：仅显示包含该字符串的文件名</li></ul><hr><h2 id="Linux-和-Windows-的虚拟内存机制">Linux 和 Windows 的虚拟内存机制</h2><ul><li><strong>Windows</strong>：主要使用 <strong>分页 + 分段</strong> 机制</li><li><strong>Linux</strong>：基本只使用 <strong>分页</strong> 机制</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 进阶与架构优化</title>
      <link href="/posts/7d06a385.html"/>
      <url>/posts/7d06a385.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-事务与锁">MySQL 事务与锁</h2><h3 id="锁的类型">锁的类型</h3><ul><li><strong>行级锁</strong>：锁住一行数据，提高并发能力。</li><li><strong>表级锁</strong>：锁住整个表，适用于大批量操作。</li><li><strong>意向锁</strong>：表级别的标记，用于加速行锁检测。</li><li><strong>乐观锁</strong>：不加锁，依赖版本号控制并发更新。</li><li><strong>悲观锁</strong>：先锁后操作，适用于高并发竞争场景。</li></ul><h3 id="死锁的处理">死锁的处理</h3><ol><li><strong>MySQL 死锁检测</strong>：自动回滚代价最小的事务。</li><li><strong>手动 <code>KILL</code> 事务</strong>：手动终止长时间阻塞事务。</li><li><strong>优化索引与 SQL 语句</strong>：减少锁冲突，降低死锁概率。</li></ol><h2 id="MySQL-读写分离与主从同步">MySQL 读写分离与主从同步</h2><ul><li><strong>主从架构</strong>：主库处理写操作，从库处理读操作。</li><li><strong>Binlog 实现主从同步</strong>：<ol><li>主库记录 Binlog。</li><li>从库读取 Binlog 并重放。</li></ol></li><li><strong>避免主从同步延迟</strong>：<ul><li>关键业务查询主库。</li><li>二次查询策略（从库查不到再查主库）。</li></ul></li></ul><h2 id="分库分表策略">分库分表策略</h2><h3 id="水平拆分"><strong>水平拆分</strong></h3><ul><li><strong>水平分表</strong>：将一张大表拆成多张小表（如 <code>users_0</code>, <code>users_1</code>）。</li><li><strong>水平分库</strong>：多个数据库存相同结构的表，降低单库压力。</li></ul><h3 id="垂直拆分"><strong>垂直拆分</strong></h3><ul><li><strong>垂直分表</strong>：将一张表的不同字段拆成多张表（如 <code>user_base</code> 和 <code>user_detail</code>）。</li><li><strong>垂直分库</strong>：不同业务数据存入不同数据库（如 <code>order_db</code> 和 <code>user_db</code>）。</li></ul><h3 id="分库分表的挑战"><strong>分库分表的挑战</strong></h3><ul><li><strong>跨库 JOIN 受限</strong>：需改为应用层查询或使用中间件（如 ShardingSphere）。</li><li><strong>事务一致性问题</strong>：需要分布式事务方案（如 TCC、最终一致性）。</li></ul><h2 id="MySQL-高可用架构">MySQL 高可用架构</h2><h3 id="避免单点故障"><strong>避免单点故障</strong></h3><ul><li><strong>主从复制</strong>：单主多从架构，保证数据可用性。</li><li><strong>MHA（MySQL High Availability）</strong>：自动故障切换，支持主从切换。</li><li><strong>PXC（Percona XtraDB Cluster）</strong>：多主集群，保证高可用。</li></ul><h3 id="不停机数据迁移"><strong>不停机数据迁移</strong></h3><ol><li><strong>双写方案</strong><ul><li>代码层面双写：新旧库同步写入。</li><li>业务低峰期停主从同步，开启双写。</li><li>逐步灰度切流，保证数据一致。</li></ul></li><li><strong>Flink CDC 方案</strong><ul><li>监听 Binlog 变更，实时同步数据。</li></ul></li></ol><h2 id="MySQL-存储与性能优化">MySQL 存储与性能优化</h2><h3 id="WAL（Write-Ahead-Logging）"><strong>WAL（Write-Ahead Logging）</strong></h3><ul><li><strong>先写日志再写数据</strong>，确保数据持久化。</li><li><strong>降低磁盘 IO</strong>，提高事务吞吐量。</li></ul><h3 id="Doublewrite-Buffer"><strong>Doublewrite Buffer</strong></h3><ul><li><strong>防止数据写入失败</strong>，避免数据损坏。</li></ul><h3 id="MySQL-缓存优化"><strong>MySQL 缓存优化</strong></h3><ul><li><strong>Buffer Pool</strong>：缓存常用数据，减少磁盘 IO。</li><li><strong>Query Cache（已废弃）</strong>：缓存查询结果，减少 SQL 解析时间。</li></ul><h2 id="MySQL-其他高级特性">MySQL 其他高级特性</h2><h3 id="存在性查询：EXISTS-vs-IN"><strong>存在性查询：EXISTS vs. IN</strong></h3><ul><li><strong>EXISTS</strong>：适用于大数据集合，只关心是否存在。</li><li><strong>IN</strong>：适用于小数据集合，直接匹配筛选。</li></ul><h3 id="存储过程"><strong>存储过程</strong></h3><ul><li><strong>优点</strong>：封装逻辑，提高性能。</li><li><strong>缺点</strong>：<ul><li>可移植性差，不同数据库的 SQL 语法可能不兼容。</li><li>调试困难，不利于代码管理（阿里开发手册不推荐）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 核心知识点整理</title>
      <link href="/posts/cdec3315.html"/>
      <url>/posts/cdec3315.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-数据排序">MySQL 数据排序</h2><p>MySQL 的数据排序主要有两种方式：</p><ul><li><strong>有索引</strong>：直接按照索引排序。</li><li><strong>无索引</strong>：采用文件排序。<ul><li><strong>数据量少</strong>：内存排序，使用单路或双路排序（类似于用一只手或两只手抓数据）。</li><li><strong>数据量大</strong>：磁盘排序，通常采用归并排序。</li></ul></li></ul><h2 id="SQL-语句的执行顺序">SQL 语句的执行顺序</h2><ol><li>连接器校验权限。</li><li>分析器解析 SQL 语法，构建解析树。</li><li>优化器选择合适的索引和表连接顺序，生成多个执行计划，选择成本最低的执行。</li><li>执行器调用存储引擎查询数据并返回。</li></ol><h2 id="MySQL-的存储引擎">MySQL 的存储引擎</h2><ul><li><strong>InnoDB</strong>：支持事务、行级锁、外键，默认存储引擎。</li><li><strong>MyISAM</strong>：不支持事务，读取性能高，适合查询密集型业务。</li></ul><h2 id="MySQL-索引类型">MySQL 索引类型</h2><ul><li><strong>普通索引（辅助索引）</strong>：提升查询效率，但不保证唯一性。</li><li><strong>主键索引（聚簇索引）</strong>：数据存储在 B+ 树叶子节点，查询效率高。</li><li><strong>唯一索引</strong>：确保字段值唯一，查询速度快。</li><li><strong>联合索引</strong>：多个字段组合建立索引，遵循最左前缀匹配原则。</li><li><strong>全文索引</strong>：适用于长文本的模糊查询。</li><li><strong>空间索引</strong>：存储地理位置信息，如经纬度。</li></ul><h2 id="MySQL-事务">MySQL 事务</h2><h3 id="事务的实现">事务的实现</h3><ol><li><strong>锁</strong>：确保数据一致性，避免并发冲突。</li><li><strong>undo log</strong>：记录事务前的数据，回滚时使用。</li><li><strong>redo log</strong>：记录已提交事务的修改，崩溃后可恢复。</li><li><strong>MVCC（多版本并发控制）</strong>：允许事务读取快照数据，提高并发性能。</li></ol><h3 id="事务的隔离级别">事务的隔离级别</h3><table><thead><tr><th>隔离级别</th><th>说明</th><th>可能问题</th></tr></thead><tbody><tr><td>读未提交</td><td>可以读到未提交数据</td><td>脏读</td></tr><tr><td>读已提交</td><td>只能读到已提交数据</td><td>不可重复读</td></tr><tr><td>可重复读</td><td>事务中多次查询数据不变</td><td>幻读</td></tr><tr><td>串行化</td><td>事务串行执行</td><td>影响性能</td></tr></tbody></table><h3 id="二阶段提交（2PC）">二阶段提交（2PC）</h3><ol><li><strong>准备阶段</strong>：协调者通知参与者执行事务，所有参与者先写入日志但不提交。</li><li><strong>提交阶段</strong>：所有参与者都准备好后，协调者通知提交，否则回滚。</li></ol><h2 id="MySQL-常见优化">MySQL 常见优化</h2><ul><li><strong>使用索引</strong>：避免无索引字段排序，尽量使用覆盖索引。</li><li><strong>避免使用 <code>LIKE %XXX%</code></strong>：会导致全表扫描。</li><li><strong>EXPLAIN 分析执行计划</strong>：查看是否走索引、是否全表扫描。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opengl加入摄像机移动</title>
      <link href="/posts/5da58852.html"/>
      <url>/posts/5da58852.html</url>
      
        <content type="html"><![CDATA[<h1>摄像头移动</h1><h2 id="基本原理"><strong>基本原理</strong></h2><ul><li>通过 <code>lookAt</code> 函数实现：<ul><li>传入 <strong>摄像机位置</strong></li><li>传入 <strong>物体位置</strong></li><li>传入 <strong>向上的分量</strong></li></ul></li><li><code>lookAt(cameraPos, targetPos, upVector)</code></li></ul><h2 id="键盘控制"><strong>键盘控制</strong></h2><ul><li><strong>注册键盘按压事件</strong></li><li><strong>支持多键同时移动</strong>（如同时向左和前）<ol><li>使用 <strong>集合（Set）</strong> 存储 <strong>当前按下的按键</strong></li><li>通过 <strong>定时器</strong> 定期对 <code>Set</code> 内的按键执行移动逻辑</li></ol></li></ul><p><img src="https://cdn-a.markji.com/files/67c87060f430f61a43a126d1_hd.png?e=1741191808698&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RDaxVaynSFpDnFf5nJHzoXdsUjI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c87068344183dd508c2aba_hd.png?e=1741191816778&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:nzQhHOfQwQfElAjp9u6ysj0InLE=" alt="图片1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>整理的一点网络方面的八股文</title>
      <link href="/posts/1b342089.html"/>
      <url>/posts/1b342089.html</url>
      
        <content type="html"><![CDATA[<h1>网络(自行整理,交由大模型写成markdown)</h1><h2 id="TCP-的粘包和拆包">TCP 的粘包和拆包</h2><ul><li><strong>粘包</strong>：多个数据包在接收时合并成一个包</li><li><strong>拆包</strong>：一个数据包被分成多个包接收</li><li><strong>原因</strong>：<ul><li>TCP 是面向字节流的协议，不关心数据边界，发送方可以随意发送</li><li>拆包是因为网络传输有 MTU（最大传输单元），不能一次发送太大的包</li></ul></li><li><strong>解决办法</strong>：<ol><li>使用 <strong>定长消息</strong>（双方固定读取）</li><li>添加 <strong>消息分隔符</strong>（双方约定好）</li><li>使用 <strong>消息头</strong>（标明包的长度）</li></ol></li></ul><h2 id="三次握手">三次握手</h2><ol><li>发起方发送 <code>SYN</code></li><li>服务器回复 <code>SYN + ACK</code></li><li>发起方回复 <code>ACK</code></li></ol><h3 id="TCP-初始序列号-ISN-如何取值？">TCP 初始序列号 ISN 如何取值？</h3><ul><li>以 <strong>时间戳</strong> 为基础生成，超过 <code>2^32</code> 会回到 0</li><li>加入一些 <strong>随机值</strong> 防止被猜到</li></ul><h3 id="TCP-三次握手时，客户端发送-SYN-之后宕机了会怎样？">TCP 三次握手时，客户端发送 <code>SYN</code> 之后宕机了会怎样？</h3><ul><li>服务器会正常发送 <code>SYN + ACK</code>，但对方无响应</li><li>服务器会 <strong>重试多次</strong>，若仍无回复则 <strong>主动断开</strong></li><li><strong>重试次数</strong> 由 <code>tcp_synack_retries</code> 参数决定</li></ul><h2 id="SYN-Flood-DDoS-攻击">SYN Flood / DDoS 攻击</h2><ul><li><strong>攻击方式</strong>：客户端不断发送 <code>SYN</code>（第一次握手），但不进行第三次握手，导致服务器资源耗尽</li><li><strong>防御方法</strong>：<ol><li><strong>SYN Cookie</strong>：要求客户端在第三次握手时带上 <code>cookie</code></li><li><strong>增加 SYN 队列</strong> 或 <strong>缩短超时时间</strong></li></ol></li></ul><h2 id="四次挥手">四次挥手</h2><ol><li>客户端 <code>FIN</code> → 进入 <code>FIN_WAIT_1</code></li><li>服务器 <code>ACK</code> → 进入 <code>CLOSE_WAIT</code></li><li>服务器 <code>FIN</code> → 进入 <code>LAST_ACK</code></li><li>客户端 <code>ACK</code> → 进入 <code>TIME_WAIT</code>，服务器 <code>CLOSE</code></li></ol><h3 id="为什么需要四次挥手？">为什么需要四次挥手？</h3><ul><li>类似打电话，要两对 <code>ACK + FIN</code> 确保数据完整</li><li><strong>不一定是四次</strong>：服务器可以在 <code>ACK</code> 时同时 <code>FIN</code></li></ul><h3 id="TIME-WAIT-作用"><code>TIME_WAIT</code> 作用</h3><ul><li><strong>确保服务器收到最后的 <code>ACK</code></strong></li><li><strong>防止端口复用时收到过期数据</strong></li><li><strong>2MSL</strong>：等待两倍的最大生存时间 <code>MSL</code>（Linux 默认 <code>MSL=30s</code>，所以 <code>2MSL=1min</code>）</li></ul><h3 id="其他断开方式">其他断开方式</h3><ul><li><strong>RST（Reset）报文</strong>：异常情况下立即断开（如主机崩溃）</li><li><strong>超时断开（Timeout）</strong>：连接长时间无数据传输</li></ul><h2 id="超时重传机制">超时重传机制</h2><ul><li>类似打电话没人回应，就再重复一遍</li></ul><h2 id="SACK（选择性确认）">SACK（选择性确认）</h2><ul><li>告诉发送方自己<strong>接收到的数据块</strong></li><li>发送方只需<strong>重传丢失的部分</strong></li></ul><h2 id="滑动窗口的作用">滑动窗口的作用</h2><ul><li><strong>协调发送方和接收方速率</strong>（一般等于接收缓冲区大小）</li><li><strong>提高吞吐量</strong>（允许一次发送多个包）</li></ul><h2 id="拥塞控制">拥塞控制</h2><h3 id="1-慢启动">1. <strong>慢启动</strong></h3><ul><li>一开始 <strong>小量发送</strong>，若成功则 <strong>指数增长</strong></li><li>直到 <strong>丢包</strong> 或 <strong>达到慢启动阈值</strong></li></ul><h3 id="2-拥塞避免">2. <strong>拥塞避免</strong></h3><ul><li>慢启动是<strong>指数增长</strong>，进入拥塞避免后<strong>线性增长</strong></li></ul><h3 id="3-快速重传">3. <strong>快速重传</strong></h3><ul><li>发送 10 个包，9 个 <code>ACK</code> 回来了 → 直接重传丢失的（只需 3 个重复 <code>ACK</code>）</li></ul><h3 id="4-快速恢复">4. <strong>快速恢复</strong></h3><ul><li>发生 <strong>快速重传</strong> 后，将窗口 <strong>砍半</strong></li><li><strong>慢启动阈值</strong> 设为新窗口大小（进入<strong>拥塞避免</strong>）</li></ul><h3 id="滑动窗口-vs-拥塞窗口"><strong>滑动窗口 vs 拥塞窗口</strong></h3><table><thead><tr><th></th><th>作用</th></tr></thead><tbody><tr><td><strong>滑动窗口</strong></td><td>接收方信箱大小（控制接受能力）</td></tr><tr><td><strong>拥塞窗口</strong></td><td>送货公司送货能力（控制发送速度）</td></tr></tbody></table><h2 id="ARP-和-RARP">ARP 和 RARP</h2><ul><li><strong>ARP（Address Resolution Protocol）</strong>：IP → MAC</li><li><strong>RARP（Reverse ARP）</strong>：MAC → IP</li></ul><h2 id="四层-七层模型">四层 &amp; 七层模型</h2><h3 id="四层模型"><strong>四层模型</strong></h3><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><h3 id="七层模型"><strong>七层模型</strong></h3><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ol><h2 id="Cookie-vs-Token-vs-Session">Cookie vs Token vs Session</h2><table><thead><tr><th></th><th><strong>Cookie</strong></th><th><strong>Session</strong></th><th><strong>Token</strong></th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>客户端</td><td>服务器</td><td>客户端（无状态）</td></tr><tr><td><strong>存储内容</strong></td><td>小型数据文件</td><td>用户数据</td><td>认证信息</td></tr><tr><td><strong>工作方式</strong></td><td>浏览器带上 <code>Cookie</code> 认证</td><td>客户端只存 <code>SessionID</code></td><td>无需数据库查询，直接校验</td></tr><tr><td><strong>示例</strong></td><td>购物车</td><td>登录状态</td><td>JWT（JSON Web Token）</td></tr></tbody></table><h2 id="DNS（域名解析系统）">DNS（域名解析系统）</h2><ul><li><strong>Domain Name System</strong></li><li><strong>解析域名</strong> → <strong>IP 地址</strong></li><li><strong>负载均衡</strong>：同一域名可以解析多个 IP</li></ul><h2 id="CDN（内容分发网络）">CDN（内容分发网络）</h2><ul><li><strong>缓存服务器</strong> 分布多个地点</li><li>用户请求时选择<strong>最近的缓存站</strong></li><li>适用于 <strong>静态资源</strong>（图片、CSS、JS）</li></ul><h2 id="用户输入网址到网页显示全过程">用户输入网址到网页显示全过程</h2><ol><li><strong>解析 URL</strong> 生成 <strong>HTTP 请求</strong></li><li><strong>DNS 解析</strong>：域名 → IP</li><li><strong>TCP 三次握手</strong></li><li><strong>封装 TCP 数据包</strong></li><li><strong>封装 IP、MAC 数据包</strong></li><li><strong>网卡</strong> 转换成 <strong>电信号</strong> 通过 <strong>网线传输</strong></li><li><strong>交换机 → 路由器 → 服务器</strong></li><li>服务器处理请求，返回数据</li><li>浏览器解析并渲染页面</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>加入旋转</title>
      <link href="/posts/5985ea05.html"/>
      <url>/posts/5985ea05.html</url>
      
        <content type="html"><![CDATA[<h1>纹理映射与旋转</h1><h2 id="1-纹理映射">1. 纹理映射</h2><p>在 OpenGL 中，可以使用 <code>sampler2D</code> 进行 2D 纹理采样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D ourTexture;</span><br></pre></td></tr></table></figure><blockquote><p>该变量用于在片元着色器中获取 2D 纹理的像素值。</p></blockquote><hr><h2 id="2-加入纹理过滤与旋转">2. 加入纹理过滤与旋转</h2><h3 id="步骤-1：转换为立方体"><strong>步骤 1：转换为立方体</strong></h3><ul><li><strong>矩形 -&gt; 立方体</strong>：原始矩形的顶点坐标扩展为 24 个顶点，以适应立方体的六个面。</li><li>每个面使用四个顶点，并绑定对应的纹理坐标。</li></ul><p>示例顶点数据（包含位置和纹理坐标）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置                // 纹理坐标</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="comment">// 其余五个面省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="步骤-2：应用纹理过滤"><strong>步骤 2：应用纹理过滤</strong></h3><p>为了提升渲染质量，可以使用 <strong>线性过滤</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><blockquote><p>这样，在放大或缩小时，纹理会进行平滑过渡，避免像素化。</p></blockquote><hr><h3 id="步骤-3：添加旋转"><strong>步骤 3：添加旋转</strong></h3><p>使用 <code>glm::rotate</code> 在片元着色器中动态旋转：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = glm::<span class="built_in">rotate</span>(model, (GLfloat)<span class="built_in">glfwGetTime</span>() * glm::<span class="built_in">radians</span>(<span class="number">50.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>glfwGetTime()</code> 让物体随着时间旋转，旋转轴为 <code>(0.5, 1.0, 0.0)</code>。</p></blockquote><hr><p><img src="https://cdn-a.markji.com/files/67c70085684ac25add60662b_hd.png?e=1741097637264&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:C2_F2MO3wuBkT_xbflb-pLwYuCE=" alt="图片1"><br>这样，我们就成功将纹理映射应用到了立方体，并添加了旋转效果！🚀</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于opengl使用的小心得</title>
      <link href="/posts/a608763a.html"/>
      <url>/posts/a608763a.html</url>
      
        <content type="html"><![CDATA[<h1>OpenGL 基础概念</h1><h2 id="VBO（数组缓冲对象）">VBO（数组缓冲对象）</h2><ul><li>用于存储顶点数据，如位置、颜色、法线、纹理坐标等。</li><li>作用是直接把数组存到 GPU 的缓存中，提高渲染效率。</li></ul><h2 id="IBO-EBO（索引缓冲对象）">IBO/EBO（索引缓冲对象）</h2><ul><li>用于存储索引数据，避免重复存储相同的顶点数据，提高渲染效率。</li><li>需要使用 <code>create</code> / <code>bind</code> / <code>allocate</code> 进行管理。</li></ul><h2 id="VAO（顶点数组对象）">VAO（顶点数组对象）</h2><ul><li>作为管理者，记录 VBO 和 IBO 的绑定状态。</li><li>不需要在每次绘制时重新设置，可在不同 VAO 之间切换，以便绘制不同的对象。</li><li>只有 <code>create</code> 和 <code>bind</code> 操作（用于成为管理者）。</li></ul><h2 id="顶点属性指针">顶点属性指针</h2><ul><li>用于告诉 OpenGL 顶点数据的格式，包括：<ul><li>每个顶点有多少数据（如每个顶点包含多少个属性）。</li><li>每个属性占用多少个 <code>GLFloat</code>。</li><li>该属性在 VBO 中的位置。</li></ul></li></ul><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shaderProgram.<span class="built_in">enableAttributeArray</span>(<span class="number">0</span>); <span class="comment">// 启用顶点位置属性，对应顶点着色器中的 layout (location = 0)</span></span><br><span class="line">shaderProgram.<span class="built_in">setAttributeBuffer</span>(<span class="number">0</span>, GL_FLOAT, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span> * <span class="built_in">sizeof</span>(GLfloat));</span><br><span class="line"><span class="comment">// 参数解析：</span></span><br><span class="line"><span class="comment">//  - 0：属性索引，对应顶点着色器中的 `layout (location = 0)`</span></span><br><span class="line"><span class="comment">//  - GL_FLOAT：数据类型</span></span><br><span class="line"><span class="comment">//  - 0：从 VBO 开始解析</span></span><br><span class="line"><span class="comment">//  - 3：一次解析 3 个值（x, y, z）</span></span><br><span class="line"><span class="comment">//  - 6 * sizeof(GLfloat)：步长（Stride），即每个顶点的总数据大小</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：这两句话相当于定义了两个指针，告诉着色器如何解析顶点数组。</p></blockquote><h3 id="OpenGL-着色器绑定规则">OpenGL 着色器绑定规则</h3><ul><li>OpenGL <strong>只能同时使用一个着色器程序</strong>，使用时需要 <code>bind</code> 绑定某个着色器。</li><li><strong>VAO 也是同理</strong>，可以创建多个 VAO 来存储不同的对象（如矩形和三角形），但<strong>不能同时使用</strong>，需要绘制不同对象时，需重新 <code>bind</code> 另一个 VAO。</li></ul><hr><h2 id="纹理映射">纹理映射</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D ourTexture;</span><br></pre></td></tr></table></figure><blockquote><p>用于获取 2D 纹理的像素值。</p></blockquote><hr><h2 id="纹理过滤与旋转">纹理过滤与旋转</h2><ul><li>将矩形扩展为立方体，并增加顶点坐标至 24 个，以支持 3D 纹理映射和旋转。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立方体顶点数据（包含纹理坐标）</span></span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置           // 纹理坐标</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="comment">// 其余五个面省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转矩阵（在片元着色器中应用）</span></span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, (GLfloat)<span class="built_in">glfwGetTime</span>() * glm::<span class="built_in">radians</span>(<span class="number">50.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>glfwGetTime()</code> 实现动态旋转。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用vcxxrv来配合wsl做图形化界面</title>
      <link href="/posts/728f80ac.html"/>
      <url>/posts/728f80ac.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 使用 VcXsrv 给 WSL2 连接图形界面</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 下载 VcXsrv  </span></span><br><span class="line">首先，从官网下载安装 VcXsrv：  </span><br><span class="line">[<span class="string">https://sourceforge.net/projects/vcxsrv/</span>](<span class="link">https://sourceforge.net/projects/vcxsrv/</span>)  </span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 更换源  </span></span><br><span class="line">执行以下命令更换源：</span><br><span class="line"><span class="code">```bash</span></span><br><span class="line"><span class="code">wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py</span></span><br><span class="line"><span class="code">sudo python3 oh-my-tuna.py --global</span></span><br><span class="line"><span class="code">sudo apt-get update</span></span><br><span class="line"><span class="code">sudo apt-get upgrade</span></span><br></pre></td></tr></table></figure><h2 id="3-安装所需软件">3. 安装所需软件</h2><p>安装 <code>xfce4-terminal</code> 和 <code>xfce4</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install xfce4-terminal</span><br><span class="line"><span class="built_in">sudo</span> apt-get install xfce4</span><br></pre></td></tr></table></figure><p>重启 <code>dbus</code> 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service dbus restart</span><br></pre></td></tr></table></figure><h2 id="4-配置环境变量">4. 配置环境变量</h2><p>编辑 <code>~/.bashrc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加以下内容（请将 <code>172.27.46.105</code> 替换为实际的 Windows IP 地址）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=172.27.46.105:0.0  <span class="comment"># 替换为你的 Windows IP 地址</span></span><br><span class="line"><span class="built_in">export</span> WAYLAND_DISPLAY=<span class="variable">$DISPLAY</span></span><br><span class="line"><span class="built_in">export</span> XDG_SESSION_TYPE=x11</span><br></pre></td></tr></table></figure><p>保存并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="5-启动图形界面">5. 启动图形界面</h2><p>执行以下命令启动 <code>xfce4</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startxfce4</span><br></pre></td></tr></table></figure><p>然后就可以在 WSL2 中显示图形界面了。</p><h2 id="6-OpenCV-相关问题">6. OpenCV 相关问题</h2><p>使用 <code>apt</code> 安装 OpenCV 成功，但 <code>vcpkg</code> 方式失败，原因未知。<br>此外，有一个小技巧：WSL 可以直接使用 Windows 磁盘路径，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/c/（C 盘路径）</span><br></pre></td></tr></table></figure><p>可以直接访问 Windows 里的图片文件。</p><p>最终编译运行成功，并成功显示图片！ 🎉<br><img src="https://cdn-a.markji.com/files/67b7f45da5c2cef46265e459_hd.png?e=1740988820039&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FVDLnFenUDMYp4etgqXF7xGFeyY=" alt="图片1"></p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SFINAE在c++模板中的使用及标准库中的应用</title>
      <link href="/posts/b2bfdc17.html"/>
      <url>/posts/b2bfdc17.html</url>
      
        <content type="html"><![CDATA[<h1>代换失败不是错误（SFINAE）</h1><h2 id="概念">概念</h2><p>SFINAE（Substitution Failure Is Not An Error）意为<strong>代换失败不是错误</strong>，这是 C++ 模板机制中的一个重要特性。</p><p><strong>核心思想</strong>：<br>当模板参数推导失败时，编译器不会报错，而是会尝试匹配其他可能的函数或模板。因此，它可以避免<strong>不合理的模板实例化</strong>，防止<strong>不该匹配的类型</strong>被错误实例化。<br><img src="https://cdn-a.markji.com/files/6718a31157833190dc44516e_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RUdsJ4FONhfWNo9_YiTTcVxvcrk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6718a366f0750c5d4663751b_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:o6yHRfpeWxDBQnRrolze3ZVy3a0=" alt="图片1"><br><strong>PS：非常非常重要！</strong></p><h2 id="代换失败的规则">代换失败的规则</h2><p>任何<strong>导致代换的模板实参</strong>不符合 C++ 语法（即<strong>非良构</strong>）的情况，都会导致代换失败，而不会引发编译错误。</p><p><strong>PS：非良构</strong>表示不符合 C++ 的基本语法。<br><img src="https://cdn-a.markji.com/files/6718aa5af0750c5d46665066_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:x751lLJmCrCiHlKE9qCWN48oK2g=" alt="图片1"></p><h2 id="SFINAE-的具体使用">SFINAE 的具体使用</h2><p>通常，即使不使用 SFINAE，C++ 也会在模板实例化后报错。但 SFINAE 的关键在于：</p><p>✅ <strong>SFINAE 使得错误发生在实例化前，而非实例化后。</strong><br>✅ <strong>能不实例化就不要实例化</strong>，因为某些模板实例化后可能产生难以理解的错误信息。<br>✅ <strong>使用 SFINAE，错误信息会变得更简单，比如 “未找到匹配的重载函数”。</strong><br>✅ <strong>模板实例化本身是有开销的</strong>，尤其对于复杂模板而言，实例化可能带来较大编译成本。<br><img src="https://cdn-a.markji.com/files/6718aebb12bf596766b9afe2_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Zqkct74cpIBK0S1gAb-IUjoCuN0=" alt="图片1"></p><h2 id="标准库中的-SFINAE-——-enable-if-t">标准库中的 SFINAE —— <code>enable_if_t</code></h2><p>标准库中的 <code>std::enable_if_t</code> 是 SFINAE 的典型应用。</p><p>在前面的知识点中，我们讨论了对类型的行为要求，例如：</p><ul><li>是否具有 <code>type</code> 成员</li><li>是否支持加减运算</li></ul><p>使用 <code>enable_if</code> 可以为模板增加约束，从而控制哪些类型可以实例化该模板。</p><p><strong>PS：本质上，<code>enable_if</code> 是“使得模板可用，如果满足某个条件”。</strong></p><h2 id="enable-if-t-的原理"><code>enable_if_t</code> 的原理</h2><ul><li><code>enable_if</code> <strong>在第一参数为 <code>true</code> 时</strong>，才会定义 <code>type</code> 成员；</li><li>如果第一参数为 <code>false</code>，则 <strong>没有 <code>type</code> 成员</strong>，从而导致代换失败（SFINAE 机制生效）。<br><img src="https://cdn-a.markji.com/files/6718e6c4ccfef1e7ef90aa39_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Qic1PBCiJefrDMGGuvz70TXe6bQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6718e87eccfef1e7ef91d10e_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:_9RzhzxTtQxZkuO8DX9FiOHPmPk=" alt="图片1"></li></ul><hr><p>SFINAE 是 C++ 模板元编程的核心技巧之一，合理使用可以提高代码的可读性和健壮性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>奇异模板递归</title>
      <link href="/posts/233853.html"/>
      <url>/posts/233853.html</url>
      
        <content type="html"><![CDATA[<h1>CRTP</h1><p>CRTP（Curiously Recurring Template Pattern）被称为<strong>奇异重现</strong>，或者<strong>奇异递归模板模式</strong>。</p><h2 id="优势">优势</h2><ul><li>实现了<strong>静态多态</strong>，无需使用虚函数。</li><li><strong>无运行时开销</strong>，提高了性能。</li><li>避免了传统的向下转换（downcasting）导致的类型错误。</li></ul><h2 id="备注">备注</h2><p>以后可以尝试<strong>都使用 CRTP</strong> 来编写代码，以免去运行时开销。其实改动并不难。<br><img src="https://cdn-a.markji.com/files/671efd0edee1d69b5795e9e8_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:eTV6e0Uq9JPfOinXXfpIMFBNfrQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671efe26dee1d69b579632ad_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:xdubiw1N2IuVkkZDpZFaa3Zt7zw=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671efe71dee1d69b5796771c_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2SKkuT0tqcQk8W5ETJdWlTmGC0M=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671effd53f407d0defb03c91_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:266HrCtrSmLMkWx15DEJq9Tg2CI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671f0372dee1d69b57977b98_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5rrSzhrY_9WCbvminQU3CnWYDzk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671f0407dee1d69b57979395_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:0y2tMdhuqFIb51or_ieuJTP55wA=" alt="图片1"></p>]]></content>
      
      
      <categories>
          
          <category> C++开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 模板元编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色与光照和冯氏光源</title>
      <link href="/posts/6f91cf88.html"/>
      <url>/posts/6f91cf88.html</url>
      
        <content type="html"><![CDATA[<h1>颜色与光源</h1><p><img src="https://cdn-a.markji.com/files/67c15ba5dc26a985b3b34fdc_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:yx4H1nkKytF1Cm7g3oJq7090FfY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c16188dc26a985b3b48403_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:56MP6kELtAyQZFdJzSF3WMfqVcE=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c16377b18af440dfe9778b_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:tIJYO-KENMom4Ws2gUWyi-3_oZY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c16554dc26a985b3b53c79_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cglFWhSiTsRj49mrrMBojIWgER4=" alt="图片1"></p><h2 id="冯氏光照">冯氏光照</h2><p><img src="https://cdn-a.markji.com/files/67c1660eb18af440dfea20e9_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:K_pslwGHQp1g_WlArTLIklZzsyg=" alt="图片1"><br>在顶点着色器（vertex shader）中实现冯氏光照会导致较差的效果，而在片元着色器（fragment shader）中实现，尽管计算成本较高，但能获得更好的渲染结果。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>opengl的摄像机相关</title>
      <link href="/posts/b90c4775.html"/>
      <url>/posts/b90c4775.html</url>
      
        <content type="html"><![CDATA[<h1>摄像机</h1><p><img src="https://cdn-a.markji.com/files/67c0333fdc26a985b391278b_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2EL6zFizoQrig0PpFEvC1WXiXAU=" alt="图片1"><br>原本应该是先旋转再位移。<br><img src="https://cdn-a.markji.com/files/67c0350ab18af440dfc68363_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:CQwgolnwpqRTgZCsQZg1aJ8kuQ0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c03694b18af440dfc6a40c_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2PMBZtj_iOf9MVA2sROAFDYsIPQ=" alt="图片1"></p><h2 id="顺时针旋转">顺时针旋转</h2><blockquote><p>注意：改成 <code>-sin</code> 就会变成顺时针旋转。</p></blockquote><h2 id="左右移动">左右移动</h2><p>给摄像机加入左右移动的功能。<br><img src="https://cdn-a.markji.com/files/67c03a00b18af440dfc6f9b1_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:yqDp-z7SEfSo2nSK76P6t1w7B64=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c03aaadc26a985b391fe4a_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:INIm9mGfjw-2mJW7pYlfYXIi0T0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c055a1dc26a985b3975b4c_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:-Lv1hO4hyiGQ90t7SmV9kmKlK70=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c0569edc26a985b3977a34_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:XXw_CNlGRgL795b_uejwQyVPWCQ=" alt="图片1"></p><h2 id="封装成-Camera-类">封装成 Camera 类</h2><p>这些功能都可以封装成一个 <code>Camera</code> 类。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>opengl的缩放/位移/旋转和坐标系统</title>
      <link href="/posts/4d5b731c.html"/>
      <url>/posts/4d5b731c.html</url>
      
        <content type="html"><![CDATA[<h1>缩放/位移/旋转</h1><ul><li><strong>点乘</strong>：就是横乘竖。</li><li><strong>叉乘</strong>：会创建出一个和两个向量垂直的向量。<br><img src="https://cdn-a.markji.com/files/67bfcf0eb18af440dfb39223_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:WLd74iKLtGMBPrpCch2taAoly-Q=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67bfcfc8dc26a985b37f91a1_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:tAkycbKopfaafy7arSAvSkbnmsA=" alt="图片1"></li></ul><h2 id="旋转">旋转</h2><p>大多数的旋转采用弧度制而不是角度制，故需要将弧度转为角度。旋转公式略。<br><img src="https://cdn-a.markji.com/files/67c004e9dc26a985b388e9ad_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:qfsteOTme2Y5PpwXXqBTsiQQ8kM=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c005b3b18af440dfbe23f8_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MC_Ak6BjrwHv0_CN5IoPuH30IQM=" alt="图片1"></p><h2 id="坐标系统">坐标系统</h2><p><img src="https://cdn-a.markji.com/files/67c007f8b18af440dfbe893f_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:CctZ1--1Y3ldRs97Ak3WZH9Csqo=" alt="图片1"></p><h3 id="画箱子：">画箱子：</h3><ol><li>先把顶点数据拷贝过去，绘制 36 个点。</li><li>然后加旋转。</li><li>在顶点着色器中将它们点乘起来。</li><li>加入透视投影，创建 MVP（模型/视图/投影）矩阵：<ul><li><code>model</code>：模型矩阵。</li><li><code>view</code>：视图矩阵。</li><li><code>projection</code>：投影矩阵，系统可以自动计算。</li></ul></li><li>将 <code>projection</code> 矩阵传入顶点着色器，并与 <code>model</code> 矩阵一起点乘。</li><li>最后再加入 <code>view</code> 矩阵。<br><img src="https://cdn-a.markji.com/files/67c010d1dc26a985b38ad5da_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:junmocf3g8CkOepaXmiQuba3ARQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c011b7dc26a985b38afbb5_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:8wSzaXEeYsmDQMrnvc5CTSympko=" alt="图片1"></li></ol><h2 id="更多立方体">更多立方体</h2><p><img src="https://cdn-a.markji.com/files/67c01387b18af440dfc097df_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:0GMhjI6i9eUr8AXemv4kbX_Krho=" alt="图片1"></p>]]></content>
      
      
      <categories>
          
          <category> 图形编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 图形学 </tag>
            
            <tag> 3D渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opengl的纹理映射和纹理过滤</title>
      <link href="/posts/db6bb13c.html"/>
      <url>/posts/db6bb13c.html</url>
      
        <content type="html"><![CDATA[<h2 id="纹理映射">纹理映射</h2><h3 id="使用-QOpenGLTexture-导入图片">使用 QOpenGLTexture 导入图片</h3><ul><li>可以使用 Qt 封装的 <code>QOpenGLTexture</code> 来导入图片等纹理资源。<br><img src="https://cdn-a.markji.com/files/67becacd62d9c43585a04aee_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:jm0Us9UtbHenL0P2084ZvQ_cnPs=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67becc7162d9c43585a0abdb_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:40mSGTkgBMNFrnudGcfFOZ357-k=" alt="图片1"></li></ul><h3 id="纹理单元">纹理单元</h3><ul><li>OpenGL 保证有 16 个纹理单元，这意味着最多可以绑定 16 个纹理。<br><img src="https://cdn-a.markji.com/files/67bef936dc26a985b3681803_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:oW4g9iz2l4cYznAuqhVGjcfeXpg=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67befd9a62d9c43585a81425_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:sisu-6cJY4ZxwSApaDX3ELQtXZc=" alt="图片1"></li></ul><h3 id="纹理过滤">纹理过滤</h3><ul><li>OpenGL 需要知道如何将纹理像素映射到纹理坐标。常见的纹理过滤方式包括：<ul><li><strong>就近值过滤</strong>：取纹理坐标附近最近的像素值。</li><li><strong>融合过滤</strong>：将周边像素进行融合，产生更平滑的过渡。<br><img src="https://cdn-a.markji.com/files/67bf0d5962d9c43585abfc69_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:0-6T-Xh7gsWLDyWhCN0Ig4YOgvk=" alt="图片1"></li></ul></li></ul><h3 id="多级渐远纹理（Mipmap）">多级渐远纹理（Mipmap）</h3><ul><li>OpenGL 还提供了多级渐远纹理（Mipmap），用于对远处的纹理进行低分辨率渲染，而对近处的纹理进行高分辨率渲染，从而优化性能并提高视觉效果。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>opengl给顶点数据增加更多属性</title>
      <link href="/posts/abe0a705.html"/>
      <url>/posts/abe0a705.html</url>
      
        <content type="html"><![CDATA[<h2 id="给顶点数据中添加更多属性">给顶点数据中添加更多属性</h2><p><img src="https://cdn-a.markji.com/files/67bec75062d9c435859f6691_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2wi5ClIvhXNorQsOPq1Whnf4mqs=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67bec7abfaa33a2f9faf35ff_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:vhhNRHZ5ajGnL1F31YAyhkIhqc0=" alt="图片1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>layout和Uniform</title>
      <link href="/posts/8374bca7.html"/>
      <url>/posts/8374bca7.html</url>
      
        <content type="html"><![CDATA[<h2 id="Layout-和-Uniform">Layout 和 Uniform</h2><h3 id="Layout">Layout</h3><ul><li>顶点着色器接收的输入是比较特殊的，不是从流水线其他步骤传下来的。</li><li>使用 <code>layout (location=?)</code> 可以使得在 CPU 上配置顶点属性。如果省略，默认会从 0 开始。</li><li>在 GLSL 中配置的数据是怎样的，C++ 文件中也需要使用相同的数字才能成功渲染。</li></ul><h3 id="Uniform">Uniform</h3><ul><li><code>uniform</code> 是用于 CPU 向 GPU 中的着色器发送数据的方式。</li><li><code>uniform</code> 是一种全局数据，可以被任意着色器程序在任意阶段访问。</li><li>可以在程序中定时更改参数，使得着色器定时从 CPU 中获取这些参数，进而重新绘制，从而实现闪烁等效果。<br><img src="https://cdn-a.markji.com/files/67bec28462d9c435859e4476_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ly4rw_uiseiou9VqwDBD5WP0Tjk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67bec2c462d9c435859e4ae0_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:dC0AapMNE87mV6gBGsdpjP9XPNA=" alt="图片1"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>opengl和qt交互</title>
      <link href="/posts/1b223038.html"/>
      <url>/posts/1b223038.html</url>
      
        <content type="html"><![CDATA[<h2 id="Qt-和-OpenGL-交互">Qt 和 OpenGL 交互</h2><ul><li><p>当在 <code>paintGL</code> 之外的地方重新绘制（比如按下按钮），则需要调用 <code>widget</code> 的 <code>update()</code> 来重新更新。</p></li><li><p>若要从其他地方调用 OpenGL 函数（即不在 <code>paintGL</code>、<code>resizeGL</code> 等函数中），需要先调用 <code>makeCurrent</code>。<br><img src="https://cdn-a.markji.com/files/67be7dae62d9c4358590966c_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:XZjt94Ejewd88ls2vko6yGyYisA=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67be7e1dfaa33a2f9f9def5b_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:pm7R8YQW0BVCl3rCnQA3wzR4Zhg=" alt="图片1"></p></li></ul><h3 id="注意事项">注意事项</h3><ul><li>如果要设置控件是否是选中的状态，可以使用带布尔值的&quot;转到槽&quot;。<br><img src="https://cdn-a.markji.com/files/67be7eebfaa33a2f9f9e67a4_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4sN-9t_2Vqgbd2TrJJmtQlHgYMg=" alt="图片1"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>绘制一个三角形-opengl</title>
      <link href="/posts/41bd35c.html"/>
      <url>/posts/41bd35c.html</url>
      
        <content type="html"><![CDATA[<h1>绘制一个三角形</h1><h2 id="流程概述">流程概述</h2><ol><li><strong>CPU上的顶点数据</strong>：首先，我们有一组顶点数据，存储在CPU内存中。</li><li><strong>发送到VBO（GPU缓冲区）</strong>：将这些顶点数据打包并发送到VBO（顶点缓冲对象），VBO是GPU中的缓冲区。</li><li><strong>VAO告诉GPU如何处理数据</strong>：VAO（顶点数组对象）用于告诉GPU如何处理这些数据，包括数据的位置和格式。</li></ol><h2 id="问题描述">问题描述</h2><p>在初始化阶段，我们绑定了VAO和VBO，将数据传入显存，并告诉GPU如何解析这些数据。之后，我们解绑了VAO和VBO。</p><p>在绘制阶段（例如调用<code>paint</code>函数时），我们重新绑定了VAO，但没有绑定VBO。</p><h2 id="问题分析">问题分析</h2><p>在OpenGL中，VAO的作用是记录VBO的配置信息。一旦VAO记录了VBO的配置（包括数据格式和位置），在绘制时只需要绑定VAO即可，不需要再次绑定VBO。这是因为VAO已经存储了VBO的相关信息。</p><p>因此，在绘制阶段只需要绑定VAO，OpenGL会自动使用VAO中记录的VBO配置。</p><h2 id="示例代码">示例代码</h2><p>以下是绘制三角形的代码片段，展示了VAO和VBO的绑定与解绑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化阶段</span></span><br><span class="line">GLuint VAO, VBO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定VAO和VBO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将顶点数据传入显存</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉GPU如何解析顶点数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑VAO和VBO</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制阶段</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">paint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制三角形</span></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解绑VAO</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><ul><li><strong>VAO</strong> 记录了VBO的配置信息，因此在绘制时只需要绑定VAO，不需要再次绑定VBO。</li><li><strong>VBO</strong> 用于存储顶点数据，在初始化阶段配置完成后，VAO会记住这些配置。</li><li>这种设计提高了性能，减少了重复绑定的开销。<br><img src="https://cdn-a.markji.com/files/67bd80bb2aecbcb9d81f88c5_hd.png?e=1740477180455&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:U0zMDH06f4fhpnCYyU3MjOSye08=" alt="Hexo Logo"><br><img src="https://cdn-a.markji.com/files/67bd86d02aecbcb9d8209e5f_hd.png?e=1740477180455&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:qAwFOT8E9BrvNYcWHdGv8j2J7-k=" alt="Hexo Logo"><br><img src="https://cdn-a.markji.com/files/67bd87ce54f5add59f684851_hd.png?e=1740477180455&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ftgvcLVjBHs0_y4ikW_YjLKTOCU=" alt="Hexo Logo"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>opengl+qt初尝试</title>
      <link href="/posts/43b541f4.html"/>
      <url>/posts/43b541f4.html</url>
      
        <content type="html"><![CDATA[<h1>我的OpenGL + Qt初次使用日记</h1><p>今天，我开启了OpenGL与Qt结合使用,以下是我初次使用过程中的操作记录。</p><h2 id="1-创建Qt的MainWindow">1. 创建Qt的MainWindow</h2><p>我首先使用cmake来正常创建Qt项目的MainWindow</p><h2 id="2-编辑菜单">2. 编辑菜单</h2><p>完成MainWindow的创建后，我着手编辑菜单。菜单编辑过程没有遇到太大阻碍</p><h2 id="3-添加工具栏（Tool-Bar）和操作（Action）">3. 添加工具栏（Tool Bar）和操作（Action）</h2><ul><li><strong>添加工具栏</strong>：在编辑过程中，我很直观地发现右键点击相关区域就可以轻松加入一个工具栏。这个操作很简便，使得界面布局变得更加丰富和可定制。</li><li><strong>添加操作（Action）</strong>：接着，我注意到点击下方左边的一个<code>New</code>选项，就可以增加一个<code>action</code>。</li></ul><p>虽然这是初次将OpenGL与Qt结合使用，但在这个过程中我对Qt框架的基本操作有了进一步的认识，也为后续探索OpenGL和Qt在图形渲染、界面构建等方面的复杂交互打下了良好的基础。<br><img src="https://cdn-a.markji.com/files/67bd0cb56b78148678378233_hd.png?e=1740447220182&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:xC85aDukPV9mDqOd6BJguO46DPo=" alt="Hexo Logo"><br><img src="https://cdn-a.markji.com/files/67bd0e53d983580075d9529f_hd.png?e=1740447220182&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:mfO3mCDVhiFVBF8UQOcDE1W7kDo=" alt="Hexo Logo"><br><img src="https://cdn-a.markji.com/files/67bd1042d983580075d9786a_hd.png?e=1740447220182&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:SNXpuQKWRq3iApZHEHn0rZSeBeg=" alt="Hexo Logo"><br><img src="https://cdn-a.markji.com/files/67bd11096b781486783851e4_hd.png?e=1740447220182&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:rdsdc-sw7JWtwHkcNHe-MBd9rtg=" alt="Hexo Logo"><br><img src="https://cdn-a.markji.com/files/67bd13d0d983580075d9e01d_hd.png?e=1740447220182&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:rJfmXzehMsalV0tv1Rph4rESeIw=" alt="Hexo Logo"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于mysql容器内部数据消失</title>
      <link href="/posts/c3592269.html"/>
      <url>/posts/c3592269.html</url>
      
        <content type="html"><![CDATA[<h1>关于 MySQL 容器内部数据消失的总结</h1><h2 id="问题描述">问题描述</h2><h2 id="在使用云服务器部署-MySQL-容器时，我遇到了一些奇怪的问题。每隔一段时间，我发现容器中的数据会消失，显示为-RECOVER-YOUR-DATA，原本存储在数据库中的数据就没有了。这让我非常困扰，最终通过排查找到了问题的根源。图片1">在使用云服务器部署 MySQL 容器时，我遇到了一些奇怪的问题。每隔一段时间，我发现容器中的数据会消失，显示为 <code>RECOVER_YOUR_DATA</code>，原本存储在数据库中的数据就没有了。这让我非常困扰，最终通过排查找到了问题的根源。<br><img src="https://cdn-a.markji.com/files/6764e7775402c84ca465da94_hd.png?e=1737643978024&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5PZ6e3hTXqg54yaL4tpxpfGc0MU=" alt="图片1"></h2><h2 id="权限问题">权限问题</h2><p>经过一些调查，我发现容器内的权限设置有问题。我修改了权限，并发现 <code>999</code> 是 MySQL 用户的权限，问题似乎得到了缓解。不过，这并不是唯一的问题根源。</p><hr><h2 id="Spring-Boot-启动问题">Spring Boot 启动问题</h2><h2 id="我也注意到，在-Spring-Boot-启动后，容器中的-MySQL-数据库经常无法连接。经过进一步排查，我猜测问题出在-Spring-Boot-启动过快，导致-MySQL-没有完全初始化好，就开始连接。这可能是容器内部数据丢失的原因之一。图片1">我也注意到，在 Spring Boot 启动后，容器中的 MySQL 数据库经常无法连接。经过进一步排查，我猜测问题出在 Spring Boot 启动过快，导致 MySQL 没有完全初始化好，就开始连接。这可能是容器内部数据丢失的原因之一。<br><img src="https://cdn-a.markji.com/files/6764ea7e5402c84ca46657ca_hd.png?e=1737643978024&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RRBFYjrEktQ_t8-5xiriIiNE4Cg=" alt="图片1"></h2><h2 id="未解之谜">未解之谜</h2><p>这个问题的根源至今没有完全弄清楚。有时，重新登录到 VSCode 后，连接问题似乎得到了缓解。虽然每次启动容器时都有类似的问题，但通过一些简单的操作（例如重新启动 Spring Boot 和导入数据），可以暂时解决问题。</p><hr><h2 id="解决方案">解决方案</h2><p>为了避免这个问题，我采取了以下几步操作：</p><ol><li>使用 <code>docker-compose up -d</code> 启动容器，以确保容器在后台运行。</li><li>每次重启 Spring Boot 后，重新导入数据，确保数据库数据不会丢失。</li></ol><hr><h2 id="小结">小结</h2><p>这次关于 MySQL 容器内部数据消失的问题，虽然没有完全找到根本原因，但我通过调整权限和重新启动服务找到了一个临时的解决方法。尽管如此，容器中 MySQL 数据丢失的问题仍需进一步调查和解决，尤其是容器启动与 Spring Boot 启动顺序的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 运维笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Docker </tag>
            
            <tag> 问题排查 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中台配置记录</title>
      <link href="/posts/91dc6d60.html"/>
      <url>/posts/91dc6d60.html</url>
      
        <content type="html"><![CDATA[<hr><p>title: 配置与部署 ElasticSearch、Kibana 和 Golang 环境<br>categories:</p><ul><li>数据中台</li><li>部署</li><li>开发环境</li></ul><hr><p>在开发数据中台项目时，我们需要配置和部署 ElasticSearch、Kibana 以及 Golang 开发环境。以下是我在配置这些工具时的完整记录。</p><h2 id="配置-ElasticSearch-和-Kibana">配置 ElasticSearch 和 Kibana</h2><h3 id="1-下载并保存-ElasticSearch-公钥">1. 下载并保存 ElasticSearch 公钥</h3><p>首先，下载并保存 ElasticSearch 的公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/trusted.gpg.d/elasticsearch.asc</span><br></pre></td></tr></table></figure><h3 id="2-添加-ElasticSearch-仓库-APT-源">2. 添加 ElasticSearch 仓库 APT 源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;echo &quot;deb https://artifacts.elastic.co/packages/7.x/apt stable main&quot; &gt; /etc/apt/sources.list.d/elastic-7.x.list&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure><h3 id="3-安装-ElasticSearch">3. 安装 ElasticSearch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install elasticsearch</span><br></pre></td></tr></table></figure><h3 id="4-启动并设置开机自启">4. 启动并设置开机自启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start elasticsearch</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> elasticsearch</span><br></pre></td></tr></table></figure><p>ElasticSearch 默认使用以下端口：</p><ul><li><strong>9200</strong>：HTTP 端口，供外部请求（例如 curl 或浏览器）访问。</li><li><strong>9300</strong>：节点间通信端口，用于集群内部节点间的连接。</li></ul><p>如果发现端口无响应，可以检查配置文件 <code>/etc/elasticsearch/elasticsearch.yml</code>，确保网络设置允许外部访问。</p><hr><h3 id="5-安装-Kibana">5. 安装 Kibana</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install kibana</span><br></pre></td></tr></table></figure><h3 id="6-启动并设置开机自启">6. 启动并设置开机自启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start kibana</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> kibana</span><br></pre></td></tr></table></figure><p>此时，Kibana 应该能够正常运行，默认使用 <strong>5601</strong> 端口。</p><h2 id="配置-Golang-开发环境">配置 Golang 开发环境</h2><h3 id="1-安装-Golang">1. 安装 Golang</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install golang-go</span><br></pre></td></tr></table></figure><h3 id="2-下载并安装-Gin">2. 下载并安装 Gin</h3><p>在高版本 Golang 中，模块化是默认的特性。我们可以使用以下命令安装 Gin 框架：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/codegangsta/gin@latest</span><br></pre></td></tr></table></figure><h3 id="3-配置环境变量">3. 配置环境变量</h3><p>将 Gin 的路径添加到系统环境变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(go <span class="built_in">env</span> GOPATH)/bin</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="4-启动项目">4. 启动项目</h3><ul><li><p>使用 Gin 启动（类似于 <code>pnpm dev</code>，支持实时监控，默认使用 <strong>3000</strong> 端口）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gin</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>go run</code> 启动（普通编译执行，无实时监控）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure></li></ul><p>初始化模块时需要执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod init mylearnGin</span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>其中 <code>go mod tidy</code> 用于整理依赖，仅在 Golang 1.2 及以上版本可用。</p><hr><h2 id="前端代码与代理配置">前端代码与代理配置</h2><p>在前端开发中，我们使用了 Vite 的自动代理功能，将 <strong>5173</strong> 端口代理到后端的 <strong>2020</strong> 端口。通过 Postman 测试后端接口时，发现代理配置正常，接口调用无问题。</p><p>默认情况下：</p><ul><li><strong>gin</strong> 启动的服务监听 <strong>3000</strong> 端口。</li><li><strong>vite</strong> 前端开发服务监听 <strong>5173</strong> 端口。</li></ul><p>通过这些配置，我们的数据中台项目后端与前端成功运行。</p><hr><p>通过以上步骤，我们完成了 ElasticSearch、Kibana 的部署以及 Golang 和 Gin 的开发环境配置。这是我们学院数据中台项目的部署记录，希望对需要快速搭建开发环境的同学有所帮助。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我关于git曾经使用过的命令</title>
      <link href="/posts/8b1604a3.html"/>
      <url>/posts/8b1604a3.html</url>
      
        <content type="html"><![CDATA[<h1>Git 和网络代理相关的曾经使用过的命令</h1><h2 id="Git-命令">Git 命令</h2><h3 id="很多人学习git的时候-命令五花八门的-我认为总结一些常用的命令是很重要的-以下是本人在开发过程中常用到命令">很多人学习git的时候,命令五花八门的,我认为总结一些常用的命令是很重要的,以下是本人在开发过程中常用到命令</h3><h3 id="基本操作">基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git commit -m<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>添加文件</strong></p><ul><li>记录删除操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li>不记录删除操作：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>远程仓库</strong></p><ul><li>添加远程：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http...  <span class="comment"># 添加远程</span></span><br><span class="line">git remote add upstream https:  <span class="comment"># 添加上游</span></span><br></pre></td></tr></table></figure></li><li>查看远程：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>推送与拉取</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li><li><p><strong>查看版本信息</strong></p><ul><li>查看版本号：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li><li>查看最近 5 条版本信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n 5 --oneline</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>版本回退</strong></p><ul><li>硬回退：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure></li><li>软回退：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft 6d3a76f</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="分支操作">分支操作</h3><ul><li><strong>创建并切换分支</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b online</span><br></pre></td></tr></table></figure></li><li><strong>分支合并</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge online  <span class="comment"># 把 master 合并到 online 分支</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置用户信息">配置用户信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config [--global] user.name <span class="string">&#x27;吃面包&#x27;</span></span><br><span class="line">git config [--global] user.email <span class="string">&#x27;14731398+eat-bread@user.noreply.gitee.com&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="配置代理">配置代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置代理</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:7897</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7897</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用局域网代理</span></span><br><span class="line">git config --global http.proxy http://192.168.1.8:7897</span><br><span class="line">git config --global https.proxy http://192.168.1.8:7897</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><h3 id="忽略文件">忽略文件</h3><ul><li>移除文件夹但保留本地文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached **/build/</span><br></pre></td></tr></table></figure></li><li>更新 <code>.gitignore</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .gitignore</span><br></pre></td></tr></table></figure></li></ul><h3 id="回退-GitHub-版本">回退 GitHub 版本</h3><ol><li>在 GitHub 上无法直接回退，需要借助本地操作。</li><li>获取需要回退到的 commit 哈希值，复制。</li><li>克隆仓库：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repository&gt;</span><br></pre></td></tr></table></figure></li><li>执行回退：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard &lt;哈希值&gt;</span><br><span class="line">git push --force  <span class="comment"># 注意：会直接覆盖 GitHub 的记录，谨慎使用！</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="恢复被删除的目录">恢复被删除的目录</h3><ol><li><p>提取某个版本的目录或文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout abc1234^ -- [相对目录/文件路径]</span><br></pre></td></tr></table></figure><ul><li>从指定的父版本 <code>abc1234</code> 中提取文件或目录。</li><li>提取后会恢复到当前分支的工作区。</li></ul></li><li><p>提交恢复内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add [目录]</span><br><span class="line">git commit -m<span class="string">&quot;恢复目录&quot;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="问题">问题</h2><h3 id="SSL-证书错误">SSL 证书错误</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/eatbreads/my_snake.git/&#x27;</span>: SSL certificate problem: unable to get <span class="built_in">local</span> issuer certificate</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslverify <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="代理连接失败">代理连接失败</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/eatbreads/fly_server.git/&#x27;</span>: Failed connect to 172.17.44.73:7897; No route to host</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 有时即使配置了代理也可能无法连接。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker compose 内部的mysql的链接</title>
      <link href="/posts/e2a8a3bb.html"/>
      <url>/posts/e2a8a3bb.html</url>
      
        <content type="html"><![CDATA[<h1>Docker Compose 内部的 MySQL 连接问题总结</h1><h2 id="问题描述">问题描述</h2><p>在使用 Docker Compose 部署 MySQL 容器时，我遇到了一些关于连接的问题。发现 MySQL 容器的配置文件位置似乎不太对，导致容器内部的数据库无法正常连接。</p><h2 id="解决方案">解决方案</h2><p>为了解决这个问题，我需要确保在 Docker Compose 配置中正确指定了 MySQL 配置文件的位置。通过检查容器内的文件路径并调整 Docker Compose 配置文件中的设置，确保容器启动时能找到正确的配置文件。</p><p><img src="https://cdn-a.markji.com/files/6767960081df59c0dc5552b8_hd.png?e=1737643978024&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:OemKu6DAYYX2N3Ffy_wAz5Tr0q0=" alt="图片1"></p><h2 id="小结">小结</h2><p>通过这次排查，我认识到 Docker Compose 内部 MySQL 容器配置文件路径的问题，以及它对容器连接的影响。确保正确配置路径和网络设置，是解决 MySQL 容器连接问题的关键。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于mysql本机之外链接不上的问题和中文字符集</title>
      <link href="/posts/663c4484.html"/>
      <url>/posts/663c4484.html</url>
      
        <content type="html"><![CDATA[<h1>关于 MySQL 连接不上和中文字符集问题的总结</h1><h2 id="问题描述">问题描述</h2><p>在使用 MySQL 时，我遇到了一些连接问题，尤其是在处理中文字符集时出现了乱码。经过一些排查，我发现问题与 MySQL 的字符集设置有关。</p><hr><h2 id="修改字符集配置">修改字符集配置</h2><p>在 Linux 系统中，可以通过编辑 MySQL 的配置文件来修改字符集。路径是 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code>，而在 Windows 系统中，通常是 <code>my.ini</code> 文件。<br><img src="https://cdn-a.markji.com/files/674976f0d66a8266eeb31e9c_hd.png?e=1737643978022&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MGPaZPNZ0d2Y34oG2Qzpv37mfA4=" alt="图片1"><br>我修改了以下几个配置项来解决字符集问题：</p><ul><li><p><strong>character-set-server</strong>: 设置服务器的默认字符集为 <code>utf8mb4</code>，这是 MySQL 最推荐的字符集，支持所有 Unicode 字符。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">character-set-server</span> = utf8mb4</span><br></pre></td></tr></table></figure></li><li><p><strong>collation-server</strong>: 设置服务器的默认排序规则为 <code>utf8mb4_unicode_ci</code>，这是 <code>utf8mb4</code> 字符集的通用排序规则。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">collation-server</span> = utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure></li><li><p><strong>init-connect</strong>: 在每个客户端连接时设置字符集为 <code>utf8mb4</code>。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">init-connect</span>=<span class="string">&#x27;SET NAMES utf8mb4&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><p>这些设置确保了 MySQL 使用支持所有 Unicode 字符的字符集和排序规则。<br><img src="https://cdn-a.markji.com/files/67498a22c0bbb7b3acebaeb3_hd.png?e=1737643978022&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:JU-tjEJ_PNOI4rzAtjaL_4s40KY=" alt="图片1"></p><h2 id="图片1"><img src="https://cdn-a.markji.com/files/67498b45d66a8266eeb92709_hd.png?e=1737643978022&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:VfYXlZyC19S4eLkf9232I6DZ7uY=" alt="图片1"></h2><h2 id="数据已导入后无法直接修改">数据已导入后无法直接修改</h2><p>修改字符集设置后，我发现由于数据已经导入到数据库中，直接修改字符集配置并不能生效。为了解决这个问题，我需要手动重新执行建表语句。</p><hr><h2 id="优化流程">优化流程</h2><p>在执行这些更改时，我的建议是：</p><ol><li><strong>先修改配置文件</strong>，确保 MySQL 使用 <code>utf8mb4</code> 字符集。</li><li><strong>然后重新执行插入语句</strong>，确保数据表使用正确的字符集。</li></ol><p>为了更好地管理这个过程，我将这些操作写入了 <code>start.sh</code> 脚本，确保每次启动容器时，MySQL 都能自动加载这些配置。</p><hr><h2 id="重新构建镜像">重新构建镜像</h2><p>在我重新构建镜像后，发现字符集问题已经得到解决，并且中文字符能够正常显示。镜像构建时，我确保了配置的正确性，避免了手动操作时可能出现的错误。</p><hr><h2 id="小结">小结</h2><p>通过这次解决 MySQL 连接和字符集问题的经历，我学到了如何正确设置 MySQL 的字符集配置，并避免字符集不匹配导致的乱码问题。修改配置文件后，我手动执行了建表语句，并且在重新构建镜像时确保了问题得到解决。将这些操作写入脚本中，也大大简化了以后部署的过程。</p><p><img src="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" alt="图片1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用smtp服务</title>
      <link href="/posts/dac8faad.html"/>
      <url>/posts/dac8faad.html</url>
      
        <content type="html"><![CDATA[<h1>使用 SMTP 发送邮件的总结</h1><h2 id="初步尝试">初步尝试</h2><p>在项目中，我需要实现邮件发送功能，于是决定使用 SMTP 协议来发送邮件。最初，我尝试使用 C++ 中的 <code>curl</code> 库进行连接，然而在连接时遇到了一些问题，主要是无法连接到服务器。<br><img src="https://cdn-a.markji.com/files/674fd76334a2d0766ac942e7_hd.png?e=1737642002782&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:CMPJAgcbZzD_uY6HWF7V6dFN2VI=" alt="图片1"></p><h3 id="问题分析">问题分析</h3><ul><li>使用的端口 587 被拒绝连接。经过排查，发现最初可能是由于编码问题导致无法正确连接。<br><img src="https://cdn-a.markji.com/files/674fdb1c1dd56644358b2808_hd.png?e=1737642002782&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Huu9GsLcuBAwvfOV6JvYRyt77Gg=" alt="图片1"></li><li>虽然在 Python 中能成功连接 SMTP 服务，但在 C++ 中却无法连接成功。这让我陷入了困惑。</li></ul><hr><h2 id="使用-Python-脚本解决问题">使用 Python 脚本解决问题</h2><p>由于在 Python 中 SMTP 连接能够正常工作，我决定通过系统调用来直接运行 Python 脚本，解决 C++ 发送邮件的问题。最终，成功调用 Python 脚本实现了邮件发送功能。<br><img src="https://cdn-a.markji.com/files/674fdb1c1dd56644358b2808_hd.png?e=1737642002782&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Huu9GsLcuBAwvfOV6JvYRyt77Gg=" alt="图片1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line">msg = MIMEText(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">msg[<span class="string">&quot;Subject&quot;</span>] = <span class="string">&quot;SMTP Test&quot;</span></span><br><span class="line">msg[<span class="string">&quot;From&quot;</span>] = <span class="string">&quot;your-email@example.com&quot;</span></span><br><span class="line">msg[<span class="string">&quot;To&quot;</span>] = <span class="string">&quot;recipient@example.com&quot;</span></span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(<span class="string">&quot;smtp.example.com&quot;</span>, <span class="number">587</span>)</span><br><span class="line">server.starttls()</span><br><span class="line">server.login(<span class="string">&quot;your-email@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br><span class="line">server.sendmail(msg[<span class="string">&quot;From&quot;</span>], msg[<span class="string">&quot;To&quot;</span>], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure><p>我通过 C++ 使用 <code>system()</code> 函数来调用这个 Python 脚本，从而绕过了 C++ 中的 SMTP 连接问题。</p><hr><h2 id="集成到-Java-项目">集成到 Java 项目</h2><p>一旦邮件发送功能在 C++ 中解决了，我开始将其集成到 Java 项目中。过程非常顺利，只需导入相关库即可实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String to, String subject, String body)</span> &#123;</span><br><span class="line">        <span class="comment">// Email sending code using JavaMail API</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，在集成过程中遇到了一个经典的 Spring Boot 版本问题。Spring Boot 版本不匹配导致无法解析依赖项。这个问题需要到网上查找解决方案，并确保正确配置了 <code>pom.xml</code> 中的依赖版本。</p><hr><h2 id="小结">小结</h2><p>通过这次实现 SMTP 邮件发送功能的过程，我经历了从 C++ 到 Python，再到 Java 的集成工作。虽然 C++ 连接 SMTP 时遇到了一些问题，但最终通过调用 Python 脚本解决了问题。而在 Java 中集成时，也遇到了一些常见的框架版本不匹配问题，解决这些问题后邮件发送功能得以顺利实现。</p><p><img src="https://cdn-a.markji.com/files/674ff77c2f7418f70a3eb83f_hd.png?e=1737642002782&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:SATav5nL6qzotwRGgW6wkky0vK8=" alt="图片1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于web库抛出异常</title>
      <link href="/posts/dbb74d1e.html"/>
      <url>/posts/dbb74d1e.html</url>
      
        <content type="html"><![CDATA[<h1>关于 Web 库抛出异常的总结</h1><h2 id="问题起因">问题起因</h2><p>在处理报文时，舍友发送的报文中包含了微信的特殊字符，这导致了 JSON 数据格式不合法，最终抛出了 <code>login</code> 异常，导致程序崩溃。这个问题让我意识到需要更好地处理异常，避免程序直接终止。</p><hr><h2 id="异常分析">异常分析</h2><p>在分析过程中，我发现当 JSON 库在解析过程中遇到错误时，会抛出异常。而这个异常没有被正确处理，导致了程序的崩溃。为了避免这个问题，我决定在 <code>http_task</code> 中捕获报文体解析时抛出的异常，并记录日志，而不是让程序直接崩溃。</p><hr><h2 id="捕获异常与调试">捕获异常与调试</h2><p>通过查看函数调用堆栈，我能够准确定位到抛出异常的具体位置。基于此，我可以在正确的地方进行异常捕获，确保程序能够在遇到类似情况时优雅地处理异常。</p><hr><h2 id="使用-VSCode-作为调试器">使用 VSCode 作为调试器</h2><p>为了进一步调试这个问题，我尝试使用 VSCode 作为调试器。按照原本的 CMake 配置进行操作，VSCode 成功地启动了调试会话，帮助我更容易地跟踪程序的执行流程。</p><hr><h2 id="虚拟机性能问题">虚拟机性能问题</h2><p>在调试过程中，我发现虚拟机的性能较差，导致 Postman 访问虚拟机时非常卡，甚至严重影响了开发进程。尽管如此，这个问题在一段时间后自行缓解，可能是由于网络问题或资源分配不足。</p><hr><h2 id="异常捕获的最终解决方案">异常捕获的最终解决方案</h2><p>通过不断调试和查看堆栈跟踪，我最终找到了抛出异常的具体点，并在该点添加了异常处理。这样，程序在遇到类似的报文异常时，不会再崩溃，而是会记录详细的日志，帮助我们进一步分析和修复问题。</p><hr><h2 id="小结">小结</h2><p>通过这次处理 Web 库抛出异常的经验，我学到了如何在正确的地方捕获异常，并记录日志，避免程序崩溃。使用 VSCode 调试器也让我更高效地解决了问题，虽然在虚拟机上运行时遇到了一些性能问题，但最终通过耐心等待和分析，问题得以解决。</p><p><img src="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" alt="图片1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>打包cpp后端代码进入docker</title>
      <link href="/posts/860d7848.html"/>
      <url>/posts/860d7848.html</url>
      
        <content type="html"><![CDATA[<h1>C++ 后端打包 Docker 镜像总结</h1><p>将 C++ 的代码打包成 Docker 镜像的过程</p><h2 id="步骤">步骤</h2><ol><li><p><strong>静态编译</strong></p><p>先使用静态编译，确保代码的依赖能被打包到最终的可执行文件中。</p></li><li><p><strong>编写 Dockerfile</strong></p><p>创建一个 Dockerfile，用于构建镜像。</p></li><li><p><strong>构建 Docker 镜像</strong></p><p>使用命令构建镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mywebproject:latest .</span><br></pre></td></tr></table></figure></li><li><p><strong>测试镜像</strong></p><p>在本地构建后，使用 <code>docker run</code> 命令测试镜像是否能正常运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name mywebproject_container -p 8080:8080 mywebproject /bin/bash</span><br></pre></td></tr></table></figure></li><li><p><strong>推送到镜像仓库</strong></p><p>当本地测试通过后，可以将镜像推送到镜像仓库。</p></li></ol><hr><h2 id="使用-Docker-Compose-统一管理多个镜像">使用 Docker Compose 统一管理多个镜像</h2><p>通过 Docker Compose 可以方便地管理多个服务，比如同时运行 <code>MySQL</code> 和 <code>MinIO</code> 镜像。在此过程中，我将数据库连接参数写死了，虽然不太灵活，但快速构建时是可接受的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">/data</span></span><br></pre></td></tr></table></figure><hr><h2 id="处理跨平台问题">处理跨平台问题</h2><p>目前的 CMake 配置并不完美，需要适应不同的 Linux 环境，特别是在动态库和头文件路径方面。由于依赖的环境不同，CMake 配置需要更通用一些，以便在不同平台下能成功构建。</p><p><img src="https://cdn-a.markji.com/files/673ff6bd4b5c865a82e26cc4_hd.png?e=1737642002780&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:8Y9jWFstiT7yiyKjP9yB9rv89lw=" alt="图片1"></p><h2 id="图片1"><img src="https://cdn-a.markji.com/files/673ffb62813017964582c91e_hd.png?e=1737642002780&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ewba-9d0qW2iVT870DRQwR-tlJA=" alt="图片1"></h2><h2 id="关于镜像构建的优化">关于镜像构建的优化</h2><p>在构建镜像时，如果每次都要执行测试命令，重新构建会非常麻烦。为了避免每次都重建镜像，可以构建一个不执行测试命令的基础镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t mywebproject:latest .</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/673ffe1f4b5c865a82e46a1f_hd.png?e=1737642002780&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:V-6ZeVmCGEAgeLAyThHm4m9CrcU=" alt="图片1"><br>然后进入镜像内部，手动运行构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name mywebproject_container mywebproject /bin/bash</span><br></pre></td></tr></table></figure><p>这样就避免了每次都需要重新构建的问题。</p><hr><h2 id="遇到的库路径问题">遇到的库路径问题</h2><p>在容器内部，我遇到了一些关于库路径和版本的问题。通过运行 <code>ldd ./main</code>，可以查看缺少的库，并根据实际情况安装对应版本的库。最终，我发现 Ubuntu 系统中库文件常常位于：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>lib/x86_64-linux-gnu</span><br></pre></td></tr></table></figure><h2 id="图片1-2"><img src="https://cdn-a.markji.com/files/6740933f8eb894c77959208d_hd.png?e=1737642002781&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:acxFONkOm0JF9g81zes7a5prQXs=" alt="图片1"></h2><h2 id="版本依赖问题">版本依赖问题</h2><h2 id="即使编译成功，运行时依然可能会遇到库版本不匹配的问题，导致程序无法启动。这时，Docker-的优势得到了体现。通过指定-Docker-镜像的基础版本，可以避免版本不匹配的麻烦。图片1">即使编译成功，运行时依然可能会遇到库版本不匹配的问题，导致程序无法启动。这时，Docker 的优势得到了体现。通过指定 Docker 镜像的基础版本，可以避免版本不匹配的麻烦。<br><img src="https://cdn-a.markji.com/files/67409a15934b33cc600f0356_hd.png?e=1737642002781&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:kHylrBJ7TV-lbmYH8lp8rbodiSQ=" alt="图片1"></h2><h2 id="使用低版本-Ubuntu-解决依赖问题">使用低版本 Ubuntu 解决依赖问题</h2><p>为了应对版本不兼容的问题，我尝试使用低版本的 Ubuntu 镜像进行构建，这样可以下载较旧版本的依赖库。然而，这样做的缺点是，镜像中的 <code>apt</code> 下载速度较慢。为了减少构建过程中的问题，我最终选择了较为稳定的版本。</p><hr><h2 id="最终结果">最终结果</h2><p>经过一番尝试和修复，最终我成功构建了镜像，并且解决了端口映射的问题。使用以下命令运行容器，确保能够通过端口访问到应用：<br><img src="https://cdn-a.markji.com/files/6740b1438eb894c77960e935_hd.png?e=1737642002781&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:977QLHB2NCVWpU5Enzigzu_GRys=" alt="图片1"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name mywebproject_container -p 8080:8080 mywebproject /bin/bash</span><br></pre></td></tr></table></figure><hr><h2 id="部署到服务器">部署到服务器</h2><p>当镜像构建完成并且本地测试通过后，我就可以尝试将镜像上传到服务器，进行部署和运行。</p><hr><h2 id="小结">小结</h2><p>通过这次构建 C++ 后端 Docker 镜像的过程，我不仅学到了 Docker 和 CMake 配置的技巧，还解决了多个跨平台的依赖和版本问题。使用 Docker 的优势尤为突出，尤其是在处理依赖版本不兼容时提供了极大的便利。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用vcpkg执行包管理</title>
      <link href="/posts/25c6d8ad.html"/>
      <url>/posts/25c6d8ad.html</url>
      
        <content type="html"><![CDATA[<h1>尝试使用 vcpkg 运行项目</h1><h2 id="1-vcpkg-介绍">1. vcpkg 介绍</h2><p><code>vcpkg</code> 安装库时，不会与系统中已存在的库发生冲突。它默认将安装的库存放在 <code>vcpkg_installed</code> 目录中，并通过 CMake 或编译命令来链接这些库。</p><h2 id="2-安装-vcpkg">2. 安装 vcpkg</h2><p>进入 <code>home</code> 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure><p>克隆 vcpkg 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/microsoft/vcpkg.git</span><br></pre></td></tr></table></figure><p>进入 vcpkg 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> vcpkg</span><br></pre></td></tr></table></figure><p>编译 vcpkg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap-vcpkg.sh</span><br></pre></td></tr></table></figure><h2 id="3-配置环境变量">3. 配置环境变量</h2><p>将 vcpkg 添加到环境变量，使其可以全局使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$HOME/vcpkg:$PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>这样就可以在终端中直接使用 <code>vcpkg</code> 了</p><p><img src="https://cdn-a.markji.com/files/679de4005017c826b3e9f40f_hd.png?e=1741010058858&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:mZGz5l-YhfjDsvs3LRpJvTXC1hk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/679de8315017c826b3ea3358_hd.png?e=1741010058858&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Wz8CREnbJJWIZSXRYbQb1GB2qJY=" alt="图片1"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> vcpkg </tag>
            
            <tag> 包管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薪酬管理系统关于路径问题</title>
      <link href="/posts/2107c920.html"/>
      <url>/posts/2107c920.html</url>
      
        <content type="html"><![CDATA[<h1>关于路径问题的总结</h1><h2 id="问题描述">问题描述</h2><h2 id="在项目中，我引入了一个第三方的-CSV-解析库。问题出现了：这个库不支持相对路径，因此在助教的环境中运行时，我必须要求他们手动指定绝对路径。这个做法显然不太方便，尤其是在不同的环境中部署时。图片1">在项目中，我引入了一个第三方的 CSV 解析库。问题出现了：这个库不支持相对路径，因此在助教的环境中运行时，我必须要求他们手动指定绝对路径。这个做法显然不太方便，尤其是在不同的环境中部署时。<br><img src="https://cdn-a.markji.com/files/672f59d20ac7ae9081def5f9_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:wf7RxKbiFD3WWzGCS8n57n6p2ng=" alt="图片1"></h2><h2 id="解决思路">解决思路</h2><p>我开始思考，是否能够自动获取可执行文件的路径，并基于此拼接出一个绝对路径，这样就不需要依赖手动输入路径了。于是我尝试过多种方法，包括调用 Windows 自身的 API 等，但始终没有成功。</p><hr><h2 id="最终解决方案">最终解决方案</h2><h2 id="经过不断尝试和调整，我终于找到了一个有效的方式，成功获取了可执行文件的路径并拼接成了正确的绝对路径。虽然过程中尝试了很多方法，有些方法最终都没有奏效，但最终我找到了一个合适的解决方案。图片1">经过不断尝试和调整，我终于找到了一个有效的方式，成功获取了可执行文件的路径并拼接成了正确的绝对路径。虽然过程中尝试了很多方法，有些方法最终都没有奏效，但最终我找到了一个合适的解决方案。<br><img src="https://cdn-a.markji.com/files/672f5b34f20d86d346644888_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:bX_UsNFy7sUFIWaWdGmtqV6lLNQ=" alt="图片1"></h2><h2 id="小结">小结</h2><p>路径问题经常在跨平台开发中出现，尤其是第三方库不支持相对路径时。通过获取可执行文件的路径并拼接成绝对路径，我避免了手动配置路径的问题。这次的经历让我更加深刻地理解了路径处理在不同环境下的重要性，尤其是在多平台支持的项目中。</p><p>int &amp; fun()<br>{<br>return x;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>智能指针管理Person</title>
      <link href="/posts/4a477991.html"/>
      <url>/posts/4a477991.html</url>
      
        <content type="html"><![CDATA[<h1>关于智能指针和抽象基类的 <code>new</code> 总结</h1><h2 id="问题描述">问题描述</h2><p>在最初编写 <code>Person</code> 类时，我发现为了实现多态，<code>personVec</code>（用于统一管理 <code>Person</code> 对象）应该存储的是指针。然而，问题随之而来：如何管理这些指针的内存？因为我习惯于“谁申请，谁释放”的内存管理方式，而此处的指针是外部传进来的。</p><hr><p><img src="https://cdn-a.markji.com/files/6722489da5ae5f54b592ddb3_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:8y0aDklJKoXE_A5xn7L6W8eGwks=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/672252dba5ae5f54b594d451_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:K4oV7f56rzmM3dQjGz4KB6o7qC8=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/672259df58683e065fe6a0fb_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:xkJLV-2w8r8LiCcpUeoMwACEuCI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6722f673e28baad2f1470fac_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:1lIkjpwVTNgACXYzkS7cgenvoyM=" alt="图片1"><br>![图片1](<a href="https://cdn-a.markji.com/files/6722fb9858683e065ff1cf18_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MrTGKOeuNYNd13PvUj_Ad7hu74A=%E7%94%A8">https://cdn-a.markji.com/files/6722fb9858683e065ff1cf18_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MrTGKOeuNYNd13PvUj_Ad7hu74A=用</a></p><p>为了简化内存管理，我决定统一使用智能指针来管理 <code>Person</code> 对象。通过将裸指针隐藏在智能指针中，我确保了内存的自动管理，并避免了手动释放的繁琐与错误。</p><hr><h2 id="遇到的问题与思考">遇到的问题与思考</h2><p>在实现过程中，我遇到了一些挑战，特别是在派生类的构造过程中。最初，我认为通过解引用智能指针就能得到 <code>Person</code> 类的对象，但实际上这个过程中出现了问题。原因在于，派生类并没有接受 <code>Person</code> 类的构造函数，导致了类型不匹配。</p><p>为了解决这个问题，我花了相当长时间去思考，最终才意识到需要正确地使用 <code>new</code> 来确保派生类对象的正确构造，并且必须显式调用派生类的构造函数。</p><hr><h2 id="二更：调试技巧">二更：调试技巧</h2><h2 id="有一个调试技巧我发现非常有帮助：通过查看调试器中的紫色区域，它会明确列出每个参数的类型。这有助于快速定位问题，特别是在类型匹配方面。图片1图片1图片1">有一个调试技巧我发现非常有帮助：通过查看调试器中的紫色区域，它会明确列出每个参数的类型。这有助于快速定位问题，特别是在类型匹配方面。<br><img src="https://cdn-a.markji.com/files/6722fbede28baad2f147b298_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:EX3PsbmNY2VXATGlAXW0C_UxO1Y=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6722fe9aa5ae5f54b5a23554_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:JpDCzsDmF49Mjn0HeGOmkCFRGDs=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67233a0ba5ae5f54b5aa2df4_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:c1c0b7rBkrwR_IfnCcXN0VevU0I=" alt="图片1"></h2><h2 id="小结">小结</h2><p>通过这次的实现，我更加深入地理解了智能指针和抽象基类的内存管理问题。智能指针确实能简化内存管理，但在多态和派生类的构造过程中，需要特别注意如何正确使用构造函数来避免潜在的内存错误。</p><p><img src="https://cdn-a.markji.com/files/67233be9e28baad2f150f543_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:w1W9m8mwfpCAMIAHQTDM9ITAPgw=" alt="图片1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++中关于嵌套定义的思考</title>
      <link href="/posts/e7e756e7.html"/>
      <url>/posts/e7e756e7.html</url>
      
        <content type="html"><![CDATA[<h1>关于嵌套定义的总结</h1><h2 id="问题描述">问题描述</h2><p>在 C++ 中，嵌套定义是指在一个头文件中包含另一个头文件，并且在不同的源文件（.cpp）中进行交叉引用。我在学习编译过程时发现，预处理阶段会将头文件 <code>a.h</code> 和 <code>b.h</code> 的内容都拷贝到源文件中。这一过程影响了编译的顺序和方式。</p><hr><h2 id="预处理和编译过程">预处理和编译过程</h2><ol><li><p><strong>预处理阶段</strong><br>预处理阶段会将 <code>a.h</code> 和 <code>b.h</code> 文件的内容插入到源文件中。其实编译器本质上只处理 <code>.cpp</code> 文件，头文件仅仅是被复制粘贴进源文件。</p></li><li><p><strong>编译过程</strong><br>在编译 <code>a.cpp</code> 时，<code>A</code> 类的定义通过前向声明 <code>B</code> 类可以正常通过编译。由于 <code>a.cpp</code> 只是对指针进行操作，而指针的大小是固定的，因此它可以直接编译并使用，甚至在调用成员函数时也没有问题，因为成员函数本质上也是指针。</p></li><li><p><strong>链接阶段</strong><br>在链接阶段，编译器会将 <code>a.o</code> 和 <code>b.o</code> 文件链接到一起，最终完成整个程序的编译过程。</p></li></ol><hr><h2 id="注意事项">注意事项</h2><p>尽管嵌套定义在一定情况下是可行的，但我建议尽量避免过度使用这种方式。使用指针可以解决类之间的依赖关系，但最好还是审视一下类之间的关系，确保设计合理。</p><hr><h2 id="小结">小结</h2><p>嵌套定义的本质是在预处理阶段将头文件内容拷贝进源文件，而编译和链接过程则是通过指针来实现对类和成员函数的操作。虽然这种方法在某些情况下可行，但最好通过审视类的设计来避免过度依赖这种方式。</p><p><img src="https://cdn-a.markji.com/files/67051e81699743e123d6fea8_hd.png?e=1737643978019&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:UGIktc9WEbW_w2TZnfKGnEa5rF0=" alt="图片1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>薪酬管理系统--关于终端字符集问题</title>
      <link href="/posts/e41624fb.html"/>
      <url>/posts/e41624fb.html</url>
      
        <content type="html"><![CDATA[<h1>关于中文字符集问题的总结</h1><h2 id="问题描述">问题描述</h2><p>在解决了大部分问题并成功跑起程序后，我开始进行一些操作测试。然而，输入中文时却出现了乱码。经过一番排查，我发现程序中的字符集设置默认是 <code>utf-8</code>，但是 VSCode 的命令行终端似乎使用的是 <code>gbk</code> 编码，导致了中文乱码问题。</p><hr><h2 id="排查过程">排查过程</h2><ol><li><p><strong>检查 VSCode 设置</strong><br>我首先查看了 VSCode 的 <code>settings.json</code> 文件，发现其中的设置都是空白的，且提示：“此设置无法应用于此工作区。它将在您直接打开包含的工作区文件夹时应用。”</p></li><li><p><strong>修改设置文件</strong><br>之后，我尝试切换到全局设置。在 VSCode 左上角选择 <strong>文件 -&gt; 首选项 -&gt; 设置</strong>，搜索 <code>setting.json</code>，并选择“在 setting.json 内部编辑”。我修改了一些编码相关的设置，但即便重启了 VSCode，中文乱码问题依然没有解决。<br><img src="https://cdn-a.markji.com/files/67244003a5ae5f54b5ca759c_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:NpuXva8ZwLyZCfqZou0bsGPi7V0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/672441c1a5ae5f54b5cabb9f_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:eXIDLSGMA5g8853a8u1C104elPo=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6724434ae28baad2f1714840_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:pFnmtrKOxGmwfp9T92fZZn-1wO0=" alt="图片1"></p></li></ol><hr><h2 id="进一步分析">进一步分析</h2><p>无论我在 VSCode 内部切换 <code>gbk</code> 或 <code>utf-8</code> 编码，都无法解决乱码问题。然后我发现可能是终端编码的问题。</p><p>通过查询，我得知 <code>chcp</code> 命令是用来切换命令行窗口的编码页，<code>936</code> 是 <code>gbk</code> 编码（简体中文）。而 <code>65001</code> 对应的是 <code>utf-8</code> 编码。因此，我尝试使用以下命令切换编码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67244ce6a5ae5f54b5cc22bd_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:V0EDcnHNzXN8hXItkTl0GlXMsLo=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67244d05a5ae5f54b5cc25f3_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:vhE-llLlGR6nfvEWCpCXkMHyiUg=" alt="图片1"><br>这一操作最终解决了 VSCode 内部终端乱码的问题。值得注意的是，当直接打开 <code>cmd</code> 时，中文输入并没有问题。</p><hr><h2 id="结论">结论</h2><p>问题的根本原因是 VSCode 内部终端的默认编码设置。虽然通过修改 <code>settings.json</code> 文件试图解决，但问题最终通过切换命令行终端的编码页得到了解决。因此，在使用 VSCode 时，如果遇到类似问题，可以通过 <code>chcp 65001</code> 来切换到 <code>utf-8</code> 编码，解决乱码问题。</p><p>至于直接输入中文的问题，我决定暂时不再使用 VSCode 终端输入中文，而是直接在外部终端中进行输入操作。</p><p><img src="https://cdn-a.markji.com/files/67244d77a5ae5f54b5cc33c1_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RpIME21mf2RZ5wSRX7jrHYjhJtc=" alt="图片1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csv解析器编写</title>
      <link href="/posts/438da789.html"/>
      <url>/posts/438da789.html</url>
      
        <content type="html"><![CDATA[<h1>关于编写 CSV 解析器的总结</h1><h2 id="问题描述">问题描述</h2><p>我在开发过程中决定编写一个用于解析 CSV 文件的类，并且要求使用模板来实现。模板在 C++ 中的语法比较复杂，导致我在实现过程中遇到了很多报错，这让我一开始遇到很多问题。</p><hr><h2 id="遇到的问题与解决方案">遇到的问题与解决方案</h2><ol><li><p><strong>模板语法问题</strong><br>一开始我在模板的使用上遇到了很多问题，导致编译时出现了大量的报错。AI 给出的建议是使用模板特例化，但实际应用中，模板特例化适用于特定的 CSV 格式，这种方式并不通用，因此最终我决定将其转化为普通模板函数（非类成员模板函数）。</p></li><li><p><strong>模板前置声明</strong><br>即便我将模板转换为普通模板函数，依然遇到报错。后来我通过添加模板的前置声明解决了这个问题。</p></li><li><p><strong>模板全特化</strong><br>经过进一步的思考，我发现模板全特化本身就具有显式实例化的功能。这让我意识到，模板特例化就像是全局头文件引入全局变量之后产生的多重定义一样，存在一些设计上的问题。<br><img src="https://cdn-a.markji.com/files/670b86e48dc79fc2583ca6e7_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:siW4kca3ny7Otu5lXuSRIePu2os=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/670b87a98dc79fc2583ce987_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:g7_HBErO4Af56yuVlllS7kdbPak=" alt="图片1"></p></li></ol><hr><h2 id="遇到的其他问题">遇到的其他问题</h2><ol><li><p><strong>虚拟机无法连接到 GitHub</strong><br>我遇到了虚拟机无法连接到 GitHub 的问题，这让我在获取资源时遇到了一些困扰。经过一番排查，发现虚拟机的网络设置可能存在问题，导致无法访问 GitHub。</p></li><li><p><strong>文件读取时偏移量的问题</strong><br>在添加新功能时，我引入了偏移量记录。AI 提出了在读取每一行时记录文件的偏移量，但在实现时存在一个 bug。问题出在我在调用 <code>getline</code> 后读取了 <code>tellg()</code>，导致对应的偏移量记录并不是当前行，而是下一行。这样，我在删除某一行时总是错误地删除了下一行的起始位置。后来我修改了逻辑，在删除原行后重新调用 <code>add</code> 方法添加新行。</p></li><li><p><strong>跨平台问题</strong><br>在 Linux 环境下测试时，逻辑没有问题，但在 Windows 环境中，删除逻辑出现了问题。经过排查，发现 Linux 和 Windows 使用不同的换行符（LF 与 CRLF），这可能是导致删除操作不正确的原因。由于换行符的差异，删除逻辑无法在 Windows 环境下正常工作。<br><img src="https://cdn-a.markji.com/files/670f625a9e947853ff1798b8_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:VE5o2tHSBvCy316o1fNvMQ2CBp8=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/670f6ab49e947853ff19b4dd_hd.png?e=1737643978020&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:B4xYEh_-To9QJVdmEDf1EyLdW2M=" alt="图片1"></p></li></ol><hr><h2 id="结论与反思">结论与反思</h2><p>通过这次编写 CSV 解析器的经历，我学到了如何更好地使用模板，并且理解了模板特化的局限性。同时，我也意识到跨平台开发中，操作系统的差异（如换行符）可能导致代码逻辑在不同平台上出现问题。虽然最终的解决方案在 Linux 上没问题，但 Windows 上出现了困难，这让我意识到跨平台开发需要特别小心这种细节。</p><p>虽然我暂时放弃了解决 Windows 下的换行符问题，但这仍然是一个值得进一步研究的方向。以后在跨平台开发时，应该更仔细地考虑操作系统之间的差异。</p><p><img src="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" alt="图片1"></p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux知识第二弹</title>
      <link href="/posts/6f07d871.html"/>
      <url>/posts/6f07d871.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-知识总结">Linux 知识总结</h3><h4 id="加载和卸载-Linux-内核模块">加载和卸载 Linux 内核模块</h4><ul><li>使用 <code>insmod</code> 或 <code>modprobe</code> 来加载内核模块（WSL 不支持，输入后显示一个都没启用）。</li></ul><h4 id="配置静态-IP">配置静态 IP</h4><ol><li>先使用 <code>ip link show</code> 查看可用的网卡。</li><li>编辑 <code>/etc/network/interfaces</code> 并写入（替换为自己的网卡名称）：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">    address 192.168.1.100</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    gateway 192.168.1.1</span><br><span class="line">    dns-nameservers 8.8.8.8 8.8.4.4</span><br></pre></td></tr></table></figure></li><li>执行 <code>sudo systemctl restart networking</code> 重启网络。</li></ol><hr><h4 id="Linux-的常见目录">Linux 的常见目录</h4><ul><li><strong><code>/bin</code></strong>：存放用户基本命令，如 <code>ls</code>、<code>cp</code>、<code>mv</code> 等。</li><li><strong><code>/sbin</code></strong>：存放系统级命令，如 <code>ifconfig</code> 和 <code>reboot</code>。</li><li><strong><code>/boot</code></strong>：存放启动程序和内核映像文件。</li><li><strong><code>/etc</code></strong>：存放环境变量、系统配置等。</li><li><strong><code>/lib</code></strong>：存放共享库和内核模块。</li><li><strong><code>/mnt</code></strong>：作为文件系统的挂载点。</li><li><strong><code>/opt</code></strong>：可选目录，存放第三方软件包。</li><li><strong><code>/proc</code></strong>：虚拟文件系统，提供系统进程和内核信息。</li><li><strong><code>/tmp</code></strong>：临时目录，重启系统后会清空。</li><li><strong><code>/usr</code></strong>：存放用户程序及其库文件。</li><li><strong><code>/var</code></strong>：存放经常变化的文件，如日志等。</li></ul><hr><h4 id="SELinux">SELinux</h4><ul><li>是一个用于加强系统安全性的工具，类似于一个安全策略管理员，确保进程仅能访问所需的资源。</li></ul><hr><h4 id="Linux-的日志系统">Linux 的日志系统</h4><ul><li>主要依赖 <code>syslog</code> 记录系统消息。</li><li>使用 <code>journalctl</code> 查询日志。</li><li>查看 <code>/var/log/syslog</code> 中的日志。</li></ul><hr><h4 id="磁盘配额管理">磁盘配额管理</h4><ul><li>通过安装 <code>quota</code> 工具，并编写配置文件、重新挂载分区等来实现磁盘配额管理。</li></ul><hr><h4 id="使用-netstat-查看网络连接">使用 <code>netstat</code> 查看网络连接</h4><ul><li><code>netstat -an</code>：显示所有的连接（包括待建立连接）。</li><li><code>netstat -tuln</code>：显示所有监听的 TCP 和 UDP 端口。</li></ul><hr><h4 id="查看和管理系统服务">查看和管理系统服务</h4><ul><li><strong>查看服务</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure></li><li><strong>启动/停止/重启/开机自启/取消自启</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start/stop/restart/enable/disable &lt;服务名&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="使用-SSH-远程登录">使用 SSH 远程登录</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@主机名</span><br></pre></td></tr></table></figure><hr><h4 id="常见-Linux-系统故障及解决">常见 Linux 系统故障及解决</h4><ul><li><strong>磁盘耗尽导致系统无法正常运行</strong><ol><li>确认故障：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure></li><li>查找占用空间的目录和文件：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /*</span><br></pre></td></tr></table></figure></li><li>定位并清理大文件。</li></ol></li></ul><hr><h4 id="strace-调试用户空间程序"><code>strace</code> 调试用户空间程序</h4><ul><li><strong>重定向输出到文件</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -o output.txt ./main</span><br></pre></td></tr></table></figure></li><li><strong>附加到正在运行的进程</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p &lt;PID&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="tcpdump-网络抓包分析"><code>tcpdump</code> 网络抓包分析</h4><ul><li><strong>指定监听的网络接口/端口</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 port 80</span><br></pre></td></tr></table></figure></li><li><strong>保存数据包到文件</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -w capture.pcap</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="排查进程占用的文件-端口">排查进程占用的文件/端口</h4><ul><li><strong>查看某个文件被哪个进程占用</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /path/file</span><br></pre></td></tr></table></figure></li><li><strong>查看占用端口的进程</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :8080</span><br></pre></td></tr></table></figure></li><li><strong>杀死进程</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="排查网络问题和故障">排查网络问题和故障</h4><ol><li>检查 IP 地址：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig 或 ip addr</span><br></pre></td></tr></table></figure></li><li>检查默认路由/网关：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure></li><li>检查 DNS：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure></li><li>测试与外部的连接：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;目标地址&gt;</span><br></pre></td></tr></table></figure></li><li>如果仍然无网络连接，可尝试重启网络服务：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="排查内存泄漏">排查内存泄漏</h4><ol><li><strong>查看整体内存使用情况</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure></li><li><strong>按内存占用排序进程</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux --<span class="built_in">sort</span>=-%mem</span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>valgrind</code> 分析程序的内存使用</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=<span class="built_in">yes</span> ./main</span><br></pre></td></tr></table></figure></li><li><strong>查看进程的内存映射情况</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap &lt;PID&gt;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="CFS（完全公平调度）">CFS（完全公平调度）</h4><ul><li><strong>CFS（Completely Fair Scheduler）</strong> 是 Linux 内核的调度策略。</li><li>每个任务按照 <strong>权重</strong> 分配 CPU 时间，权重由任务的 <strong>nice 值</strong> 决定。</li><li><strong>内部使用红黑树</strong> 管理任务，以确保公平性。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 运维 </tag>
            
            <tag> 系统管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/posts/ff05b5bf.html"/>
      <url>/posts/ff05b5bf.html</url>
      
        <content type="html"><![CDATA[<h1>心得1 创建博客</h1><h2 id="1-安装-Hexo">1. 安装 Hexo</h2><p>首先，安装 Hexo。</p><h3 id="遇到的小问题">遇到的小问题</h3><p>在安装过程中遇到了依赖问题，最终没有解决 <code>npm</code> 的依赖解析问题。我初步怀疑是 <code>npm</code> 和 <code>pnpm</code> 之间的兼容性问题。</p><h3 id="转战-WSL">转战 WSL</h3><p>后来决定直接在 WSL 上进行安装。首先，我发现 WSL 中没有安装 Node.js，于是执行以下命令来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade -y</span><br></pre></td></tr></table></figure><p>更新软件包索引，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_18.x | <span class="built_in">sudo</span> -E bash -</span><br></pre></td></tr></table></figure><p>添加 Node.js 仓库，然后安装 Node.js：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y nodejs</span><br></pre></td></tr></table></figure><p>接着安装了 <code>pnpm</code>，但发现执行 <code>pnpm add hexo-cli -g</code> 时，提示我需要执行 <code>pnpm setup</code>。解决办法是执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm setup</span><br></pre></td></tr></table></figure><p>执行完 <code>pnpm setup</code> 后，Hexo 就成功安装到环境变量中了。刷新环境变量后，问题解决。</p><h3 id="初始化-Hexo-博客">初始化 Hexo 博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">pnpm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h3 id="安装部署插件">安装部署插件</h3><p>安装 <code>hexo-deployer-git</code> 插件，以便将博客部署到 GitHub：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm add hexo-deployer-git</span><br></pre></td></tr></table></figure><p>然后初始化 Git 仓库并添加远程地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin https://github.com/your-username/your-username.github.io.git</span><br></pre></td></tr></table></figure><h3 id="部署到-GitHub">部署到 GitHub</h3><p>生成静态文件并部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>这样就可以通过 <code>https://eatbreads.github.io</code> 访问博客了。</p><hr><h3 id="使用-Hexo-查看效果">使用 Hexo 查看效果</h3><p>平时如果想查看效果，可以使用 <code>hexo server</code> 在本地查看。如果想部署到 GitHub，则使用 <code>hexo deploy</code> 将博客推送到远程仓库。</p><hr><h2 id="2-创建新文章">2. 创建新文章</h2><p>创建新文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;My New Blog Post&quot;</span></span><br></pre></td></tr></table></figure><p>这将在 <code>source/_posts/</code> 目录下生成一个 <code>.md</code> 文件，你可以在其中编写文章内容。</p><p>编写完成后，就可以再次执行 <code>hexo deploy</code> 将新文章发布到博客。</p><hr><h2 id="3-插入图片示例">3. 插入图片示例</h2><p>下面是一个插入图片的例子：</p><p><img src="https://cdn-a.markji.com/files/6786077f70264288b5aa4497_hd.png?e=1736845304404&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:-8xrC4rdVoUEq1dAVdeSvsMixQY=" alt="Hexo Logo"></p><p>这张图片将会显示在文章中。</p><h3 id="说明">说明</h3><ul><li>我使用了外部链接插入了一张 Hexo 的官方 logo 图片，确保在博客中显示。</li><li>如果想插入其他图片，只需替换图片链接即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 建站笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
