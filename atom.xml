<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到小面包的小站🥝</title>
  
  
  <link href="https://eatbreads.github.io/atom.xml" rel="self"/>
  
  <link href="https://eatbreads.github.io/"/>
  <updated>2025-03-22T15:40:13.288Z</updated>
  <id>https://eatbreads.github.io/</id>
  
  <author>
    <name>小面包🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于grae的使用</title>
    <link href="https://eatbreads.github.io/posts/5315a699.html"/>
    <id>https://eatbreads.github.io/posts/5315a699.html</id>
    <published>2025-03-22T15:40:13.000Z</published>
    <updated>2025-03-22T15:40:13.288Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>协程八股</title>
    <link href="https://eatbreads.github.io/posts/706f5e8.html"/>
    <id>https://eatbreads.github.io/posts/706f5e8.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现">实现</h2><p>这是一个基于 <code>ucontext</code> 的轻量级协程库，实现了 <strong>用户态上下文切换</strong>，支持 <strong>非抢占式协程调度</strong>。核心包括 <strong>协程管理（Routine）</strong> 和 <strong>调度器（Schedule）</strong>，采用 <strong>FIFO 调度策略</strong>，协程通过 <code>resume()</code> 切换到运行态，<code>yield()</code> 挂起并交回调度器。</p><ul><li>利用 <code>swapcontext()</code> 进行 <strong>寄存器和栈的上下文切换</strong>，避免线程切换的内核态开销。</li><li>支持 <strong>动态栈管理</strong>，通过 <strong>栈快照（<code>memcpy</code> 保存栈数据）</strong> 实现挂起与恢复。</li><li>适用于 <strong>高并发 IO 场景</strong>，可扩展为 <strong><code>epoll</code> 事件驱动</strong> 结合 <strong>异步 IO</strong>。</li></ul><h3 id="后续优化方向：">后续优化方向：</h3><ul><li><strong>多线程支持（work-stealing）</strong></li><li><strong>使用 <code>boost::context </code> 提升可移植性</strong></li><li><strong>优化调度算法</strong></li></ul><hr><h2 id="亮点">亮点</h2><ul><li><strong>纯用户态调度，低开销，高效执行</strong><ul><li><code>swapcontext()</code> 仅涉及 <strong>寄存器和栈切换</strong>，比 <code>std::thread</code> 的调度更轻量。</li></ul></li><li><strong>使用非抢占式调度，确保任务可控</strong></li><li><strong>采用栈快照（<code>memcpy</code> 备份数据）</strong><ul><li>在 <code>yield()</code> 时存储当前执行状态，<code>resume()</code> 时恢复。</li><li>避免 <code>setjmp/longjmp</code> 传统方法的局限性，提高灵活性和可维护性。</li></ul></li><li><strong>比线程池更轻量</strong><ul><li>避免大量线程带来的上下文切换和同步开销。</li></ul></li></ul><hr><h2 id="难点与解决方案">难点与解决方案</h2><h3 id="1-yield-需要保存协程的执行状态，否则恢复时会丢失现场">1. <code>yield()</code> 需要保存协程的执行状态，否则恢复时会丢失现场</h3><blockquote><p><strong>挑战</strong>：栈是动态增长的，如何正确地保存 &amp; 恢复执行环境？</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>使用 <code>memcpy</code> 备份协程栈</strong><ul><li>在 <code>yield()</code> 时，计算栈使用空间，并将数据拷贝到堆中，防止被覆盖。</li></ul></li><li><strong>动态分配存储空间</strong><ul><li>如果 <code>yield()</code> 时的栈大小变大，重新分配存储，确保数据完整性。</li></ul></li><li><strong>在 <code>resume()</code> 时恢复栈数据</strong><ul><li>然后调用 <code>swapcontext()</code> 切回协程。</li></ul></li></ul><h3 id="2-ucontext-API-兼容性问题">2. <code>ucontext</code> API 兼容性问题</h3><blockquote><p><strong>问题</strong>：未来的 Linux 可能移除 <code>ucontext</code>，如何保持代码的可移植性？</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>切换到 <code>Boost.Context</code></strong></li><li><strong>使用 Linux <code>swapcontext()</code> 替代方案</strong>，如 <code>fibers</code> 或 <code>libco</code>。</li></ul><h3 id="3-协程调度优化">3. 协程调度优化</h3><blockquote><p><strong>问题</strong>：目前是单线程 FIFO 调度，如果协程数量过多，可能出现某些协程长期得不到执行的问题。</p></blockquote><p><strong>优化方案：</strong></p><ul><li><strong>使用时间片调度</strong><ul><li>让 <code>yield()</code> 也能由调度器主动调用，防止某些任务长期占用 CPU。</li></ul></li><li><strong>基于优先级的调度</strong><ul><li>例如高优先级的协程可以优先执行（可结合任务权重机制）。</li></ul></li><li><strong>多线程 Work-Stealing</strong><ul><li>不同线程管理自己的协程池，当某个线程空闲时，可以从别的线程窃取任务，提升 CPU 资源利用率。</li></ul></li></ul><h3 id="4-如何让多个线程安全地调度协程？">4. 如何让多个线程安全地调度协程？</h3><blockquote><p><strong>问题</strong>：目前是单线程，但很多高并发场景需要多个线程并行执行协程。</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>多线程调度器（Work-Stealing）</strong><ul><li>每个线程有自己的 <code>Schedule</code>，但可以从别的线程偷取任务。</li></ul></li><li><strong>使用 <code>std::mutex</code> + <code>std::queue</code> 共享任务队列</strong><ul><li>当某个线程空闲时，可以从公共队列取任务。</li></ul></li><li><strong>无锁队列优化（如 MPSC Queue）</strong><ul><li>减少锁的开销，提高并发度。</li></ul></li></ul><hr><h2 id="总结">总结</h2><p>本协程库基于 <code>ucontext</code>，采用 <strong>非抢占式调度</strong>，支持 <strong>栈快照</strong>，适用于高并发 IO 场景。未来可以扩展多线程 <code>work-stealing</code> 以及更优的调度策略，提高整体性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;这是一个基于 &lt;code&gt;ucontext&lt;/code&gt; 的轻量级协程库，实现了 &lt;strong&gt;用户态上下文切换&lt;/strong&gt;，支持 &lt;strong&gt;非抢占式协程调度&lt;/strong&gt;。核心包括 &lt;strong&gt;协程管理（Rou</summary>
      
    
    
    
    <category term="编程" scheme="https://eatbreads.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://eatbreads.github.io/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="协程" scheme="https://eatbreads.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="ucontext" scheme="https://eatbreads.github.io/tags/ucontext/"/>
    
    <category term="异步IO" scheme="https://eatbreads.github.io/tags/%E5%BC%82%E6%AD%A5IO/"/>
    
  </entry>
  
  <entry>
    <title>使用 vcpkg 运行 redis++ 遇到的问题</title>
    <link href="https://eatbreads.github.io/posts/be1ef227.html"/>
    <id>https://eatbreads.github.io/posts/be1ef227.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>使用 vcpkg 安装 redis++ 库后，发现该库并没有 <code>.cmake</code> 文件，导致 <code>find_package</code> 无法找到它。</p><h2 id="现象分析">现象分析</h2><p>通过 <code>ls</code> 命令查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /root/vcpkg/installed/x64-linux/lib</span><br></pre></td></tr></table></figure><p>可以确认 redis++ 确实已经安装，并且在代码中可以跳转到对应的定义文件。但由于缺少 CMake 配置文件，只能手动指定路径进行连接。<br><img src="https://cdn-a.markji.com/files/67d9717eb49cc95a6c0f4ea3_hd.png?e=1742368508911&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:44busKLsAaG2t2U6WGRFo4uQL4s=" alt="图片1"></p><h2 id="解决尝试">解决尝试</h2><p>尝试手动指定库路径，但在链接时遇到错误，提示找不到某些函数定义，怀疑是动态库和静态库混用的问题。然而最终仍然没有找到具体原因。</p><h2 id="结果总结">结果总结</h2><ol><li><strong>好消息</strong>：redis++ 通过手动指定路径找到了。</li><li><strong>坏消息</strong>：仍然无法正确链接，可能与库的静态/动态方式混用有关。</li></ol><p>最后还是没能解决这个问题，先摆烂了 😭。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;使用 vcpkg 安装 redis++ 库后，发现该库并没有 &lt;code&gt;.cmake&lt;/code&gt; 文件，导致 &lt;code&gt;find_package&lt;/code&gt; 无法找到它。&lt;/p&gt;
&lt;h2 id=&quot;现象分析&quot;&gt;现象分析&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://eatbreads.github.io/categories/C/"/>
    
    <category term="vcpkg" scheme="https://eatbreads.github.io/categories/C/vcpkg/"/>
    
    <category term="Redis" scheme="https://eatbreads.github.io/categories/C/vcpkg/Redis/"/>
    
    
    <category term="redis++" scheme="https://eatbreads.github.io/tags/redis/"/>
    
    <category term="vcpkg" scheme="https://eatbreads.github.io/tags/vcpkg/"/>
    
    <category term="CMake" scheme="https://eatbreads.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>使用 C++ 运行 Kafka 和 Elasticsearch</title>
    <link href="https://eatbreads.github.io/posts/b71a46cc.html"/>
    <id>https://eatbreads.github.io/posts/b71a46cc.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-处理方式">Elasticsearch 处理方式</h2><p>Elasticsearch 通常直接使用 HTTP 报文通信，因此不需要额外下载 C++ 库，直接通过 HTTP 请求即可进行操作。</p><h2 id="Kafka-处理方式">Kafka 处理方式</h2><p>Kafka 我使用的是 vcpkg 提供的包，但和之前遇到的问题一样，<code>find_package</code> 无法直接找到，所以还是手动加入了库的路径。<br><img src="https://cdn-a.markji.com/files/67da545476d0a5611b7c05e6_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:OVEEkK8mOAmVOjHyA1CWapEMpvM=" alt="图片1"></p><h2 id="遇到的问题">遇到的问题</h2><ol><li><p><strong>AI 帮的倒忙</strong><br>在调用某个接口时，AI 生成的代码少了两个参数，导致无法正常执行。最后还是我自己手动跳转到定义里查看并修正了。</p></li><li><p><strong>Docker Compose 启动多个容器</strong><br>我使用 <code>docker-compose</code> 一键启动了多个服务，包括 Redis、Kafka 等，但在尝试运行时，Kafka 无法正确收到消息，导致程序无法正常工作。<br><img src="https://cdn-a.markji.com/files/67da6357b49cc95a6c2923c7_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:O71hPvwIkVaNim_dDLTqxlJhPos=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67da644fb49cc95a6c293c85_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:j5hKpx7807ueI8nBNuZ3yhQu3SA=" alt="图片1"></p></li><li><p><strong>最终解决方案</strong><br>去 CSDN 找了代码，终于能正常执行了，AI 这次还是不行 😓。</p></li></ol><h2 id="总结">总结</h2><ul><li>Elasticsearch 直接用 HTTP 通信，无需额外的 C++ 库。</li><li>Kafka 需要手动指定路径才能使用。</li><li><code>docker-compose</code> 方便管理多个容器，但 Kafka 运行过程中可能遇到无法接收消息的问题。</li><li>代码有问题时，AI 可能会犯病，还是要多检查文档和源码。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Elasticsearch-处理方式&quot;&gt;Elasticsearch 处理方式&lt;/h2&gt;
&lt;p&gt;Elasticsearch 通常直接使用 HTTP 报文通信，因此不需要额外下载 C++ 库，直接通过 HTTP 请求即可进行操作。&lt;/p&gt;
&lt;h2 id=&quot;Kafka-</summary>
      
    
    
    
    <category term="C++" scheme="https://eatbreads.github.io/categories/C/"/>
    
    <category term="Kafka" scheme="https://eatbreads.github.io/categories/C/Kafka/"/>
    
    <category term="Elasticsearch" scheme="https://eatbreads.github.io/categories/C/Kafka/Elasticsearch/"/>
    
    
    <category term="vcpkg" scheme="https://eatbreads.github.io/tags/vcpkg/"/>
    
    <category term="Docker" scheme="https://eatbreads.github.io/tags/Docker/"/>
    
    <category term="分布式" scheme="https://eatbreads.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>消息队列的基础编写</title>
    <link href="https://eatbreads.github.io/posts/be5c987b.html"/>
    <id>https://eatbreads.github.io/posts/be5c987b.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-任务封装">1. 任务封装</h2><p>首先实现了 <code>Task</code> 类，这是一个简单的包裹类，仅包含任务的 <strong>名称</strong> 和 <strong>参数列表</strong>，用于封装任务信息。</p><h2 id="2-任务处理器设计">2. 任务处理器设计</h2><p>为了让任务处理更加模块化，我设计了 <strong>任务处理器抽象基类</strong>，所有具体任务处理方法都需要继承该基类，并重写 <code>process</code> 函数，以实现具体任务的处理逻辑。</p><h2 id="3-处理器注册机制">3. 处理器注册机制</h2><p>然后实现了 <strong>处理器注册类</strong>，用于管理不同任务处理器的映射关系：</p><ul><li><strong>Key</strong>：任务名称</li><li><strong>Value</strong>：对应的任务处理器类</li></ul><p>当需要处理 <code>Task</code> 时，会从注册类中获取与 <code>Task</code> 名称对应的处理器，并传入 <code>Task</code> 进行执行。</p><p><strong>示例流程：</strong><br>如果 <code>Task</code> 是 <strong>A 类型</strong>，注册类会找到 <strong>A 处理器</strong>，然后将 <code>Task</code> 传入处理器以获取参数列表并执行。</p><h2 id="4-单元测试">4. 单元测试</h2><p>代码编写完成后，学习并使用 <strong>Google Test（GTest）</strong> 进行单元测试，以验证任务队列的正确性。</p><hr><h2 id="总结">总结</h2><ul><li><code>Task</code> 作为基础封装类，仅存储名称和参数列表。</li><li>任务处理器通过继承基类实现 <code>process</code> 方法。</li><li>处理器注册类维护任务名称到处理器的映射，实现动态调用。</li><li>使用 Google Test 进行单元测试，提高代码的可靠性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-任务封装&quot;&gt;1. 任务封装&lt;/h2&gt;
&lt;p&gt;首先实现了 &lt;code&gt;Task&lt;/code&gt; 类，这是一个简单的包裹类，仅包含任务的 &lt;strong&gt;名称&lt;/strong&gt; 和 &lt;strong&gt;参数列表&lt;/strong&gt;，用于封装任务信息。&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="C++" scheme="https://eatbreads.github.io/categories/C/"/>
    
    <category term="消息队列" scheme="https://eatbreads.github.io/categories/C/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="任务队列" scheme="https://eatbreads.github.io/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
    <category term="设计模式" scheme="https://eatbreads.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Google Test" scheme="https://eatbreads.github.io/tags/Google-Test/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 基础知识总结</title>
    <link href="https://eatbreads.github.io/posts/d00def19.html"/>
    <id>https://eatbreads.github.io/posts/d00def19.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Kafka-应用场景">1. Kafka 应用场景</h2><p>Kafka 作为一款高吞吐的分布式消息系统，适用于多种应用场景：</p><ul><li><strong>消息队列</strong>：用于解耦生产者和消费者，提高系统的伸缩性。</li><li><strong>日志收集</strong>：集中存储和处理系统日志，方便分析和监控。</li><li><strong>流计算</strong>：处理实时数据流，将数据传输给实时计算系统进行计算。</li><li><strong>事件溯源</strong>：记录事件发生的历史，以便后续回溯和分析。</li><li><strong>Metrics 采集</strong>：收集和存储系统的监控指标数据。</li></ul><hr><h2 id="2-Kafka-组件介绍">2. Kafka 组件介绍</h2><p>Kafka 由多个核心组件组成：</p><ul><li><p><strong>生产者（Producer）</strong>：负责将消息发送到 Kafka。</p></li><li><p><strong>消费者（Consumer）</strong>：从 Kafka 读取消息进行处理。</p></li><li><p><strong>消息代理（Broker）</strong>：存储和管理消息，负责接收、存储和转发数据。</p></li><li><p><strong>协调器（Zookeeper）</strong>：提供分布式协调和管理任务。</p></li><li><p><strong>主题（Topic）</strong>：类似广播频道，生产者将消息发送到指定的 <code>Topic</code>，消费者从 <code>Topic</code> 读取消息。</p><p>创建 Topic 命令示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 3 --topic my-topic</span><br></pre></td></tr></table></figure></li><li><p><strong>分区（Partition）</strong>：一个 <code>Topic</code> 进一步分为多个 <code>Partition</code>，可以提高数据局部性、支持并行处理，实现负载均衡。</p></li></ul><hr><h2 id="3-Kafka-消息有序性">3. Kafka 消息有序性</h2><p>Kafka 的消息处理方式：</p><ul><li><strong>不同分区的消息是并行处理的</strong>，因此 Kafka <strong>全局上不保证消息的有序性</strong>。</li><li><strong>同一分区内的消息是严格有序的</strong>，消费者会按照 <code>offset</code> 依次消费。</li></ul><hr><h2 id="4-Offset（偏移量）">4. Offset（偏移量）</h2><ul><li>Kafka 中的每条消息都有唯一的 <strong>Offset</strong>（偏移量），从 <code>0</code> 开始递增。</li><li>Offset 用于追踪消息消费进度，每个消费者组都会维护自己的 Offset。</li></ul><hr><h2 id="5-Consumer-Group（消费者组）">5. Consumer Group（消费者组）</h2><ul><li><p><strong>一个分区（Partition）只能由一个组员消费</strong>，保证分区数据不会被组内多个消费者重复消费。</p></li><li><p><strong>多个 Consumer Group 可以同时消费同一个 Topic</strong>，不同组之间不会相互影响。例如：</p><ul><li><code>Group A</code> 读取 <code>Topic X</code> 的消息一次。</li><li><code>Group B</code> 也可以独立读取 <code>Topic X</code> 的消息一次。</li></ul></li></ul><p>这样，每个组都可以独立处理相同的消息，实现多用途消费。</p><hr><h2 id="6-总结">6. 总结</h2><ul><li>Kafka 适用于消息队列、日志收集、流计算、事件溯源等场景。</li><li>核心组件包括 Producer、Consumer、Broker、Zookeeper、Topic、Partition 等。</li><li>消息的全局有序性无法保证，但 <strong>同一分区内是有序的</strong>。</li><li>Offset 记录消息的消费进度，每个 Consumer Group 维护自己的 Offset。</li><li>通过 Consumer Group 机制，可以控制消息的分发和重复消费。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Kafka-应用场景&quot;&gt;1. Kafka 应用场景&lt;/h2&gt;
&lt;p&gt;Kafka 作为一款高吞吐的分布式消息系统，适用于多种应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：用于解耦生产者和消费者，提高系统的伸缩性。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="分布式系统" scheme="https://eatbreads.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Kafka" scheme="https://eatbreads.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Kafka/"/>
    
    
    <category term="消息队列" scheme="https://eatbreads.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="实时流处理" scheme="https://eatbreads.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B5%81%E5%A4%84%E7%90%86/"/>
    
    <category term="大数据" scheme="https://eatbreads.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>docker一点小记录</title>
    <link href="https://eatbreads.github.io/posts/bc68fe1f.html"/>
    <id>https://eatbreads.github.io/posts/bc68fe1f.html</id>
    <published>2025-03-13T14:21:56.000Z</published>
    <updated>2025-03-21T16:02:18.702Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker 基础使用</h1><h2 id="1-Docker-组件">1. Docker 组件</h2><p>Docker 主要由以下三个核心组件组成：</p><ul><li><strong>镜像（Image）</strong>：类似于软件的 <strong>蓝图</strong>，定义了容器运行所需的环境。</li><li><strong>容器（Container）</strong>：基于镜像创建的 <strong>实例</strong>，可以运行应用。</li><li><strong>引擎（Engine）</strong>：Docker 的 <strong>核心管理组件</strong>，负责容器的创建、运行、管理等。</li></ul><hr><h2 id="2-如何构建镜像（Blueprint）">2. 如何构建镜像（Blueprint）</h2><ol><li><strong>编写 <code>Dockerfile</code></strong> 定义镜像构建过程。</li><li><strong>构建镜像</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my_image .</span><br></pre></td></tr></table></figure></li><li><strong>发布镜像</strong>：<ul><li>登录 Docker Hub：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></li><li>推送镜像：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push my_image</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>使用镜像</strong>：<ul><li>运行容器：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my_container my_image</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="使用-Docker-执行-CI-CD">使用 Docker 执行 CI/CD</h2><p>Docker 可与 <strong>Jenkins</strong>、<strong>GitHub Actions</strong> 结合使用，实现 CI/CD：</p><ul><li><strong>Jenkins</strong> + Docker：用于企业级 CI/CD 自动化部署。</li><li><strong>GitHub Actions</strong>（适用于个人小项目/免费方案）。</li></ul><hr><h2 id="3-查看容器日志">3. 查看容器日志</h2><p>使用 <code>docker logs</code> 命令查看容器日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs my_container</span><br></pre></td></tr></table></figure><p>支持多种日志模式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f my_container  <span class="comment"># 持续查看日志（实时刷新）</span></span><br><span class="line">docker logs --<span class="built_in">tail</span> 100 my_container  <span class="comment"># 查看最后100行日志</span></span><br><span class="line">docker logs --since 10m my_container  <span class="comment"># 查看最近10分钟的日志</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-Docker-数据卷（Volume）">4. Docker 数据卷（Volume）</h2><p>Docker <strong>数据卷</strong> 主要用于持久化存储数据，容器销毁时数据不会丢失。</p><h3 id="1-创建数据卷">1. 创建数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my_data</span><br></pre></td></tr></table></figure><h3 id="2-运行容器并挂载数据卷">2. 运行容器并挂载数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my_container -v my_data:/app/data nginx</span><br></pre></td></tr></table></figure><h3 id="3-多个容器共享数据卷">3. 多个容器共享数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name container1 -v my_data:/app/data nginx</span><br><span class="line">docker run -d --name container2 -v my_data:/app/data alpine</span><br></pre></td></tr></table></figure><h3 id="4-查看数据卷信息">4. 查看数据卷信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect my_data</span><br></pre></td></tr></table></figure><hr><h2 id="5-Docker-网络">5. Docker 网络</h2><p>Docker 提供多种 <strong>网络模式</strong>，用于管理容器间的通信：</p><h3 id="1-Bridge（桥接模式）">1. <strong>Bridge（桥接模式）</strong></h3><ul><li><strong>默认模式</strong>，适用于多个容器之间的通信。</li><li>在相同桥接网络的容器可以通过<strong>容器名</strong>互相访问。</li><li>创建桥接网络并将容器连接到该网络：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create my_bridge</span><br><span class="line">docker run -d --name container1 --network my_bridge_network nginx</span><br><span class="line">docker run -d --name container2 --network my_bridge</span><br></pre></td></tr></table></figure></li><li>使用 <strong>Docker Compose</strong> 可以自动创建共享网络，提供<strong>基础的服务发现功能</strong>。</li></ul><h3 id="2-Host（主机模式）">2. <strong>Host（主机模式）</strong></h3><ul><li>容器直接使用 <strong>宿主机的网络</strong>，不做隔离，具有更高的网络性能。</li></ul><h3 id="3-None（无网络）">3. <strong>None（无网络）</strong></h3><ul><li>容器没有任何网络连接，适用于需要完全隔离的环境。</li></ul><h3 id="4-Overlay-网络">4. <strong>Overlay 网络</strong></h3><ul><li>用于 <strong>Docker Swarm</strong> 集群，使多个主机上的容器可相互通信。</li></ul><h3 id="5-Macvlan-模式">5. <strong>Macvlan 模式</strong></h3><ul><li>允许容器直接与宿主机的网络通信，适用于需要独立 <strong>IP 地址</strong> 的场景。</li></ul><hr><h2 id="6-如何优化-Docker-启动时间">6. 如何优化 Docker 启动时间</h2><ol><li><strong>使用较小的基础镜像</strong>（如 <code>alpine</code> 代替 <code>ubuntu</code>）。</li><li><strong>利用构建缓存</strong>：避免每次 <code>docker build</code> 都从头开始构建。</li><li><strong>减少容器层数</strong>：使用多阶段构建来减少镜像大小。</li><li><strong>本地缓存镜像</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull my_image</span><br></pre></td></tr></table></figure></li><li><strong>优化应用启动方式</strong>：如 <strong>多阶段构建</strong>，减少不必要的运行时依赖。</li></ol><hr><h2 id="6-使用-docker-compose">6. 使用 <code>docker-compose</code></h2><p><code>docker-compose</code> 允许用 <strong>YAML 配置文件</strong> 定义多个容器，并通过一个命令启动所有容器：</p><ol><li><strong>编写 <code>docker-compose.yml</code> 文件</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>docker-compose</code> 启动容器</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="6-使用多阶段构建优化镜像体积">6. 使用多阶段构建优化镜像体积</h2><p>多阶段构建可减少最终镜像的大小：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：构建应用</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.18</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：创建更小的最终镜像</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /app/mybinary .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./mybinary&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li><strong>第一阶段</strong>：使用完整的 Golang 环境构建二进制文件。</li><li><strong>第二阶段</strong>：使用 <code>alpine</code> 作为基础镜像，仅复制最终生成的二进制文件，减少体积。</li></ul><hr><h2 id="6-Docker-Swarm（集群）">6. Docker Swarm（集群）</h2><p>Docker Swarm 是 Docker 官方提供的 <strong>轻量级容器编排工具</strong>：</p><ul><li>允许将多个 Docker 主机集合成一个<strong>虚拟</strong> Docker 主机。</li><li>适用于 <strong>轻量级的集群管理</strong>，相比 Kubernetes 更加简单易用。</li></ul><hr><h2 id="7-总结">7. 总结</h2><ul><li>Docker 提供了<strong>镜像、容器、网络</strong>等组件，简化应用的<strong>打包、分发、部署</strong>。</li><li>通过 <strong>Dockerfile</strong> 构建自定义镜像，并使用 <strong>Docker Hub</strong> 分发。</li><li>利用 <strong>Docker + CI/CD 工具</strong>（如 <strong>Jenkins</strong>、<strong>GitHub Actions</strong>），可实现自动化部署。</li><li>通过 <strong>Docker Compose</strong> 快速启动多容器应用，简化管理。</li><li>使用 <strong>多阶段构建</strong> 可 <strong>优化镜像体积</strong>，提高拉取与启动速度。</li><li><strong>优化启动时间</strong> 可以通过：<ul><li>选择较小的基础镜像。</li><li>减少不必要的层数。</li><li>使用本地缓存提高构建效率。</li></ul></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Docker 基础使用&lt;/h1&gt;
&lt;h2 id=&quot;1-Docker-组件&quot;&gt;1. Docker 组件&lt;/h2&gt;
&lt;p&gt;Docker 主要由以下三个核心组件组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;镜像（Image）&lt;/strong&gt;：类似于软件的 &lt;strong&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis八股文</title>
    <link href="https://eatbreads.github.io/posts/c74dfdcd.html"/>
    <id>https://eatbreads.github.io/posts/c74dfdcd.html</id>
    <published>2025-03-13T14:11:08.000Z</published>
    <updated>2025-03-21T16:02:18.713Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Redis 基础使用</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 进入 Redis 终端</span></span><br><span class="line">使用 <span class="code">`redis-cli`</span> 进入 Redis 交互终端。</span><br><span class="line"></span><br><span class="line"><span class="section">## Redis 支持的数据类型</span></span><br><span class="line">Redis 支持五种数据类型：</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**String**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Hash**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**List**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Set**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Sorted Set（有序集合）**</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1. String</span></span><br><span class="line"><span class="code">```sh</span></span><br><span class="line"><span class="code">set name mike</span></span><br><span class="line"><span class="code">get name</span></span><br><span class="line"><span class="code">del name</span></span><br></pre></td></tr></table></figure><h3 id="2-Hash">2. Hash</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset user name Alice</span><br><span class="line">hget user name</span><br><span class="line">hgetall user</span><br><span class="line">hdel user name</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> <code>user</code> 在这里是表名，<code>name</code> 是 key。</p></blockquote><h3 id="3-List">3. List</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lpush queue task</span><br><span class="line">rpush queue task</span><br><span class="line">lpop queue</span><br><span class="line">rpop queue</span><br><span class="line">lrange queue 0 -1</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> <code>-1</code> 表示倒数第一个，<code>lrange queue 0 -1</code> 表示遍历从 <code>0</code> 到最后一个元素。</p></blockquote><h3 id="4-Set">4. Set</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd myset a</span><br><span class="line">sadd myset b</span><br><span class="line">sadd myset c</span><br><span class="line">smembers myset</span><br><span class="line">srem myset a</span><br></pre></td></tr></table></figure><h3 id="5-Sorted-Set">5. Sorted Set</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zadd scores 100 Alice</span><br><span class="line">zadd scores 200 Bob</span><br><span class="line">zrange scores 0 -1 withscores</span><br><span class="line">zrevrange scores 0 -1 withscores</span><br><span class="line">zrem scores Alice</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> 有序集合插入时需要提供权重值，<code>withscores</code> 表示按照权重遍历。</p></blockquote><hr><h2 id="配置文件位置">配置文件位置</h2><ul><li>配置文件路径：<code>/etc/redis/redis.conf</code></li><li>修改配置后需要重启 Redis：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart redis</span><br></pre></td></tr></table></figure></li><li>该配置文件可用于编辑 <strong>持久化</strong> 设置。</li></ul><hr><h2 id="Redis-持久化">Redis 持久化</h2><h3 id="1-RDB-快照持久化（保存数据到磁盘）">1. RDB 快照持久化（保存数据到磁盘）</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1   <span class="comment"># 900 秒（15 分钟）至少有 1 次写入操作，就保存 RDB</span></span><br><span class="line">save 300 10  <span class="comment"># 300 秒（5 分钟）至少有 10 次写入操作，就保存 RDB</span></span><br><span class="line">save 60 10000 <span class="comment"># 60 秒内有 10000 次写入操作，就保存 RDB</span></span><br></pre></td></tr></table></figure><h3 id="2-AOF-日志持久化">2. AOF 日志持久化</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span>   <span class="comment"># 启用 AOF</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>  <span class="comment"># AOF 文件名</span></span><br></pre></td></tr></table></figure><hr><h2 id="Redis-使用场景">Redis 使用场景</h2><ol><li><p><strong>缓存</strong></p><ul><li>存储常用数据，如页面渲染等。</li></ul></li><li><p><strong>实时系统</strong></p><ul><li>统计网站点击率、实时排行榜、点赞功能等。</li></ul></li><li><p><strong>消息队列</strong></p><ul><li>使用 <code>List</code> 和 <code>Pub/Sub</code> 可实现轻量级消息队列。</li></ul></li><li><p><strong>分布式锁</strong></p><ul><li>本质上与消息队列功能类似，可用于分布式环境下的锁管理。</li></ul></li><li><p><strong>计数器</strong></p><ul><li>Redis 具有原子操作能力，适合作为计数器，例如在线人数统计等。</li></ul></li></ol><hr><h2 id="Redis-为什么这么快？">Redis 为什么这么快？</h2><ol><li><strong>数据存储在内存</strong>（而非磁盘）。</li><li><strong>使用高效的数据结构</strong> 进行数据存储和查找。</li><li><strong>单线程 + I/O 多路复用</strong>，避免了多线程的上下文切换，提高性能。</li></ol><hr><h2 id="为什么-Redis-采用单线程？">为什么 Redis 采用单线程？</h2><ul><li>Redis 的瓶颈不在 <strong>CPU</strong>，而在 <strong>网络 I/O 和键值对操作</strong>，因此使用单线程处理请求。</li><li>持久化等操作由后台线程完成，并不会影响主线程的处理性能。</li></ul><hr><h2 id="Redis-跳表实现">Redis 跳表实现</h2><p>（略）</p><hr><h2 id="Redis-和-Memcached-的区别">Redis 和 Memcached 的区别</h2><table><thead><tr><th>特性</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>数据类型</td><td>丰富（String、Hash、List、Set、Sorted Set）</td><td>仅支持键值对（K-V）</td></tr><tr><td>持久化</td><td>支持（RDB、AOF）</td><td>不支持</td></tr><tr><td>事务</td><td>支持（但不支持回滚）</td><td>不支持</td></tr><tr><td>内存占用</td><td>较高</td><td>较低</td></tr><tr><td>速度</td><td>快</td><td>更快</td></tr><tr><td>使用场景</td><td>多种（缓存、队列、分布式锁等）</td><td>主要用于缓存</td></tr></tbody></table><hr><h2 id="Redis-事务-vs-MySQL-事务">Redis 事务 vs MySQL 事务</h2><ul><li>Redis 事务本质上是 <strong>多个命令的原子性执行</strong>，执行期间不会被打断。</li><li>但 Redis <strong>不支持事务回滚</strong>，一旦执行，无法撤销。</li></ul><hr><blockquote><p><strong>PS:</strong> <code>-1</code> 表示倒数第一个，范围遍历 <code>0</code> 到最后一个元素。<br><strong>PS:</strong> <code>user</code> 在这里是表名，<code>name</code> 是 key。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux一些好用的操作</title>
    <link href="https://eatbreads.github.io/posts/83cfdf8d.html"/>
    <id>https://eatbreads.github.io/posts/83cfdf8d.html</id>
    <published>2025-03-09T15:43:14.000Z</published>
    <updated>2025-03-21T16:02:18.704Z</updated>
    
    <content type="html"><![CDATA[<p>以下是你的内容转换为 <strong>Markdown</strong> 格式的文档：</p><h1>Linux 知识整理</h1><h2 id="软硬链接的区别">软硬链接的区别</h2><h3 id="硬链接">硬链接</h3><p>硬链接更像是创建出了 <code>shared_ptr</code> 智能指针，原链接和硬链接都变成智能指针，删除其中一个不会使得文件失效。但是：</p><ul><li><strong>不能跨文件系统</strong></li><li><strong>不能链接目录</strong></li></ul><p><strong>创建硬链接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> file.txt file_link.txt</span><br></pre></td></tr></table></figure><h3 id="软链接">软链接</h3><p>软链接就像是原来文件的引用，删除原文件就会导致变成空悬链接（Dangling Link）。</p><p><strong>创建软链接：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s file.txt file_link.txt</span><br></pre></td></tr></table></figure><hr><h2 id="使用-crontab">使用 <code>crontab</code></h2><p><code>crontab</code> 可用于定时执行任务，常见操作如下：</p><hr><h2 id="查看某个进程的使用情况">查看某个进程的使用情况</h2><h3 id="使用-ps-命令"><strong>使用 <code>ps</code> 命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p 1234 -o %mem,%cpu,vsz,rss</span><br></pre></td></tr></table></figure><ul><li><code>%mem</code>：查看进程使用的内存占比</li><li><code>%cpu</code>：查看进程占用的 CPU</li><li><code>vsz</code>：查看虚拟内存大小</li><li><code>rss</code>：查看常驻内存大小</li></ul><h3 id="使用-top-命令"><strong>使用 <code>top</code> 命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 1234</span><br></pre></td></tr></table></figure><ul><li><code>PR</code>：进程优先级</li><li><code>NI</code>：进程 Nice 值</li><li><code>VIRT</code>：虚拟内存总量</li><li><code>RES</code>：物理内存</li><li><code>SHR</code>：共享内存</li><li><code>S</code>：进程状态</li><li><code>COMMAND</code>：执行的具体命令</li></ul><hr><h2 id="改变用户权限">改变用户权限</h2><p>使用 <code>chmod</code> 命令修改文件权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 /project/hello.sh</span><br></pre></td></tr></table></figure><ul><li><strong>第一个数字（7）</strong>：文件所有者（可读、可写、可执行）</li><li><strong>第二个数字（5）</strong>：同组用户（可读、可执行）</li><li><strong>第三个数字（5）</strong>：其他用户（可读、可执行）</li></ul><hr><h2 id="查找某个目录下包含特定字符串的文件">查找某个目录下包含特定字符串的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rl <span class="string">&quot;特定字符串&quot;</span> /path/to/directory</span><br></pre></td></tr></table></figure><ul><li><code>-r</code>：递归查找</li><li><code>-l</code>：仅显示包含该字符串的文件名</li></ul><hr><h2 id="Linux-和-Windows-的虚拟内存机制">Linux 和 Windows 的虚拟内存机制</h2><ul><li><strong>Windows</strong>：主要使用 <strong>分页 + 分段</strong> 机制</li><li><strong>Linux</strong>：基本只使用 <strong>分页</strong> 机制</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下是你的内容转换为 &lt;strong&gt;Markdown&lt;/strong&gt; 格式的文档：&lt;/p&gt;
&lt;h1&gt;Linux 知识整理&lt;/h1&gt;
&lt;h2 id=&quot;软硬链接的区别&quot;&gt;软硬链接的区别&lt;/h2&gt;
&lt;h3 id=&quot;硬链接&quot;&gt;硬链接&lt;/h3&gt;
&lt;p&gt;硬链接更像是创建出了 &lt;co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL 进阶与架构优化</title>
    <link href="https://eatbreads.github.io/posts/7d06a385.html"/>
    <id>https://eatbreads.github.io/posts/7d06a385.html</id>
    <published>2025-03-07T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-事务与锁">MySQL 事务与锁</h2><h3 id="锁的类型">锁的类型</h3><ul><li><strong>行级锁</strong>：锁住一行数据，提高并发能力。</li><li><strong>表级锁</strong>：锁住整个表，适用于大批量操作。</li><li><strong>意向锁</strong>：表级别的标记，用于加速行锁检测。</li><li><strong>乐观锁</strong>：不加锁，依赖版本号控制并发更新。</li><li><strong>悲观锁</strong>：先锁后操作，适用于高并发竞争场景。</li></ul><h3 id="死锁的处理">死锁的处理</h3><ol><li><strong>MySQL 死锁检测</strong>：自动回滚代价最小的事务。</li><li><strong>手动 <code>KILL</code> 事务</strong>：手动终止长时间阻塞事务。</li><li><strong>优化索引与 SQL 语句</strong>：减少锁冲突，降低死锁概率。</li></ol><h2 id="MySQL-读写分离与主从同步">MySQL 读写分离与主从同步</h2><ul><li><strong>主从架构</strong>：主库处理写操作，从库处理读操作。</li><li><strong>Binlog 实现主从同步</strong>：<ol><li>主库记录 Binlog。</li><li>从库读取 Binlog 并重放。</li></ol></li><li><strong>避免主从同步延迟</strong>：<ul><li>关键业务查询主库。</li><li>二次查询策略（从库查不到再查主库）。</li></ul></li></ul><h2 id="分库分表策略">分库分表策略</h2><h3 id="水平拆分"><strong>水平拆分</strong></h3><ul><li><strong>水平分表</strong>：将一张大表拆成多张小表（如 <code>users_0</code>, <code>users_1</code>）。</li><li><strong>水平分库</strong>：多个数据库存相同结构的表，降低单库压力。</li></ul><h3 id="垂直拆分"><strong>垂直拆分</strong></h3><ul><li><strong>垂直分表</strong>：将一张表的不同字段拆成多张表（如 <code>user_base</code> 和 <code>user_detail</code>）。</li><li><strong>垂直分库</strong>：不同业务数据存入不同数据库（如 <code>order_db</code> 和 <code>user_db</code>）。</li></ul><h3 id="分库分表的挑战"><strong>分库分表的挑战</strong></h3><ul><li><strong>跨库 JOIN 受限</strong>：需改为应用层查询或使用中间件（如 ShardingSphere）。</li><li><strong>事务一致性问题</strong>：需要分布式事务方案（如 TCC、最终一致性）。</li></ul><h2 id="MySQL-高可用架构">MySQL 高可用架构</h2><h3 id="避免单点故障"><strong>避免单点故障</strong></h3><ul><li><strong>主从复制</strong>：单主多从架构，保证数据可用性。</li><li><strong>MHA（MySQL High Availability）</strong>：自动故障切换，支持主从切换。</li><li><strong>PXC（Percona XtraDB Cluster）</strong>：多主集群，保证高可用。</li></ul><h3 id="不停机数据迁移"><strong>不停机数据迁移</strong></h3><ol><li><strong>双写方案</strong><ul><li>代码层面双写：新旧库同步写入。</li><li>业务低峰期停主从同步，开启双写。</li><li>逐步灰度切流，保证数据一致。</li></ul></li><li><strong>Flink CDC 方案</strong><ul><li>监听 Binlog 变更，实时同步数据。</li></ul></li></ol><h2 id="MySQL-存储与性能优化">MySQL 存储与性能优化</h2><h3 id="WAL（Write-Ahead-Logging）"><strong>WAL（Write-Ahead Logging）</strong></h3><ul><li><strong>先写日志再写数据</strong>，确保数据持久化。</li><li><strong>降低磁盘 IO</strong>，提高事务吞吐量。</li></ul><h3 id="Doublewrite-Buffer"><strong>Doublewrite Buffer</strong></h3><ul><li><strong>防止数据写入失败</strong>，避免数据损坏。</li></ul><h3 id="MySQL-缓存优化"><strong>MySQL 缓存优化</strong></h3><ul><li><strong>Buffer Pool</strong>：缓存常用数据，减少磁盘 IO。</li><li><strong>Query Cache（已废弃）</strong>：缓存查询结果，减少 SQL 解析时间。</li></ul><h2 id="MySQL-其他高级特性">MySQL 其他高级特性</h2><h3 id="存在性查询：EXISTS-vs-IN"><strong>存在性查询：EXISTS vs. IN</strong></h3><ul><li><strong>EXISTS</strong>：适用于大数据集合，只关心是否存在。</li><li><strong>IN</strong>：适用于小数据集合，直接匹配筛选。</li></ul><h3 id="存储过程"><strong>存储过程</strong></h3><ul><li><strong>优点</strong>：封装逻辑，提高性能。</li><li><strong>缺点</strong>：<ul><li>可移植性差，不同数据库的 SQL 语法可能不兼容。</li><li>调试困难，不利于代码管理（阿里开发手册不推荐）。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL-事务与锁&quot;&gt;MySQL 事务与锁&lt;/h2&gt;
&lt;h3 id=&quot;锁的类型&quot;&gt;锁的类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;行级锁&lt;/strong&gt;：锁住一行数据，提高并发能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表级锁&lt;/strong&gt;：锁住整个表</summary>
      
    
    
    
    <category term="数据库" scheme="https://eatbreads.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://eatbreads.github.io/tags/MySQL/"/>
    
    <category term="数据库" scheme="https://eatbreads.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="优化" scheme="https://eatbreads.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 核心知识点整理</title>
    <link href="https://eatbreads.github.io/posts/cdec3315.html"/>
    <id>https://eatbreads.github.io/posts/cdec3315.html</id>
    <published>2025-03-07T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-数据排序">MySQL 数据排序</h2><p>MySQL 的数据排序主要有两种方式：</p><ul><li><strong>有索引</strong>：直接按照索引排序。</li><li><strong>无索引</strong>：采用文件排序。<ul><li><strong>数据量少</strong>：内存排序，使用单路或双路排序（类似于用一只手或两只手抓数据）。</li><li><strong>数据量大</strong>：磁盘排序，通常采用归并排序。</li></ul></li></ul><h2 id="SQL-语句的执行顺序">SQL 语句的执行顺序</h2><ol><li>连接器校验权限。</li><li>分析器解析 SQL 语法，构建解析树。</li><li>优化器选择合适的索引和表连接顺序，生成多个执行计划，选择成本最低的执行。</li><li>执行器调用存储引擎查询数据并返回。</li></ol><h2 id="MySQL-的存储引擎">MySQL 的存储引擎</h2><ul><li><strong>InnoDB</strong>：支持事务、行级锁、外键，默认存储引擎。</li><li><strong>MyISAM</strong>：不支持事务，读取性能高，适合查询密集型业务。</li></ul><h2 id="MySQL-索引类型">MySQL 索引类型</h2><ul><li><strong>普通索引（辅助索引）</strong>：提升查询效率，但不保证唯一性。</li><li><strong>主键索引（聚簇索引）</strong>：数据存储在 B+ 树叶子节点，查询效率高。</li><li><strong>唯一索引</strong>：确保字段值唯一，查询速度快。</li><li><strong>联合索引</strong>：多个字段组合建立索引，遵循最左前缀匹配原则。</li><li><strong>全文索引</strong>：适用于长文本的模糊查询。</li><li><strong>空间索引</strong>：存储地理位置信息，如经纬度。</li></ul><h2 id="MySQL-事务">MySQL 事务</h2><h3 id="事务的实现">事务的实现</h3><ol><li><strong>锁</strong>：确保数据一致性，避免并发冲突。</li><li><strong>undo log</strong>：记录事务前的数据，回滚时使用。</li><li><strong>redo log</strong>：记录已提交事务的修改，崩溃后可恢复。</li><li><strong>MVCC（多版本并发控制）</strong>：允许事务读取快照数据，提高并发性能。</li></ol><h3 id="事务的隔离级别">事务的隔离级别</h3><table><thead><tr><th>隔离级别</th><th>说明</th><th>可能问题</th></tr></thead><tbody><tr><td>读未提交</td><td>可以读到未提交数据</td><td>脏读</td></tr><tr><td>读已提交</td><td>只能读到已提交数据</td><td>不可重复读</td></tr><tr><td>可重复读</td><td>事务中多次查询数据不变</td><td>幻读</td></tr><tr><td>串行化</td><td>事务串行执行</td><td>影响性能</td></tr></tbody></table><h3 id="二阶段提交（2PC）">二阶段提交（2PC）</h3><ol><li><strong>准备阶段</strong>：协调者通知参与者执行事务，所有参与者先写入日志但不提交。</li><li><strong>提交阶段</strong>：所有参与者都准备好后，协调者通知提交，否则回滚。</li></ol><h2 id="MySQL-常见优化">MySQL 常见优化</h2><ul><li><strong>使用索引</strong>：避免无索引字段排序，尽量使用覆盖索引。</li><li><strong>避免使用 <code>LIKE %XXX%</code></strong>：会导致全表扫描。</li><li><strong>EXPLAIN 分析执行计划</strong>：查看是否走索引、是否全表扫描。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL-数据排序&quot;&gt;MySQL 数据排序&lt;/h2&gt;
&lt;p&gt;MySQL 的数据排序主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有索引&lt;/strong&gt;：直接按照索引排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无索引&lt;/strong&gt;：采用文件排序。</summary>
      
    
    
    
    <category term="数据库" scheme="https://eatbreads.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://eatbreads.github.io/tags/MySQL/"/>
    
    <category term="数据库" scheme="https://eatbreads.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>opengl加入摄像机移动</title>
    <link href="https://eatbreads.github.io/posts/5da58852.html"/>
    <id>https://eatbreads.github.io/posts/5da58852.html</id>
    <published>2025-03-05T15:39:37.000Z</published>
    <updated>2025-03-21T16:02:18.709Z</updated>
    
    <content type="html"><![CDATA[<h1>摄像头移动</h1><h2 id="基本原理"><strong>基本原理</strong></h2><ul><li>通过 <code>lookAt</code> 函数实现：<ul><li>传入 <strong>摄像机位置</strong></li><li>传入 <strong>物体位置</strong></li><li>传入 <strong>向上的分量</strong></li></ul></li><li><code>lookAt(cameraPos, targetPos, upVector)</code></li></ul><h2 id="键盘控制"><strong>键盘控制</strong></h2><ul><li><strong>注册键盘按压事件</strong></li><li><strong>支持多键同时移动</strong>（如同时向左和前）<ol><li>使用 <strong>集合（Set）</strong> 存储 <strong>当前按下的按键</strong></li><li>通过 <strong>定时器</strong> 定期对 <code>Set</code> 内的按键执行移动逻辑</li></ol></li></ul><p><img src="https://cdn-a.markji.com/files/67c87060f430f61a43a126d1_hd.png?e=1741191808698&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RDaxVaynSFpDnFf5nJHzoXdsUjI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c87068344183dd508c2aba_hd.png?e=1741191816778&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:nzQhHOfQwQfElAjp9u6ysj0InLE=" alt="图片1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;摄像头移动&lt;/h1&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;strong&gt;基本原理&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过 &lt;code&gt;lookAt&lt;/code&gt; 函数实现：
&lt;ul&gt;
&lt;li&gt;传入 &lt;strong&gt;摄像机位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;传入</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>整理的一点网络方面的八股文</title>
    <link href="https://eatbreads.github.io/posts/1b342089.html"/>
    <id>https://eatbreads.github.io/posts/1b342089.html</id>
    <published>2025-03-05T15:36:25.000Z</published>
    <updated>2025-03-21T16:02:18.726Z</updated>
    
    <content type="html"><![CDATA[<h1>网络(自行整理,交由大模型写成markdown)</h1><h2 id="TCP-的粘包和拆包">TCP 的粘包和拆包</h2><ul><li><strong>粘包</strong>：多个数据包在接收时合并成一个包</li><li><strong>拆包</strong>：一个数据包被分成多个包接收</li><li><strong>原因</strong>：<ul><li>TCP 是面向字节流的协议，不关心数据边界，发送方可以随意发送</li><li>拆包是因为网络传输有 MTU（最大传输单元），不能一次发送太大的包</li></ul></li><li><strong>解决办法</strong>：<ol><li>使用 <strong>定长消息</strong>（双方固定读取）</li><li>添加 <strong>消息分隔符</strong>（双方约定好）</li><li>使用 <strong>消息头</strong>（标明包的长度）</li></ol></li></ul><h2 id="三次握手">三次握手</h2><ol><li>发起方发送 <code>SYN</code></li><li>服务器回复 <code>SYN + ACK</code></li><li>发起方回复 <code>ACK</code></li></ol><h3 id="TCP-初始序列号-ISN-如何取值？">TCP 初始序列号 ISN 如何取值？</h3><ul><li>以 <strong>时间戳</strong> 为基础生成，超过 <code>2^32</code> 会回到 0</li><li>加入一些 <strong>随机值</strong> 防止被猜到</li></ul><h3 id="TCP-三次握手时，客户端发送-SYN-之后宕机了会怎样？">TCP 三次握手时，客户端发送 <code>SYN</code> 之后宕机了会怎样？</h3><ul><li>服务器会正常发送 <code>SYN + ACK</code>，但对方无响应</li><li>服务器会 <strong>重试多次</strong>，若仍无回复则 <strong>主动断开</strong></li><li><strong>重试次数</strong> 由 <code>tcp_synack_retries</code> 参数决定</li></ul><h2 id="SYN-Flood-DDoS-攻击">SYN Flood / DDoS 攻击</h2><ul><li><strong>攻击方式</strong>：客户端不断发送 <code>SYN</code>（第一次握手），但不进行第三次握手，导致服务器资源耗尽</li><li><strong>防御方法</strong>：<ol><li><strong>SYN Cookie</strong>：要求客户端在第三次握手时带上 <code>cookie</code></li><li><strong>增加 SYN 队列</strong> 或 <strong>缩短超时时间</strong></li></ol></li></ul><h2 id="四次挥手">四次挥手</h2><ol><li>客户端 <code>FIN</code> → 进入 <code>FIN_WAIT_1</code></li><li>服务器 <code>ACK</code> → 进入 <code>CLOSE_WAIT</code></li><li>服务器 <code>FIN</code> → 进入 <code>LAST_ACK</code></li><li>客户端 <code>ACK</code> → 进入 <code>TIME_WAIT</code>，服务器 <code>CLOSE</code></li></ol><h3 id="为什么需要四次挥手？">为什么需要四次挥手？</h3><ul><li>类似打电话，要两对 <code>ACK + FIN</code> 确保数据完整</li><li><strong>不一定是四次</strong>：服务器可以在 <code>ACK</code> 时同时 <code>FIN</code></li></ul><h3 id="TIME-WAIT-作用"><code>TIME_WAIT</code> 作用</h3><ul><li><strong>确保服务器收到最后的 <code>ACK</code></strong></li><li><strong>防止端口复用时收到过期数据</strong></li><li><strong>2MSL</strong>：等待两倍的最大生存时间 <code>MSL</code>（Linux 默认 <code>MSL=30s</code>，所以 <code>2MSL=1min</code>）</li></ul><h3 id="其他断开方式">其他断开方式</h3><ul><li><strong>RST（Reset）报文</strong>：异常情况下立即断开（如主机崩溃）</li><li><strong>超时断开（Timeout）</strong>：连接长时间无数据传输</li></ul><h2 id="超时重传机制">超时重传机制</h2><ul><li>类似打电话没人回应，就再重复一遍</li></ul><h2 id="SACK（选择性确认）">SACK（选择性确认）</h2><ul><li>告诉发送方自己<strong>接收到的数据块</strong></li><li>发送方只需<strong>重传丢失的部分</strong></li></ul><h2 id="滑动窗口的作用">滑动窗口的作用</h2><ul><li><strong>协调发送方和接收方速率</strong>（一般等于接收缓冲区大小）</li><li><strong>提高吞吐量</strong>（允许一次发送多个包）</li></ul><h2 id="拥塞控制">拥塞控制</h2><h3 id="1-慢启动">1. <strong>慢启动</strong></h3><ul><li>一开始 <strong>小量发送</strong>，若成功则 <strong>指数增长</strong></li><li>直到 <strong>丢包</strong> 或 <strong>达到慢启动阈值</strong></li></ul><h3 id="2-拥塞避免">2. <strong>拥塞避免</strong></h3><ul><li>慢启动是<strong>指数增长</strong>，进入拥塞避免后<strong>线性增长</strong></li></ul><h3 id="3-快速重传">3. <strong>快速重传</strong></h3><ul><li>发送 10 个包，9 个 <code>ACK</code> 回来了 → 直接重传丢失的（只需 3 个重复 <code>ACK</code>）</li></ul><h3 id="4-快速恢复">4. <strong>快速恢复</strong></h3><ul><li>发生 <strong>快速重传</strong> 后，将窗口 <strong>砍半</strong></li><li><strong>慢启动阈值</strong> 设为新窗口大小（进入<strong>拥塞避免</strong>）</li></ul><h3 id="滑动窗口-vs-拥塞窗口"><strong>滑动窗口 vs 拥塞窗口</strong></h3><table><thead><tr><th></th><th>作用</th></tr></thead><tbody><tr><td><strong>滑动窗口</strong></td><td>接收方信箱大小（控制接受能力）</td></tr><tr><td><strong>拥塞窗口</strong></td><td>送货公司送货能力（控制发送速度）</td></tr></tbody></table><h2 id="ARP-和-RARP">ARP 和 RARP</h2><ul><li><strong>ARP（Address Resolution Protocol）</strong>：IP → MAC</li><li><strong>RARP（Reverse ARP）</strong>：MAC → IP</li></ul><h2 id="四层-七层模型">四层 &amp; 七层模型</h2><h3 id="四层模型"><strong>四层模型</strong></h3><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><h3 id="七层模型"><strong>七层模型</strong></h3><ol><li>物理层</li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ol><h2 id="Cookie-vs-Token-vs-Session">Cookie vs Token vs Session</h2><table><thead><tr><th></th><th><strong>Cookie</strong></th><th><strong>Session</strong></th><th><strong>Token</strong></th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>客户端</td><td>服务器</td><td>客户端（无状态）</td></tr><tr><td><strong>存储内容</strong></td><td>小型数据文件</td><td>用户数据</td><td>认证信息</td></tr><tr><td><strong>工作方式</strong></td><td>浏览器带上 <code>Cookie</code> 认证</td><td>客户端只存 <code>SessionID</code></td><td>无需数据库查询，直接校验</td></tr><tr><td><strong>示例</strong></td><td>购物车</td><td>登录状态</td><td>JWT（JSON Web Token）</td></tr></tbody></table><h2 id="DNS（域名解析系统）">DNS（域名解析系统）</h2><ul><li><strong>Domain Name System</strong></li><li><strong>解析域名</strong> → <strong>IP 地址</strong></li><li><strong>负载均衡</strong>：同一域名可以解析多个 IP</li></ul><h2 id="CDN（内容分发网络）">CDN（内容分发网络）</h2><ul><li><strong>缓存服务器</strong> 分布多个地点</li><li>用户请求时选择<strong>最近的缓存站</strong></li><li>适用于 <strong>静态资源</strong>（图片、CSS、JS）</li></ul><h2 id="用户输入网址到网页显示全过程">用户输入网址到网页显示全过程</h2><ol><li><strong>解析 URL</strong> 生成 <strong>HTTP 请求</strong></li><li><strong>DNS 解析</strong>：域名 → IP</li><li><strong>TCP 三次握手</strong></li><li><strong>封装 TCP 数据包</strong></li><li><strong>封装 IP、MAC 数据包</strong></li><li><strong>网卡</strong> 转换成 <strong>电信号</strong> 通过 <strong>网线传输</strong></li><li><strong>交换机 → 路由器 → 服务器</strong></li><li>服务器处理请求，返回数据</li><li>浏览器解析并渲染页面</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;网络(自行整理,交由大模型写成markdown)&lt;/h1&gt;
&lt;h2 id=&quot;TCP-的粘包和拆包&quot;&gt;TCP 的粘包和拆包&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;粘包&lt;/strong&gt;：多个数据包在接收时合并成一个包&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆包&lt;/stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>加入旋转</title>
    <link href="https://eatbreads.github.io/posts/5985ea05.html"/>
    <id>https://eatbreads.github.io/posts/5985ea05.html</id>
    <published>2025-03-04T13:29:26.000Z</published>
    <updated>2025-03-21T16:02:18.732Z</updated>
    
    <content type="html"><![CDATA[<h1>纹理映射与旋转</h1><h2 id="1-纹理映射">1. 纹理映射</h2><p>在 OpenGL 中，可以使用 <code>sampler2D</code> 进行 2D 纹理采样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D ourTexture;</span><br></pre></td></tr></table></figure><blockquote><p>该变量用于在片元着色器中获取 2D 纹理的像素值。</p></blockquote><hr><h2 id="2-加入纹理过滤与旋转">2. 加入纹理过滤与旋转</h2><h3 id="步骤-1：转换为立方体"><strong>步骤 1：转换为立方体</strong></h3><ul><li><strong>矩形 -&gt; 立方体</strong>：原始矩形的顶点坐标扩展为 24 个顶点，以适应立方体的六个面。</li><li>每个面使用四个顶点，并绑定对应的纹理坐标。</li></ul><p>示例顶点数据（包含位置和纹理坐标）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置                // 纹理坐标</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="comment">// 其余五个面省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="步骤-2：应用纹理过滤"><strong>步骤 2：应用纹理过滤</strong></h3><p>为了提升渲染质量，可以使用 <strong>线性过滤</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><blockquote><p>这样，在放大或缩小时，纹理会进行平滑过渡，避免像素化。</p></blockquote><hr><h3 id="步骤-3：添加旋转"><strong>步骤 3：添加旋转</strong></h3><p>使用 <code>glm::rotate</code> 在片元着色器中动态旋转：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = glm::<span class="built_in">rotate</span>(model, (GLfloat)<span class="built_in">glfwGetTime</span>() * glm::<span class="built_in">radians</span>(<span class="number">50.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><blockquote><p>这里 <code>glfwGetTime()</code> 让物体随着时间旋转，旋转轴为 <code>(0.5, 1.0, 0.0)</code>。</p></blockquote><hr><p><img src="https://cdn-a.markji.com/files/67c70085684ac25add60662b_hd.png?e=1741097637264&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:C2_F2MO3wuBkT_xbflb-pLwYuCE=" alt="图片1"><br>这样，我们就成功将纹理映射应用到了立方体，并添加了旋转效果！🚀</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;纹理映射与旋转&lt;/h1&gt;
&lt;h2 id=&quot;1-纹理映射&quot;&gt;1. 纹理映射&lt;/h2&gt;
&lt;p&gt;在 OpenGL 中，可以使用 &lt;code&gt;sampler2D&lt;/code&gt; 进行 2D 纹理采样：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于opengl使用的小心得</title>
    <link href="https://eatbreads.github.io/posts/a608763a.html"/>
    <id>https://eatbreads.github.io/posts/a608763a.html</id>
    <published>2025-03-04T13:20:29.000Z</published>
    <updated>2025-03-21T16:02:18.718Z</updated>
    
    <content type="html"><![CDATA[<h1>OpenGL 基础概念</h1><h2 id="VBO（数组缓冲对象）">VBO（数组缓冲对象）</h2><ul><li>用于存储顶点数据，如位置、颜色、法线、纹理坐标等。</li><li>作用是直接把数组存到 GPU 的缓存中，提高渲染效率。</li></ul><h2 id="IBO-EBO（索引缓冲对象）">IBO/EBO（索引缓冲对象）</h2><ul><li>用于存储索引数据，避免重复存储相同的顶点数据，提高渲染效率。</li><li>需要使用 <code>create</code> / <code>bind</code> / <code>allocate</code> 进行管理。</li></ul><h2 id="VAO（顶点数组对象）">VAO（顶点数组对象）</h2><ul><li>作为管理者，记录 VBO 和 IBO 的绑定状态。</li><li>不需要在每次绘制时重新设置，可在不同 VAO 之间切换，以便绘制不同的对象。</li><li>只有 <code>create</code> 和 <code>bind</code> 操作（用于成为管理者）。</li></ul><h2 id="顶点属性指针">顶点属性指针</h2><ul><li>用于告诉 OpenGL 顶点数据的格式，包括：<ul><li>每个顶点有多少数据（如每个顶点包含多少个属性）。</li><li>每个属性占用多少个 <code>GLFloat</code>。</li><li>该属性在 VBO 中的位置。</li></ul></li></ul><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shaderProgram.<span class="built_in">enableAttributeArray</span>(<span class="number">0</span>); <span class="comment">// 启用顶点位置属性，对应顶点着色器中的 layout (location = 0)</span></span><br><span class="line">shaderProgram.<span class="built_in">setAttributeBuffer</span>(<span class="number">0</span>, GL_FLOAT, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span> * <span class="built_in">sizeof</span>(GLfloat));</span><br><span class="line"><span class="comment">// 参数解析：</span></span><br><span class="line"><span class="comment">//  - 0：属性索引，对应顶点着色器中的 `layout (location = 0)`</span></span><br><span class="line"><span class="comment">//  - GL_FLOAT：数据类型</span></span><br><span class="line"><span class="comment">//  - 0：从 VBO 开始解析</span></span><br><span class="line"><span class="comment">//  - 3：一次解析 3 个值（x, y, z）</span></span><br><span class="line"><span class="comment">//  - 6 * sizeof(GLfloat)：步长（Stride），即每个顶点的总数据大小</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：这两句话相当于定义了两个指针，告诉着色器如何解析顶点数组。</p></blockquote><h3 id="OpenGL-着色器绑定规则">OpenGL 着色器绑定规则</h3><ul><li>OpenGL <strong>只能同时使用一个着色器程序</strong>，使用时需要 <code>bind</code> 绑定某个着色器。</li><li><strong>VAO 也是同理</strong>，可以创建多个 VAO 来存储不同的对象（如矩形和三角形），但<strong>不能同时使用</strong>，需要绘制不同对象时，需重新 <code>bind</code> 另一个 VAO。</li></ul><hr><h2 id="纹理映射">纹理映射</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D ourTexture;</span><br></pre></td></tr></table></figure><blockquote><p>用于获取 2D 纹理的像素值。</p></blockquote><hr><h2 id="纹理过滤与旋转">纹理过滤与旋转</h2><ul><li>将矩形扩展为立方体，并增加顶点坐标至 24 个，以支持 3D 纹理映射和旋转。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立方体顶点数据（包含纹理坐标）</span></span><br><span class="line">GLfloat vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置           // 纹理坐标</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="comment">// 其余五个面省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转矩阵（在片元着色器中应用）</span></span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, (GLfloat)<span class="built_in">glfwGetTime</span>() * glm::<span class="built_in">radians</span>(<span class="number">50.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>glfwGetTime()</code> 实现动态旋转。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;OpenGL 基础概念&lt;/h1&gt;
&lt;h2 id=&quot;VBO（数组缓冲对象）&quot;&gt;VBO（数组缓冲对象）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用于存储顶点数据，如位置、颜色、法线、纹理坐标等。&lt;/li&gt;
&lt;li&gt;作用是直接把数组存到 GPU 的缓存中，提高渲染效率。&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用vcxxrv来配合wsl做图形化界面</title>
    <link href="https://eatbreads.github.io/posts/728f80ac.html"/>
    <id>https://eatbreads.github.io/posts/728f80ac.html</id>
    <published>2025-03-03T13:09:36.000Z</published>
    <updated>2025-03-21T16:02:18.717Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 使用 VcXsrv 给 WSL2 连接图形界面</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 下载 VcXsrv  </span></span><br><span class="line">首先，从官网下载安装 VcXsrv：  </span><br><span class="line">[<span class="string">https://sourceforge.net/projects/vcxsrv/</span>](<span class="link">https://sourceforge.net/projects/vcxsrv/</span>)  </span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 更换源  </span></span><br><span class="line">执行以下命令更换源：</span><br><span class="line"><span class="code">```bash</span></span><br><span class="line"><span class="code">wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py</span></span><br><span class="line"><span class="code">sudo python3 oh-my-tuna.py --global</span></span><br><span class="line"><span class="code">sudo apt-get update</span></span><br><span class="line"><span class="code">sudo apt-get upgrade</span></span><br></pre></td></tr></table></figure><h2 id="3-安装所需软件">3. 安装所需软件</h2><p>安装 <code>xfce4-terminal</code> 和 <code>xfce4</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install xfce4-terminal</span><br><span class="line"><span class="built_in">sudo</span> apt-get install xfce4</span><br></pre></td></tr></table></figure><p>重启 <code>dbus</code> 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service dbus restart</span><br></pre></td></tr></table></figure><h2 id="4-配置环境变量">4. 配置环境变量</h2><p>编辑 <code>~/.bashrc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加以下内容（请将 <code>172.27.46.105</code> 替换为实际的 Windows IP 地址）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=172.27.46.105:0.0  <span class="comment"># 替换为你的 Windows IP 地址</span></span><br><span class="line"><span class="built_in">export</span> WAYLAND_DISPLAY=<span class="variable">$DISPLAY</span></span><br><span class="line"><span class="built_in">export</span> XDG_SESSION_TYPE=x11</span><br></pre></td></tr></table></figure><p>保存并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="5-启动图形界面">5. 启动图形界面</h2><p>执行以下命令启动 <code>xfce4</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startxfce4</span><br></pre></td></tr></table></figure><p>然后就可以在 WSL2 中显示图形界面了。</p><h2 id="6-OpenCV-相关问题">6. OpenCV 相关问题</h2><p>使用 <code>apt</code> 安装 OpenCV 成功，但 <code>vcpkg</code> 方式失败，原因未知。<br>此外，有一个小技巧：WSL 可以直接使用 Windows 磁盘路径，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mnt/c/（C 盘路径）</span><br></pre></td></tr></table></figure><p>可以直接访问 Windows 里的图片文件。</p><p>最终编译运行成功，并成功显示图片！ 🎉<br><img src="https://cdn-a.markji.com/files/67b7f45da5c2cef46265e459_hd.png?e=1740988820039&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FVDLnFenUDMYp4etgqXF7xGFeyY=" alt="图片1"></p><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SFINAE在c++模板中的使用及标准库中的应用</title>
    <link href="https://eatbreads.github.io/posts/b2bfdc17.html"/>
    <id>https://eatbreads.github.io/posts/b2bfdc17.html</id>
    <published>2025-03-02T15:35:44.000Z</published>
    <updated>2025-03-21T16:02:18.695Z</updated>
    
    <content type="html"><![CDATA[<h1>代换失败不是错误（SFINAE）</h1><h2 id="概念">概念</h2><p>SFINAE（Substitution Failure Is Not An Error）意为<strong>代换失败不是错误</strong>，这是 C++ 模板机制中的一个重要特性。</p><p><strong>核心思想</strong>：<br>当模板参数推导失败时，编译器不会报错，而是会尝试匹配其他可能的函数或模板。因此，它可以避免<strong>不合理的模板实例化</strong>，防止<strong>不该匹配的类型</strong>被错误实例化。<br><img src="https://cdn-a.markji.com/files/6718a31157833190dc44516e_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RUdsJ4FONhfWNo9_YiTTcVxvcrk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6718a366f0750c5d4663751b_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:o6yHRfpeWxDBQnRrolze3ZVy3a0=" alt="图片1"><br><strong>PS：非常非常重要！</strong></p><h2 id="代换失败的规则">代换失败的规则</h2><p>任何<strong>导致代换的模板实参</strong>不符合 C++ 语法（即<strong>非良构</strong>）的情况，都会导致代换失败，而不会引发编译错误。</p><p><strong>PS：非良构</strong>表示不符合 C++ 的基本语法。<br><img src="https://cdn-a.markji.com/files/6718aa5af0750c5d46665066_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:x751lLJmCrCiHlKE9qCWN48oK2g=" alt="图片1"></p><h2 id="SFINAE-的具体使用">SFINAE 的具体使用</h2><p>通常，即使不使用 SFINAE，C++ 也会在模板实例化后报错。但 SFINAE 的关键在于：</p><p>✅ <strong>SFINAE 使得错误发生在实例化前，而非实例化后。</strong><br>✅ <strong>能不实例化就不要实例化</strong>，因为某些模板实例化后可能产生难以理解的错误信息。<br>✅ <strong>使用 SFINAE，错误信息会变得更简单，比如 “未找到匹配的重载函数”。</strong><br>✅ <strong>模板实例化本身是有开销的</strong>，尤其对于复杂模板而言，实例化可能带来较大编译成本。<br><img src="https://cdn-a.markji.com/files/6718aebb12bf596766b9afe2_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Zqkct74cpIBK0S1gAb-IUjoCuN0=" alt="图片1"></p><h2 id="标准库中的-SFINAE-——-enable-if-t">标准库中的 SFINAE —— <code>enable_if_t</code></h2><p>标准库中的 <code>std::enable_if_t</code> 是 SFINAE 的典型应用。</p><p>在前面的知识点中，我们讨论了对类型的行为要求，例如：</p><ul><li>是否具有 <code>type</code> 成员</li><li>是否支持加减运算</li></ul><p>使用 <code>enable_if</code> 可以为模板增加约束，从而控制哪些类型可以实例化该模板。</p><p><strong>PS：本质上，<code>enable_if</code> 是“使得模板可用，如果满足某个条件”。</strong></p><h2 id="enable-if-t-的原理"><code>enable_if_t</code> 的原理</h2><ul><li><code>enable_if</code> <strong>在第一参数为 <code>true</code> 时</strong>，才会定义 <code>type</code> 成员；</li><li>如果第一参数为 <code>false</code>，则 <strong>没有 <code>type</code> 成员</strong>，从而导致代换失败（SFINAE 机制生效）。<br><img src="https://cdn-a.markji.com/files/6718e6c4ccfef1e7ef90aa39_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Qic1PBCiJefrDMGGuvz70TXe6bQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6718e87eccfef1e7ef91d10e_hd.png?e=1740932078152&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:_9RzhzxTtQxZkuO8DX9FiOHPmPk=" alt="图片1"></li></ul><hr><p>SFINAE 是 C++ 模板元编程的核心技巧之一，合理使用可以提高代码的可读性和健壮性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;代换失败不是错误（SFINAE）&lt;/h1&gt;
&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;SFINAE（Substitution Failure Is Not An Error）意为&lt;strong&gt;代换失败不是错误&lt;/strong&gt;，这是 C++ 模板机制中的一个重要特性</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>奇异模板递归</title>
    <link href="https://eatbreads.github.io/posts/233853.html"/>
    <id>https://eatbreads.github.io/posts/233853.html</id>
    <published>2025-03-02T15:32:28.000Z</published>
    <updated>2025-03-21T16:02:18.735Z</updated>
    
    <content type="html"><![CDATA[<h1>CRTP</h1><p>CRTP（Curiously Recurring Template Pattern）被称为<strong>奇异重现</strong>，或者<strong>奇异递归模板模式</strong>。</p><h2 id="优势">优势</h2><ul><li>实现了<strong>静态多态</strong>，无需使用虚函数。</li><li><strong>无运行时开销</strong>，提高性能。</li><li>避免了传统的向下转换（downcasting）导致的类型错误。</li></ul><h2 id="备注">备注</h2><p>以后可以尝试<strong>都使用 CRTP</strong> 来编写代码，以免去运行时开销。其实改动并不难。<br><img src="https://cdn-a.markji.com/files/671efd0edee1d69b5795e9e8_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:eTV6e0Uq9JPfOinXXfpIMFBNfrQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671efe26dee1d69b579632ad_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:xdubiw1N2IuVkkZDpZFaa3Zt7zw=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671efe71dee1d69b5796771c_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2SKkuT0tqcQk8W5ETJdWlTmGC0M=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671effd53f407d0defb03c91_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:266HrCtrSmLMkWx15DEJq9Tg2CI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/671f0372dee1d69b57977b98_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5rrSzhrY_9WCbvminQU3CnWYDzk=" alt="图片1"><br><img src="%E9%93%BEhttps://cdn-a.markji.com/files/671f0407dee1d69b57979395_hd.png?e=1740932078154&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:0y2tMdhuqFIb51or_ieuJTP55wA=" alt="图片1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CRTP&lt;/h1&gt;
&lt;p&gt;CRTP（Curiously Recurring Template Pattern）被称为&lt;strong&gt;奇异重现&lt;/strong&gt;，或者&lt;strong&gt;奇异递归模板模式&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;优势&quot;&gt;优势&lt;/h2&gt;
&lt;ul</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>颜色与光照和冯氏光源</title>
    <link href="https://eatbreads.github.io/posts/6f91cf88.html"/>
    <id>https://eatbreads.github.io/posts/6f91cf88.html</id>
    <published>2025-03-01T14:27:42.000Z</published>
    <updated>2025-03-21T16:02:18.735Z</updated>
    
    <content type="html"><![CDATA[<h1>颜色与光源</h1><p><img src="https://cdn-a.markji.com/files/67c15ba5dc26a985b3b34fdc_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:yx4H1nkKytF1Cm7g3oJq7090FfY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c16188dc26a985b3b48403_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:56MP6kELtAyQZFdJzSF3WMfqVcE=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c16377b18af440dfe9778b_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:tIJYO-KENMom4Ws2gUWyi-3_oZY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c16554dc26a985b3b53c79_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cglFWhSiTsRj49mrrMBojIWgER4=" alt="图片1"></p><h2 id="冯氏光照">冯氏光照</h2><p><img src="https://cdn-a.markji.com/files/67c1660eb18af440dfea20e9_hd.png?e=1740841796029&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:K_pslwGHQp1g_WlArTLIklZzsyg=" alt="图片1"><br>在顶点着色器（vertex shader）中实现冯氏光照会导致较差的效果，而在片元着色器（fragment shader）中实现，尽管计算成本较高，但能获得更好的渲染结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;颜色与光源&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-a.markji.com/files/67c15ba5dc26a985b3b34fdc_hd.png?e=1740841796029&amp;amp;token=xX63b9jqTlDOcGmctt5K925</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>opengl的摄像机相关</title>
    <link href="https://eatbreads.github.io/posts/b90c4775.html"/>
    <id>https://eatbreads.github.io/posts/b90c4775.html</id>
    <published>2025-02-27T16:07:30.000Z</published>
    <updated>2025-03-21T16:02:18.710Z</updated>
    
    <content type="html"><![CDATA[<h1>摄像机</h1><p><img src="https://cdn-a.markji.com/files/67c0333fdc26a985b391278b_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2EL6zFizoQrig0PpFEvC1WXiXAU=" alt="图片1"><br>原本应该是先旋转再位移。<br><img src="https://cdn-a.markji.com/files/67c0350ab18af440dfc68363_hd.png?e=1740672193731&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:CQwgolnwpqRTgZCsQZg1aJ8kuQ0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c03694b18af440dfc6a40c_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2PMBZtj_iOf9MVA2sROAFDYsIPQ=" alt="图片1"></p><h2 id="顺时针旋转">顺时针旋转</h2><blockquote><p>注意：改成 <code>-sin</code> 就会变成顺时针旋转。</p></blockquote><h2 id="左右移动">左右移动</h2><p>给摄像机加入左右移动的功能。<br><img src="https://cdn-a.markji.com/files/67c03a00b18af440dfc6f9b1_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:yqDp-z7SEfSo2nSK76P6t1w7B64=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c03aaadc26a985b391fe4a_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:INIm9mGfjw-2mJW7pYlfYXIi0T0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c055a1dc26a985b3975b4c_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:-Lv1hO4hyiGQ90t7SmV9kmKlK70=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67c0569edc26a985b3977a34_hd.png?e=1740672193732&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:XXw_CNlGRgL795b_uejwQyVPWCQ=" alt="图片1"></p><h2 id="封装成-Camera-类">封装成 Camera 类</h2><p>这些功能都可以封装成一个 <code>Camera</code> 类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;摄像机&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-a.markji.com/files/67c0333fdc26a985b391278b_hd.png?e=1740672193731&amp;amp;token=xX63b9jqTlDOcGmctt5K9254r</summary>
      
    
    
    
    
  </entry>
  
</feed>
