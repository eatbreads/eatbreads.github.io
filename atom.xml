<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到小面包的小站🥝</title>
  
  
  <link href="https://eatbreads.github.io/atom.xml" rel="self"/>
  
  <link href="https://eatbreads.github.io/"/>
  <updated>2025-04-01T15:56:44.026Z</updated>
  <id>https://eatbreads.github.io/</id>
  
  <author>
    <name>小面包🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Qt+OpenGL+FFmpeg实现GPU硬解码视频播放</title>
    <link href="https://eatbreads.github.io/posts/f4071fe9.html"/>
    <id>https://eatbreads.github.io/posts/f4071fe9.html</id>
    <published>2025-04-01T15:53:33.000Z</published>
    <updated>2025-04-01T15:56:44.026Z</updated>
    
    <content type="html"><![CDATA[<h1>OpenGL+FFmpeg实现GPU硬解码视频播放</h1><h2 id="OpenGL渲染流程">OpenGL渲染流程</h2><h3 id="1-着色器准备">1. 着色器准备</h3><p>需要准备:</p><ul><li>顶点着色器代码</li><li>片段着色器代码</li><li>顶点数组</li><li>索引缓冲对象(IBO)数组</li></ul><h3 id="2-缓冲区设置">2. 缓冲区设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并绑定VAO</span></span><br><span class="line">GLuint VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并绑定VBO和IBO</span></span><br><span class="line">GLuint VBO, IBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;IBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入数据</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, IBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="3-着色器编译与链接">3. 着色器编译与链接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译着色器</span></span><br><span class="line">program.<span class="built_in">addShaderFromSourceCode</span>(QOpenGLShader::Vertex, vertexShaderSource);</span><br><span class="line">program.<span class="built_in">addShaderFromSourceCode</span>(QOpenGLShader::Fragment, fragmentShaderSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接程序</span></span><br><span class="line">program.<span class="built_in">link</span>();</span><br><span class="line">program.<span class="built_in">bind</span>();</span><br></pre></td></tr></table></figure><h3 id="4-属性指针设置">4. 属性指针设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应着色器中的layout (location = 0)</span></span><br><span class="line">program.<span class="built_in">enableAttributeArray</span>(<span class="number">0</span>);  <span class="comment">// 顶点位置</span></span><br><span class="line">program.<span class="built_in">enableAttributeArray</span>(<span class="number">1</span>);  <span class="comment">// 纹理坐标</span></span><br></pre></td></tr></table></figure><h3 id="5-矩阵变换">5. 矩阵变换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置MVP矩阵</span></span><br><span class="line">QMatrix4x4 model, view, projection;</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br></pre></td></tr></table></figure><h2 id="FFmpeg硬解码部分">FFmpeg硬解码部分</h2><h3 id="1-初始化硬解码器">1. 初始化硬解码器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找硬解码器</span></span><br><span class="line"><span class="type">const</span> AVCodec *codec = <span class="built_in">avcodec_find_decoder_by_name</span>(<span class="string">&quot;h264_cuvid&quot;</span>); <span class="comment">// NVIDIA GPU</span></span><br><span class="line"><span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">    codec = <span class="built_in">avcodec_find_decoder_by_name</span>(<span class="string">&quot;h264_qsv&quot;</span>);  <span class="comment">// Intel GPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-解码并传输到GPU">2. 解码并传输到GPU</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解码后直接得到GPU纹理</span></span><br><span class="line">AVFrame *frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="built_in">avcodec_send_packet</span>(codecContext, packet);</span><br><span class="line"><span class="built_in">avcodec_receive_frame</span>(codecContext, frame);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OpenGL纹理</span></span><br><span class="line">GLuint texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><h2 id="渲染循环">渲染循环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清空缓冲</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定程序和纹理</span></span><br><span class="line">    program.<span class="built_in">bind</span>();</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67ea86de8e36ed84184859cb_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:a8msW1EK2bX_E-38bWanGWW4DcI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea87b4205d5713c0bf8b46_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5JY2dB8a0x_1kstKpMmOT5jajaw=" alt="图片1"></p><h2 id="注意事项">注意事项</h2><ol><li><p>硬解码支持:</p><ul><li>需要确保GPU支持对应格式的硬解码</li><li>需要正确安装GPU驱动</li></ul></li><li><p>性能优化:</p><ul><li>使用PBO(Pixel Buffer Object)进行异步传输</li><li>考虑使用多重缓冲</li></ul></li><li><p>同步处理:</p><ul><li>注意音视频同步</li><li>控制帧率</li></ul></li></ol>]]></content>
    
    
    <summary type="html">使用OpenGL实现GPU硬解码视频播放的完整流程</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="GPU加速" scheme="https://eatbreads.github.io/tags/GPU%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Qt5+FFmpeg实现视频软解码播放</title>
    <link href="https://eatbreads.github.io/posts/fd1aef76.html"/>
    <id>https://eatbreads.github.io/posts/fd1aef76.html</id>
    <published>2025-04-01T15:41:20.000Z</published>
    <updated>2025-04-01T15:45:40.943Z</updated>
    
    <content type="html"><![CDATA[<h1>Qt5+FFmpeg实现视频软解码播放</h1><h2 id="基本流程">基本流程</h2><ol><li>使用FFmpeg解封装获取视频流</li><li>对视频流进行解码得到原始数据</li><li>将解码后的数据转换为Qt可显示的格式</li><li>使用Qt组件显示视频画面</li></ol><h2 id="主要步骤">主要步骤</h2><h3 id="1-初始化FFmpeg">1. 初始化FFmpeg</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册所有组件</span></span><br><span class="line"><span class="built_in">av_register_all</span>();</span><br><span class="line"><span class="comment">// 打开视频文件</span></span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;formatContext, filename, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 获取流信息</span></span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(formatContext, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h3 id="2-查找视频解码器">2. 查找视频解码器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取视频流索引</span></span><br><span class="line">videoIndex = <span class="built_in">av_find_best_stream</span>(formatContext, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取解码器</span></span><br><span class="line">AVCodec *codec = <span class="built_in">avcodec_find_decoder</span>(formatContext-&gt;streams[videoIndex]-&gt;codecpar-&gt;codec_id);</span><br></pre></td></tr></table></figure><h3 id="3-解码并显示">3. 解码并显示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取视频帧</span></span><br><span class="line"><span class="built_in">av_read_frame</span>(formatContext, packet);</span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="built_in">avcodec_send_packet</span>(codecContext, packet);</span><br><span class="line"><span class="built_in">avcodec_receive_frame</span>(codecContext, frame);</span><br><span class="line"><span class="comment">// 转换为RGB格式</span></span><br><span class="line"><span class="built_in">sws_scale</span>(swsContext, frame-&gt;data, frame-&gt;linesize, <span class="number">0</span>, codecContext-&gt;height,</span><br><span class="line">          frameRGB-&gt;data, frameRGB-&gt;linesize);</span><br><span class="line"><span class="comment">// 显示画面</span></span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(frameRGB-&gt;data[<span class="number">0</span>], codecContext-&gt;width, codecContext-&gt;height, </span></span></span><br><span class="line"><span class="params"><span class="function">             QImage::Format_RGB32)</span></span>;</span><br><span class="line">label-&gt;<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br></pre></td></tr></table></figure><h2 id="部分代码图片">部分代码图片</h2><p><img src="https://cdn-a.markji.com/files/67ea4ced8e36ed841840aef9_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:0oKoHUP8QToYpe52ZzlRFuDU4fI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea4d4c205d5713c0b740e2_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ArjYpTLoeAf_jD2eYls8bfegURI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea4e4a8e36ed841840da6a_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:p9GWgo9KlxiCFrWDpwrGFFEOcb8=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea5167205d5713c0b7d299_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:pnGhA5vUgjOD2j1jeIcako17Ku0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea51ea205d5713c0b7e150_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:kYBdJwcbpc9hzbyzsEt6QVNkaNQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54818e36ed8418422ffe_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:31FoxGoEK8vYqAJKDGWXS35mbSQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54af8e36ed8418423956_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:M65_RmAy6Z3G-i1E-F1oQbEpEDA=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54d68e36ed8418423ff2_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:dl3u7WCx1V5fZlwBV1tIqEvo9vs=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea56d7205d5713c0b887a0_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:wULFepBr_NTRnAr1AFkRYQDWsrk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea5a08205d5713c0b92436_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Eo7PAY6RNuLrWE9awS8bpV4Mcrc=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">记录使用Qt5和FFmpeg实现视频软解码播放的过程</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>在Qt中使用FFmpeg</title>
    <link href="https://eatbreads.github.io/posts/9b502338.html"/>
    <id>https://eatbreads.github.io/posts/9b502338.html</id>
    <published>2025-03-30T15:57:37.000Z</published>
    <updated>2025-03-30T16:00:01.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Qt中使用FFmpeg实现播放和录音"><a href="#在Qt中使用FFmpeg实现播放和录音" class="headerlink" title="在Qt中使用FFmpeg实现播放和录音"></a>在Qt中使用FFmpeg实现播放和录音</h1><h2 id="初始尝试"><a href="#初始尝试" class="headerlink" title="初始尝试"></a>初始尝试</h2><p>从CSDN中找到了对应的库并进行修改，最终编译成功。但运行时发现没有对应的输入声音设备。</p><h2 id="查看设备"><a href="#查看设备" class="headerlink" title="查看设备"></a>查看设备</h2><p>使用FFmpeg命令查看可用设备:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -list_devices <span class="literal">true</span> -f dshow -i dummy</span><br></pre></td></tr></table></figure><br><img src="https://cdn-a.markji.com/files/67e7e6c2205d5713c080d12b_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:HlFFCuvBB0KSVXRTfKUfHs_zWYY=" alt="图片1"></p><h2 id="录制测试"><a href="#录制测试" class="headerlink" title="录制测试"></a>录制测试</h2><p>尝试直接使用FFmpeg命令录制:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f dshow -i audio=<span class="string">&quot;麦克风阵列 (Realtek(R) Audio)&quot;</span> -t 5 test.wav</span><br></pre></td></tr></table></figure><br>录制失败，最后发现是没有打开麦克风权限。解决权限问题后成功录制音频。<br><img src="https://cdn-a.markji.com/files/67e7f6222f58dfdf11a28259_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:P57m6HSucCpw477ZThLl9ycR9sE=" alt="图片1"></p><h2 id="音频播放实现"><a href="#音频播放实现" class="headerlink" title="音频播放实现"></a>音频播放实现</h2><p>在论坛找到播放代码，发现使用的是<code>&lt;QAudioFormat&gt;</code>中的<code>QAudioOutput</code>。但在Qt6中它已被<code>QAudioSink</code>取代。</p><h2 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h2><p>添加头文件后仍然报错，最终在CMakeLists.txt中添加:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Qt6::Multimedia</span><br></pre></td></tr></table></figure><br>才解决了头文件找不到的问题。<br><img src="https://cdn-a.markji.com/files/67e7fa65205d5713c08396ca_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:UVepqCC-P2xPFN7e-CcqjiRjrEU=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e80df9205d5713c086279e_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:LkbnqLWkqBpgs5XhdSxMzqpyeRk=" alt="图片1"></p><h2 id="重采样问题"><a href="#重采样问题" class="headerlink" title="重采样问题"></a>重采样问题</h2><p>重采样相关的代码编译一直不通过。</p><p>即使参考官方文档的示例也无法运行，最终不得不寻找其他解决方案。<br> <img src="https://cdn-a.markji.com/files/67e812cf205d5713c086a286_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Iidek_AwIhs3x_vdFwJcPRHMIvg=" alt="图片1"><br> <img src="https://cdn-a.markji.com/files/67e816252f58dfdf11a68af8_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:vz8s-IeSIVWjNEB1jsY88wphH1o=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">记录在Qt中使用FFmpeg实现音视频播放和录制的过程</summary>
    
    
    
    <category term="Qt开发" scheme="https://eatbreads.github.io/categories/Qt%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>封装一个好用的C++20协程</title>
    <link href="https://eatbreads.github.io/posts/5950a8c.html"/>
    <id>https://eatbreads.github.io/posts/5950a8c.html</id>
    <published>2025-03-27T09:52:50.000Z</published>
    <updated>2025-03-28T07:18:33.692Z</updated>
    
    <content type="html"><![CDATA[<h1>封装C++20协程</h1><h2 id="基本概念">基本概念</h2><p>在C++20中,只要函数返回值是Task类型,并使用co_return返回,该函数就自动成为一个协程函数。</p><p>Task不仅仅是一个&quot;配置文件&quot;,它还承担着协程的核心管理职责。<br><img src="https://cdn-a.markji.com/files/67e5149181bdefd1be1b48a1_hd.png?e=1743071911923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:qD4gzPadJ_pcN2NUgOz7CfrLvuA=" alt="图片1"></p><h2 id="核心原理">核心原理</h2><h3 id="协程的执行控制">协程的执行控制</h3><p>一个返回Task的函数本身就是协程,其内部代码会在以下情况下异步执行:</p><ul><li>co_await 语句控制</li><li>co_return 语句控制</li></ul><h3 id="恢复协程的两种方式">恢复协程的两种方式</h3><ol><li>内部恢复:</li></ol><ul><li>通过handle.resume()</li><li>由异步等待操作触发(如Delay的await_suspend)</li></ul><ol start="2"><li>外部恢复:</li></ol><ul><li>通过task2.resume()显式调用</li><li>主动从外部恢复协程执行</li></ul><p>这两种方式都会立即恢复协程并从挂起点继续执行,最终到达co_return。</p><h2 id="实践发现">实践发现</h2><p>在实际使用中发现一个有趣的现象:</p><ul><li>注释掉handle.resume()不影响程序运行</li><li>但注释掉main函数中的resume()会导致程序卡住<br><img src="https://cdn-a.markji.com/files/67e50d7bd5e9e782bf746323_hd.png?e=1743071911923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Bqc5H0LAPJjBWn_d_qcFVY0rLxk=" alt="图片1"></li></ul><h2 id="编译命令">编译命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> -std=c++20 test.cpp</span><br></pre></td></tr></table></figure><h2 id="完整头文集">完整头文集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        T value_;</span><br><span class="line">        std::exception_ptr exception_;</span><br><span class="line"></span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">            value_ = std::<span class="built_in">move</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            exception_ = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Awaiter 支持</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存当前等待的协程句柄</span></span><br><span class="line">        waiting_handle_ = handle;</span><br><span class="line">        <span class="comment">// 恢复当前任务的执行</span></span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_) &#123;</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(handle_.<span class="built_in">promise</span>().value_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">handle_</span>(handle) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(Task&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">handle_</span>(other.handle_) &#123;</span><br><span class="line">        other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(Task&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">            handle_ = other.handle_;</span><br><span class="line">            other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_)</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(handle_.<span class="built_in">promise</span>().value_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle_.<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; handle_;</span><br><span class="line">    <span class="keyword">mutable</span> std::coroutine_handle&lt;&gt; waiting_handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化 void 类型的 Task</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        std::exception_ptr exception_;</span><br><span class="line"></span><br><span class="line">        <span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Task</span>&lt;<span class="type">void</span>&gt;(std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            exception_ = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Awaiter 支持</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        waiting_handle_ = handle;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_) &#123;</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">handle_</span>(handle) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(Task&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">handle_</span>(other.handle_) &#123;</span><br><span class="line">        other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(Task&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">            handle_ = other.handle_;</span><br><span class="line">            other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_)</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle_.<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; handle_;</span><br><span class="line">    <span class="keyword">mutable</span> std::coroutine_handle&lt;&gt; waiting_handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCoroutine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例: 延迟执行的awaiter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delay</span> &#123;</span><br><span class="line">    std::chrono::milliseconds duration_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Delay</span><span class="params">(std::chrono::milliseconds duration)</span> : duration_(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">thread</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(duration_);</span><br><span class="line">            <span class="comment">//handle.resume();</span></span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始执行任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">42</span>;  <span class="comment">// 直接返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 带延迟的异步任务</span></span><br><span class="line"><span class="function">Task&lt;std::string&gt; <span class="title">delayed_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始延迟任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">Delay</span><span class="params">(std::chrono::milliseconds(<span class="number">4000</span>))</span></span>;  <span class="comment">// 等待1秒</span></span><br><span class="line">    <span class="keyword">co_return</span> <span class="string">&quot;完成&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3: 组合多个异步任务</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">combined_tasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result1 = <span class="keyword">co_await</span> <span class="built_in">simple_task</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个任务结果: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">delayed_task</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第二个任务结果: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行简单任务</span></span><br><span class="line">    <span class="keyword">auto</span> task1 = <span class="built_in">simple_task</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">1.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">1.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;简单任务结果: &quot;</span> &lt;&lt; task<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行延迟任务</span></span><br><span class="line">    <span class="keyword">auto</span> task2 = <span class="built_in">delayed_task</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">2.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">2.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;延迟任务结果: &quot;</span> &lt;&lt; task<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行组合任务</span></span><br><span class="line">    <span class="keyword">auto</span> task3 = <span class="built_in">combined_tasks</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">3.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">3.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    task<span class="number">3.</span><span class="built_in">get</span>();  <span class="comment">// 对于void类型的Task，仍然需要调用get()来检查异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>## 注意事项1. 协程函数必须:   - 返回Task类型   - 使用co_return返回值2. 恢复机制选择:   - 内部恢复适合自动触发的场景   - 外部恢复适合需要手动控制的场景3. 性能考虑:   - 协程切换有一定开销   - 适合IO密集型任务   - 不适合CPU密集型计算</code></pre>]]></content>
    
    
    <summary type="html">介绍如何封装和使用C++20协程功能</summary>
    
    
    
    <category term="C++开发" scheme="https://eatbreads.github.io/categories/C-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="协程" scheme="https://eatbreads.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="异步编程" scheme="https://eatbreads.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>回调地狱和解决方法</title>
    <link href="https://eatbreads.github.io/posts/f3d7b43c.html"/>
    <id>https://eatbreads.github.io/posts/f3d7b43c.html</id>
    <published>2025-03-27T09:48:16.000Z</published>
    <updated>2025-03-28T07:18:33.689Z</updated>
    
    <content type="html"><![CDATA[<h1>回调地狱及其解决方案</h1><h2 id="什么是回调地狱">什么是回调地狱</h2><p>回调地狱(Callback Hell)一般指的是回调函数层层嵌套的现象,这种代码结构会导致:</p><ul><li>代码难以理解</li><li>维护成本高</li><li>调试困难</li></ul><h2 id="常见场景">常见场景</h2><p>回调地狱常见于异步编程中,特别是:</p><ol><li>事件驱动模型</li><li>基于回调的异步操作</li><li>网络请求</li><li>文件读取</li><li>定时任务</li></ol><h2 id="主要问题">主要问题</h2><h3 id="1-状态传递困难">1. 状态传递困难</h3><p>多层嵌套的回调需要在不同层级间传递各种状态,导致:</p><ul><li>代码难以调试</li><li>错误追踪困难</li><li>状态管理复杂</li></ul><h3 id="2-事件依赖链">2. 事件依赖链</h3><p>典型例子是处理EPOLLIN事件时需要等待其他异步事件完成,形成复杂的事件依赖关系。<br><img src="https://cdn-a.markji.com/files/67e4f7d681bdefd1be164eb2_hd.png?e=1743071664551&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:S7s8WGObEQ7yLIBHFVNx3hy0zQ0=" alt="图片1"></p><h3 id="3-框架局限">3. 框架局限</h3><p>即使是现代框架如Qt的信号槽机制,在处理复杂的异步流程时也可能遇到类似问题。</p><h2 id="解决方案">解决方案</h2><h3 id="1-有限状态机">1. 有限状态机</h3><p>使用状态机可以:</p><ul><li>清晰地定义状态转换</li><li>简化事件处理逻辑</li><li>提高代码可维护性<br><img src="https://cdn-a.markji.com/files/67e4f9ae81bdefd1be16b2e6_hd.png?e=1743071674079&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4qWtJeXCFx8d5jW3lGtTV0QP2fY=" alt="图片1"></li></ul><h3 id="2-协程">2. 协程</h3><p>协程提供了更优雅的解决方案:</p><ul><li>可以暂停执行中的线程</li><li>类似于给线程添加了goto能力</li><li>代码结构更清晰易读</li><li>接近同步代码的写法</li><li>避免了显式的回调嵌套</li></ul><p>协程相比传统回调的优势:</p><ul><li>线性的代码结构</li><li>更好的错误处理</li><li>更容易的状态管理</li><li>更接近人类思维方式</li></ul><h2 id="总结">总结</h2><p>回调地狱是异步编程中的常见问题,通过合适的设计模式(如状态机)或现代语言特性(如协程)可以有效避免这个问题。选择哪种解决方案需要根据具体场景和需求来决定。</p>]]></content>
    
    
    <summary type="html">回调地狱产生的原因及其解决方案</summary>
    
    
    
    <category term="编程技术" scheme="https://eatbreads.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="异步编程" scheme="https://eatbreads.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    <category term="设计模式" scheme="https://eatbreads.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>高性能服务器压力测试</title>
    <link href="https://eatbreads.github.io/posts/1c2eabf7.html"/>
    <id>https://eatbreads.github.io/posts/1c2eabf7.html</id>
    <published>2025-03-27T09:38:43.000Z</published>
    <updated>2025-03-27T09:44:48.280Z</updated>
    
    <content type="html"><![CDATA[<h1>服务器性能测试</h1><h2 id="测试类型">测试类型</h2><p>服务器性能测试主要分为两类:</p><ul><li>连接吞吐测试: 测试TCP的连接建立和断开性能</li><li>数据吞吐测试: 测试数据收发能力<br><img src="https://cdn-a.markji.com/files/67e41be2d5e9e782bf5d5c27_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:gXwKTAIzYWZ958RV0rFgeQY-lkA=" alt="图片1"></li></ul><h2 id="测试工具尝试">测试工具尝试</h2><h3 id="1-hping3测试">1. hping3测试</h3><p>hping3主要用于TCP/UDP/ICMP测试,可以用于简单的TCP并发连接测试。</p><p>测试命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S -p 8080 -c 200 --fast 127.0.0.1</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>-S：发送SYN包(建立TCP连接)</li><li>-p 8080：目标端口8080</li><li>-c 200：发送200个连接</li><li>–fast：快速发送请求</li></ul><h3 id="2-测试问题">2. 测试问题</h3><p>hping3存在问题:只发送SYN包而不完成完整的三次握手。</p><p>尝试使用nping:</p><ul><li>可以同时发送SYN和ACK</li><li>但服务器直接返回RST拒绝连接</li><li>可能是因为同时发送导致的问题</li></ul><h3 id="3-wrk测试">3. wrk测试</h3><p>最后尝试使用http测试工具wrk:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t4 -c1000 -d10s http://127.0.0.1:8082/</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>4个线程</li><li>1000并发连接</li><li>持续10秒</li></ul><p>测试结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Running 10s test @ http://127.0.0.1:8082/</span><br><span class="line">  4 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     0.00us    0.00us   0.00us    -nan%</span><br><span class="line">    Req/Sec     0.00      0.00     0.00      -nan%</span><br><span class="line">  0 requests in 10.10s, 0.00B read</span><br><span class="line">  Socket errors: connect 0, read 221412, write 0, timeout 0</span><br><span class="line">Requests/sec:      0.00</span><br><span class="line">Transfer/sec:       0.00B</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67e4230481bdefd1be044f9c_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5xzRSXgWiCCrw0kE2d6C8Niiro4=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e423d9d5e9e782bf5f4193_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:KqAiU6anLcQmrkLlipX43k-OgLs=" alt="图片1"></p><h3 id="4-最终方案">4. 最终方案</h3><p>虽然wrk需要解析HTTP协议会带来额外开销,但考虑到测试的完整性,最终还是选择了:</p><ul><li>使用简单的HTTP响应</li><li>通过自定义client.cpp进行压力测试</li></ul><p><img src="https://cdn-a.markji.com/files/67e4e82681bdefd1be142474_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MsZPuHpePJdsXpwEhq9FlnU0bak=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e4e8f981bdefd1be1437e8_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Sgon3GxsCZKhCSOoiSfadNtK3qo=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">记录服务器性能测试的方法和经验</summary>
    
    
    
    <category term="c++开发" scheme="https://eatbreads.github.io/categories/c-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="服务器" scheme="https://eatbreads.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="性能测试" scheme="https://eatbreads.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="网络编程" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++20协程学习笔记</title>
    <link href="https://eatbreads.github.io/posts/c8e6cc4a.html"/>
    <id>https://eatbreads.github.io/posts/c8e6cc4a.html</id>
    <published>2025-03-27T09:36:43.000Z</published>
    <updated>2025-03-27T10:58:22.397Z</updated>
    
    <content type="html"><![CDATA[<h1>C++20协程学习笔记</h1><h2 id="协程基本概念">协程基本概念</h2><p>C++20引入了协程支持,提供了三个关键字:</p><h3 id="co-await">co_await</h3><p>用于等待一个异步操作完成。当遇到co_await时,协程会暂停执行并让出控制权,直到异步操作完成。</p><h3 id="co-return">co_return</h3><p>协程的返回语句,用于返回一个值并结束协程的执行。与普通函数的return不同,co_return会触发协程的清理流程。</p><h3 id="co-yield">co_yield</h3><p>暂停协程执行并返回一个值,但不会结束协程。当协程重新恢复执行时,会从co_yield的下一条语句继续执行。</p><h2 id="图片展示">图片展示</h2><p><img src="https://cdn-a.markji.com/files/67e3b3bed5e9e782bf4c5f5e_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:dm0hXEqtu0m3aIkrwD090-GKEM0=" alt="协程原理图1"></p><p><img src="https://cdn-a.markji.com/files/67e3b4c181bdefd1bef23aff_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:tiu4RI3FO9Ow1wjPMSnHm-9EJMQ=" alt="协程示例代码"></p><p><img src="https://cdn-a.markji.com/files/67e3e413d5e9e782bf530102_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:WQQWDUaan3U5TF1Q0MN4TgzVg9E=" alt="协程执行流程"></p><p><img src="https://cdn-a.markji.com/files/67e3e614d5e9e782bf533eae_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cBWMwkhuLg6n7m2K_L-bFA9lE3w=" alt="协程执行流程"></p>]]></content>
    
    
    <summary type="html">C++20协程的基本概念和使用方法总结</summary>
    
    
    
    <category term="C++开发" scheme="https://eatbreads.github.io/categories/C-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="协程" scheme="https://eatbreads.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="异步编程" scheme="https://eatbreads.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>RTSP客户端</title>
    <link href="https://eatbreads.github.io/posts/78dc036a.html"/>
    <id>https://eatbreads.github.io/posts/78dc036a.html</id>
    <published>2025-03-25T15:51:53.000Z</published>
    <updated>2025-03-27T09:39:25.147Z</updated>
    
    <content type="html"><![CDATA[<h1>RTSP客户端实现</h1><h2 id="客户端类型">客户端类型</h2><p>有两种实现方式:</p><ul><li>拉流客户端</li><li>推流客户端</li></ul><p>之前的实现都是直接使用ffmpeg来推流到服务器。</p><h2 id="拉流命令">拉流命令</h2><h3 id="从RTSP拉流">从RTSP拉流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -rtsp_transport tcp -i rtsp://your_rtsp_url -c copy output.mp4</span><br></pre></td></tr></table></figure><h3 id="从RTMP拉流">从RTMP拉流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp://your_rtmp_url -c copy output.mp4</span><br></pre></td></tr></table></figure><h2 id="推流命令">推流命令</h2><h3 id="RTMP推流">RTMP推流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c:v libx264 -b:v 1M -c:a aac -b:a 128k -f flv rtmp://your_rtmp_server/live/stream</span><br></pre></td></tr></table></figure><h3 id="RTSP推流">RTSP推流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c:v libx264 -preset ultrafast -tune zerolatency -c:a aac -f rtsp rtsp://your_rtsp_server/live</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67e260cb05df26320832127d_hd.png?e=1742892963667&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:fHVoxBdXPEl4Ehy3Ogstwn8RE4g=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e261a805df263208322f45_hd.png?e=1742892963667&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:TWRdSVs2UbebpQEXk77sb2q_Dz4=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e2653e81bdefd1bec96919_hd.png?e=1742892963667&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:TsjvUR8TDJ9YzdWxpiwBxCBZMEQ=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">RTSP客户端的推流和拉流实现</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="流媒体" scheme="https://eatbreads.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>在Qt中调用摄像头</title>
    <link href="https://eatbreads.github.io/posts/41c91819.html"/>
    <id>https://eatbreads.github.io/posts/41c91819.html</id>
    <published>2025-03-25T14:02:46.000Z</published>
    <updated>2025-03-25T14:36:13.321Z</updated>
    
    <content type="html"><![CDATA[<h1>Qt摄像头调用</h1><p><img src="https://cdn-a.markji.com/files/67e26e0f81bdefd1becac53f_hd.png?e=1742896807580&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:KKLRNxPYIsoAeyZ33CtujgoMhWE=" alt="图片1"></p><h2 id="视频帧处理">视频帧处理</h2><p>Qt 6 采集的视频帧是 QVideoFrame 格式,需要转换为 QImage 才能进行进一步处理,比如编码成 H.264 并保存为 MP4 文件。</p><h2 id="编码支持">编码支持</h2><p>Qt 本身不包含 H.264 或 AAC 编码功能，因此需要使用 FFmpeg 来进行编码和存储。<br><img src="https://cdn-a.markji.com/files/67e2727d81bdefd1becb7101_hd.png?e=1742896807580&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2o3jMUjyoQgaZdwiXwvZkYSel-o=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e273c005df263208355b7b_hd.png?e=1742896807580&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:XGfhJX89CRDkfaNyUkLwZ8uoVjM=" alt="图片1"></p><h2 id="extern关键字说明">extern关键字说明</h2><ul><li>extern主要用来告知编译器去外部查找定义,表示这里只是声明而没有定义,常用于头文件中声明全局变量</li><li>extern &quot;C&quot;用于告诉编译器这些引入的内容是C语言代码,不需要按照C++的命名规则来解析符号,避免解析错误</li></ul>]]></content>
    
    
    <summary type="html">Qt摄像头调用及视频处理相关知识</summary>
    
    
    
    <category term="Qt开发" scheme="https://eatbreads.github.io/categories/Qt%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>AAC音频解码</title>
    <link href="https://eatbreads.github.io/posts/4aa94b70.html"/>
    <id>https://eatbreads.github.io/posts/4aa94b70.html</id>
    <published>2025-03-24T15:51:53.000Z</published>
    <updated>2025-03-25T14:11:43.168Z</updated>
    
    <content type="html"><![CDATA[<h1>AAC音频解码</h1><p><img src="https://cdn-a.markji.com/files/67e113fc4e1cf4bdf4de9b84_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:jrtlGiHKozQdoQswVZm1Z4IsCJ0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e115d84e1cf4bdf4dedd66_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:XozHbjRj5GhfN44zC1HRMKtnk74=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e118ab8d016adbb48d03ce_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:xHd469LPFP1CY2K6iv9cMipU45k=" alt="图片1"><br>本质和h264封装进RTP数据包差不多,这里是把AAC封装进RTP数据包中进行传输。</p><h2 id="应用场景">应用场景</h2><p>此时就可以实现从客户端上传到服务器,然后服务器执行播放功能。<br><img src="https://cdn-a.markji.com/files/67e11ab44e1cf4bdf4dfbcf0_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:bfm5HqgqC3YcfPDerCySHvwLGow=" alt="图片1"></p><h2 id="播放命令">播放命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -i rtsp://127.0.0.1:8554</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">AAC音频编码及其RTP封装传输</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="网络协议" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频中同时传输h264和aac</title>
    <link href="https://eatbreads.github.io/posts/f5f059ad.html"/>
    <id>https://eatbreads.github.io/posts/f5f059ad.html</id>
    <published>2025-03-24T15:51:53.000Z</published>
    <updated>2025-03-25T14:11:43.168Z</updated>
    
    <content type="html"><![CDATA[<h1>音视频同步传输</h1><h2 id="实现原理">实现原理</h2><p><img src="https://cdn-a.markji.com/files/67e123a54e1cf4bdf4e16b2c_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:hljxLZt4MgMKbfZllhhTpnKHXX4=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e1255a8d016adbb48f30ae_hd.png?e=1742833810864&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cflNaN-tUpP_17v5oxghxc8X8Wk=" alt="图片1"><br>本质上是创建了两个线程,然后分别处理视频和音频的传输:</p><ul><li>一个线程负责h264视频数据的传输</li><li>另一个线程负责aac音频数据的传输</li></ul><p>通过多线程实现音视频的并行传输。</p>]]></content>
    
    
    <summary type="html">实现音视频的同步传输</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="多线程" scheme="https://eatbreads.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>h264封装到RTP数据包进行传输</title>
    <link href="https://eatbreads.github.io/posts/5b7142ef.html"/>
    <id>https://eatbreads.github.io/posts/5b7142ef.html</id>
    <published>2025-03-23T15:54:39.000Z</published>
    <updated>2025-03-28T07:23:22.178Z</updated>
    
    <content type="html"><![CDATA[<h1>h264封装到RTP数据包进行传输</h1><h2 id="RTP数据包结构">RTP数据包结构</h2><p>报文下面的数据称为有效载荷(payload)</p><h2 id="h264编码原理">h264编码原理</h2><p>h264是一种视频压缩技术,主要包含三种帧:</p><ul><li>i帧(关键帧): 不借助其他帧的独立完整帧</li><li>p帧: 需要参考前面帧的预测帧</li><li>b帧: 需要参考前后帧的双向预测帧</li></ul><p>使用GOP(Group Of Pictures)组来防止丢包。因为p帧这种全部参考前面帧的,一旦丢包后面就都会乱掉。</p><h2 id="h264结构">h264结构</h2><p>h264分为两层:</p><ul><li>网络提取层(NAL)</li><li>视讯编码层(VCL)</li></ul><p>编码后的数据流在网络提取层中传输。例如一个由100张图片组成的视频,每张图片压缩后都会得到一个独立的NAL单元(总共100个NAL)。</p><p>NAL的第一个字节用于标识当前帧类型(i/p/b帧)。</p><h2 id="IDR帧">IDR帧</h2><p>IDR帧是一种特殊的I帧:</p><ul><li>I帧是关键帧,可以独立解码</li><li>当IDR帧出现时会清空之前的参考帧(即时刷新Refresh)</li></ul><h2 id="MP4与h264">MP4与h264</h2><p>使用ffmpeg可以将MP4解析成h264文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -codec copy -bsf:h264 mp4toannexb -f h264 test.h264</span><br></pre></td></tr></table></figure><p>PS: MP4本质上是在h264基础上添加了头尾信息的封装格式,所以解封装过程主要是数据拷贝。</p>]]></content>
    
    
    <summary type="html">介绍h264视频编码及其RTP封装传输相关知识</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="网络协议" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>RTSP协议</title>
    <link href="https://eatbreads.github.io/posts/9577f504.html"/>
    <id>https://eatbreads.github.io/posts/9577f504.html</id>
    <published>2025-03-23T15:48:20.000Z</published>
    <updated>2025-03-23T15:56:41.078Z</updated>
    
    <content type="html"><![CDATA[<h1>RTSP协议</h1><h2 id="协议组成">协议组成</h2><p>包括RTSP、RTP、RTCP三个协议：</p><ul><li>RTSP: 负责建立连接通道</li><li>RTP(Real Time Transport Protocol 实时传输协议): 负责传输数据</li><li>RTCP: 负责传输质量控制</li></ul><h2 id="传输协议要求">传输协议要求</h2><ul><li>RTSP需要使用TCP协议</li><li>RTP和RTCP既可以使用TCP也可以使用UDP<br><img src="https://cdn-a.markji.com/files/67dfde4b63fe6caddd0ed86a_hd.png?e=1742731753507&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:nANoNala-Z_7NOgpyiexGRAhdq8=" alt="图片1"></li></ul><h2 id="SDP描述">SDP描述</h2><p>SDP包含两个层次的描述:</p><ul><li>会话级描述</li><li>媒体级描述(比如同时存在视频和音频就会有两个媒体级别)<br><img src="https://cdn-a.markji.com/files/67dfe27f5e2541566caed143_hd.png?e=1742731753507&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:wwCw9QuKdbiHiMfo2S64WUdijew=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67dfe43263fe6caddd0f8543_hd.png?e=1742731753507&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:8nsOtckGYkk8m6-wYgBJTcupiLU=" alt="图片1"></li></ul><h2 id="端口分配">端口分配</h2><ul><li>RTP使用低端口号</li><li>RTCP使用高端口号</li></ul><h2 id="实现说明">实现说明</h2><p>在实际代码实现中并没有真正建立两个通道,因为使用TCP时可以直接合并RTP和RTCP。<br><img src="https://cdn-a.markji.com/files/67dfe5715e2541566caf4522_hd.png?e=1742731753507&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:q9x1WpsovlA-kT3z1bqaXDniV_g=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">RTSP协议及相关协议介绍</summary>
    
    
    
    <category term="网络编程" scheme="https://eatbreads.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="网络协议" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="流媒体" scheme="https://eatbreads.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>协程八股</title>
    <link href="https://eatbreads.github.io/posts/706f5e8.html"/>
    <id>https://eatbreads.github.io/posts/706f5e8.html</id>
    <published>2025-03-19T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现">实现</h2><p>这是一个基于 <code>ucontext</code> 的轻量级协程库，实现了 <strong>用户态上下文切换</strong>，支持 <strong>非抢占式协程调度</strong>。核心包括 <strong>协程管理（Routine）</strong> 和 <strong>调度器（Schedule）</strong>，采用 <strong>FIFO 调度策略</strong>，协程通过 <code>resume()</code> 切换到运行态，<code>yield()</code> 挂起并交回调度器。</p><ul><li>利用 <code>swapcontext()</code> 进行 <strong>寄存器和栈的上下文切换</strong>，避免线程切换的内核态开销。</li><li>支持 <strong>动态栈管理</strong>，通过 <strong>栈快照（<code>memcpy</code> 保存栈数据）</strong> 实现挂起与恢复。</li><li>适用于 <strong>高并发 IO 场景</strong>，可扩展为 <strong><code>epoll</code> 事件驱动</strong> 结合 <strong>异步 IO</strong>。</li></ul><h3 id="后续优化方向：">后续优化方向：</h3><ul><li><strong>多线程支持（work-stealing）</strong></li><li><strong>使用 <code>boost::context </code> 提升可移植性</strong></li><li><strong>优化调度算法</strong></li></ul><hr><h2 id="亮点">亮点</h2><ul><li><strong>纯用户态调度，低开销，高效执行</strong><ul><li><code>swapcontext()</code> 仅涉及 <strong>寄存器和栈切换</strong>，比 <code>std::thread</code> 的调度更轻量。</li></ul></li><li><strong>使用非抢占式调度，确保任务可控</strong></li><li><strong>采用栈快照（<code>memcpy</code> 备份数据）</strong><ul><li>在 <code>yield()</code> 时存储当前执行状态，<code>resume()</code> 时恢复。</li><li>避免 <code>setjmp/longjmp</code> 传统方法的局限性，提高灵活性和可维护性。</li></ul></li><li><strong>比线程池更轻量</strong><ul><li>避免大量线程带来的上下文切换和同步开销。</li></ul></li></ul><hr><h2 id="难点与解决方案">难点与解决方案</h2><h3 id="1-yield-需要保存协程的执行状态，否则恢复时会丢失现场">1. <code>yield()</code> 需要保存协程的执行状态，否则恢复时会丢失现场</h3><blockquote><p><strong>挑战</strong>：栈是动态增长的，如何正确地保存 &amp; 恢复执行环境？</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>使用 <code>memcpy</code> 备份协程栈</strong><ul><li>在 <code>yield()</code> 时，计算栈使用空间，并将数据拷贝到堆中，防止被覆盖。</li></ul></li><li><strong>动态分配存储空间</strong><ul><li>如果 <code>yield()</code> 时的栈大小变大，重新分配存储，确保数据完整性。</li></ul></li><li><strong>在 <code>resume()</code> 时恢复栈数据</strong><ul><li>然后调用 <code>swapcontext()</code> 切回协程。</li></ul></li></ul><h3 id="2-ucontext-API-兼容性问题">2. <code>ucontext</code> API 兼容性问题</h3><blockquote><p><strong>问题</strong>：未来的 Linux 可能移除 <code>ucontext</code>，如何保持代码的可移植性？</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>切换到 <code>Boost.Context</code></strong></li><li><strong>使用 Linux <code>swapcontext()</code> 替代方案</strong>，如 <code>fibers</code> 或 <code>libco</code>。</li></ul><h3 id="3-协程调度优化">3. 协程调度优化</h3><blockquote><p><strong>问题</strong>：目前是单线程 FIFO 调度，如果协程数量过多，可能出现某些协程长期得不到执行的问题。</p></blockquote><p><strong>优化方案：</strong></p><ul><li><strong>使用时间片调度</strong><ul><li>让 <code>yield()</code> 也能由调度器主动调用，防止某些任务长期占用 CPU。</li></ul></li><li><strong>基于优先级的调度</strong><ul><li>例如高优先级的协程可以优先执行（可结合任务权重机制）。</li></ul></li><li><strong>多线程 Work-Stealing</strong><ul><li>不同线程管理自己的协程池，当某个线程空闲时，可以从别的线程窃取任务，提升 CPU 资源利用率。</li></ul></li></ul><h3 id="4-如何让多个线程安全地调度协程？">4. 如何让多个线程安全地调度协程？</h3><blockquote><p><strong>问题</strong>：目前是单线程，但很多高并发场景需要多个线程并行执行协程。</p></blockquote><p><strong>解决方案：</strong></p><ul><li><strong>多线程调度器（Work-Stealing）</strong><ul><li>每个线程有自己的 <code>Schedule</code>，但可以从别的线程偷取任务。</li></ul></li><li><strong>使用 <code>std::mutex</code> + <code>std::queue</code> 共享任务队列</strong><ul><li>当某个线程空闲时，可以从公共队列取任务。</li></ul></li><li><strong>无锁队列优化（如 MPSC Queue）</strong><ul><li>减少锁的开销，提高并发度。</li></ul></li></ul><hr><h2 id="总结">总结</h2><p>本协程库基于 <code>ucontext</code>，采用 <strong>非抢占式调度</strong>，支持 <strong>栈快照</strong>，适用于高并发 IO 场景。未来可以扩展多线程 <code>work-stealing</code> 以及更优的调度策略，提高整体性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;这是一个基于 &lt;code&gt;ucontext&lt;/code&gt; 的轻量级协程库，实现了 &lt;strong&gt;用户态上下文切换&lt;/strong&gt;，支持 &lt;strong&gt;非抢占式协程调度&lt;/strong&gt;。核心包括 &lt;strong&gt;协程管理（Rou</summary>
      
    
    
    
    <category term="编程" scheme="https://eatbreads.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://eatbreads.github.io/categories/%E7%BC%96%E7%A8%8B/C/"/>
    
    
    <category term="协程" scheme="https://eatbreads.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="ucontext" scheme="https://eatbreads.github.io/tags/ucontext/"/>
    
    <category term="异步IO" scheme="https://eatbreads.github.io/tags/%E5%BC%82%E6%AD%A5IO/"/>
    
  </entry>
  
  <entry>
    <title>使用 vcpkg 运行 redis++ 遇到的问题</title>
    <link href="https://eatbreads.github.io/posts/be1ef227.html"/>
    <id>https://eatbreads.github.io/posts/be1ef227.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>使用 vcpkg 安装 redis++ 库后，发现该库并没有 <code>.cmake</code> 文件，导致 <code>find_package</code> 无法找到它。</p><h2 id="现象分析">现象分析</h2><p>通过 <code>ls</code> 命令查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /root/vcpkg/installed/x64-linux/lib</span><br></pre></td></tr></table></figure><p>可以确认 redis++ 确实已经安装，并且在代码中可以跳转到对应的定义文件。但由于缺少 CMake 配置文件，只能手动指定路径进行连接。<br><img src="https://cdn-a.markji.com/files/67d9717eb49cc95a6c0f4ea3_hd.png?e=1742368508911&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:44busKLsAaG2t2U6WGRFo4uQL4s=" alt="图片1"></p><h2 id="解决尝试">解决尝试</h2><p>尝试手动指定库路径，但在链接时遇到错误，提示找不到某些函数定义，怀疑是动态库和静态库混用的问题。然而最终仍然没有找到具体原因。</p><h2 id="结果总结">结果总结</h2><ol><li><strong>好消息</strong>：redis++ 通过手动指定路径找到了。</li><li><strong>坏消息</strong>：仍然无法正确链接，可能与库的静态/动态方式混用有关。</li></ol><p>最后还是没能解决这个问题，先摆烂了 😭。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;使用 vcpkg 安装 redis++ 库后，发现该库并没有 &lt;code&gt;.cmake&lt;/code&gt; 文件，导致 &lt;code&gt;find_package&lt;/code&gt; 无法找到它。&lt;/p&gt;
&lt;h2 id=&quot;现象分析&quot;&gt;现象分析&lt;</summary>
      
    
    
    
    <category term="C++" scheme="https://eatbreads.github.io/categories/C/"/>
    
    <category term="vcpkg" scheme="https://eatbreads.github.io/categories/C/vcpkg/"/>
    
    <category term="Redis" scheme="https://eatbreads.github.io/categories/C/vcpkg/Redis/"/>
    
    
    <category term="redis++" scheme="https://eatbreads.github.io/tags/redis/"/>
    
    <category term="vcpkg" scheme="https://eatbreads.github.io/tags/vcpkg/"/>
    
    <category term="CMake" scheme="https://eatbreads.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>使用 C++ 运行 Kafka 和 Elasticsearch</title>
    <link href="https://eatbreads.github.io/posts/b71a46cc.html"/>
    <id>https://eatbreads.github.io/posts/b71a46cc.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch-处理方式">Elasticsearch 处理方式</h2><p>Elasticsearch 通常直接使用 HTTP 报文通信，因此不需要额外下载 C++ 库，直接通过 HTTP 请求即可进行操作。</p><h2 id="Kafka-处理方式">Kafka 处理方式</h2><p>Kafka 我使用的是 vcpkg 提供的包，但和之前遇到的问题一样，<code>find_package</code> 无法直接找到，所以还是手动加入了库的路径。<br><img src="https://cdn-a.markji.com/files/67da545476d0a5611b7c05e6_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:OVEEkK8mOAmVOjHyA1CWapEMpvM=" alt="图片1"></p><h2 id="遇到的问题">遇到的问题</h2><ol><li><p><strong>AI 帮的倒忙</strong><br>在调用某个接口时，AI 生成的代码少了两个参数，导致无法正常执行。最后还是我自己手动跳转到定义里查看并修正了。</p></li><li><p><strong>Docker Compose 启动多个容器</strong><br>我使用 <code>docker-compose</code> 一键启动了多个服务，包括 Redis、Kafka 等，但在尝试运行时，Kafka 无法正确收到消息，导致程序无法正常工作。<br><img src="https://cdn-a.markji.com/files/67da6357b49cc95a6c2923c7_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:O71hPvwIkVaNim_dDLTqxlJhPos=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67da644fb49cc95a6c293c85_hd.png?e=1742390400486&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:j5hKpx7807ueI8nBNuZ3yhQu3SA=" alt="图片1"></p></li><li><p><strong>最终解决方案</strong><br>去 CSDN 找了代码，终于能正常执行了，AI 这次还是不行 😓。</p></li></ol><h2 id="总结">总结</h2><ul><li>Elasticsearch 直接用 HTTP 通信，无需额外的 C++ 库。</li><li>Kafka 需要手动指定路径才能使用。</li><li><code>docker-compose</code> 方便管理多个容器，但 Kafka 运行过程中可能遇到无法接收消息的问题。</li><li>代码有问题时，AI 可能会犯病，还是要多检查文档和源码。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Elasticsearch-处理方式&quot;&gt;Elasticsearch 处理方式&lt;/h2&gt;
&lt;p&gt;Elasticsearch 通常直接使用 HTTP 报文通信，因此不需要额外下载 C++ 库，直接通过 HTTP 请求即可进行操作。&lt;/p&gt;
&lt;h2 id=&quot;Kafka-</summary>
      
    
    
    
    <category term="C++" scheme="https://eatbreads.github.io/categories/C/"/>
    
    <category term="Kafka" scheme="https://eatbreads.github.io/categories/C/Kafka/"/>
    
    <category term="Elasticsearch" scheme="https://eatbreads.github.io/categories/C/Kafka/Elasticsearch/"/>
    
    
    <category term="vcpkg" scheme="https://eatbreads.github.io/tags/vcpkg/"/>
    
    <category term="Docker" scheme="https://eatbreads.github.io/tags/Docker/"/>
    
    <category term="分布式" scheme="https://eatbreads.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>消息队列的基础编写</title>
    <link href="https://eatbreads.github.io/posts/be5c987b.html"/>
    <id>https://eatbreads.github.io/posts/be5c987b.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-任务封装">1. 任务封装</h2><p>首先实现了 <code>Task</code> 类，这是一个简单的包裹类，仅包含任务的 <strong>名称</strong> 和 <strong>参数列表</strong>，用于封装任务信息。</p><h2 id="2-任务处理器设计">2. 任务处理器设计</h2><p>为了让任务处理更加模块化，我设计了 <strong>任务处理器抽象基类</strong>，所有具体任务处理方法都需要继承该基类，并重写 <code>process</code> 函数，以实现具体任务的处理逻辑。</p><h2 id="3-处理器注册机制">3. 处理器注册机制</h2><p>然后实现了 <strong>处理器注册类</strong>，用于管理不同任务处理器的映射关系：</p><ul><li><strong>Key</strong>：任务名称</li><li><strong>Value</strong>：对应的任务处理器类</li></ul><p>当需要处理 <code>Task</code> 时，会从注册类中获取与 <code>Task</code> 名称对应的处理器，并传入 <code>Task</code> 进行执行。</p><p><strong>示例流程：</strong><br>如果 <code>Task</code> 是 <strong>A 类型</strong>，注册类会找到 <strong>A 处理器</strong>，然后将 <code>Task</code> 传入处理器以获取参数列表并执行。</p><h2 id="4-单元测试">4. 单元测试</h2><p>代码编写完成后，学习并使用 <strong>Google Test（GTest）</strong> 进行单元测试，以验证任务队列的正确性。</p><hr><h2 id="总结">总结</h2><ul><li><code>Task</code> 作为基础封装类，仅存储名称和参数列表。</li><li>任务处理器通过继承基类实现 <code>process</code> 方法。</li><li>处理器注册类维护任务名称到处理器的映射，实现动态调用。</li><li>使用 Google Test 进行单元测试，提高代码的可靠性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-任务封装&quot;&gt;1. 任务封装&lt;/h2&gt;
&lt;p&gt;首先实现了 &lt;code&gt;Task&lt;/code&gt; 类，这是一个简单的包裹类，仅包含任务的 &lt;strong&gt;名称&lt;/strong&gt; 和 &lt;strong&gt;参数列表&lt;/strong&gt;，用于封装任务信息。&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="C++" scheme="https://eatbreads.github.io/categories/C/"/>
    
    <category term="消息队列" scheme="https://eatbreads.github.io/categories/C/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="设计模式" scheme="https://eatbreads.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="任务队列" scheme="https://eatbreads.github.io/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
    <category term="Google Test" scheme="https://eatbreads.github.io/tags/Google-Test/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 基础知识总结</title>
    <link href="https://eatbreads.github.io/posts/d00def19.html"/>
    <id>https://eatbreads.github.io/posts/d00def19.html</id>
    <published>2025-03-18T16:00:00.000Z</published>
    <updated>2025-03-21T16:02:18.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Kafka-应用场景">1. Kafka 应用场景</h2><p>Kafka 作为一款高吞吐的分布式消息系统，适用于多种应用场景：</p><ul><li><strong>消息队列</strong>：用于解耦生产者和消费者，提高系统的伸缩性。</li><li><strong>日志收集</strong>：集中存储和处理系统日志，方便分析和监控。</li><li><strong>流计算</strong>：处理实时数据流，将数据传输给实时计算系统进行计算。</li><li><strong>事件溯源</strong>：记录事件发生的历史，以便后续回溯和分析。</li><li><strong>Metrics 采集</strong>：收集和存储系统的监控指标数据。</li></ul><hr><h2 id="2-Kafka-组件介绍">2. Kafka 组件介绍</h2><p>Kafka 由多个核心组件组成：</p><ul><li><p><strong>生产者（Producer）</strong>：负责将消息发送到 Kafka。</p></li><li><p><strong>消费者（Consumer）</strong>：从 Kafka 读取消息进行处理。</p></li><li><p><strong>消息代理（Broker）</strong>：存储和管理消息，负责接收、存储和转发数据。</p></li><li><p><strong>协调器（Zookeeper）</strong>：提供分布式协调和管理任务。</p></li><li><p><strong>主题（Topic）</strong>：类似广播频道，生产者将消息发送到指定的 <code>Topic</code>，消费者从 <code>Topic</code> 读取消息。</p><p>创建 Topic 命令示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 3 --topic my-topic</span><br></pre></td></tr></table></figure></li><li><p><strong>分区（Partition）</strong>：一个 <code>Topic</code> 进一步分为多个 <code>Partition</code>，可以提高数据局部性、支持并行处理，实现负载均衡。</p></li></ul><hr><h2 id="3-Kafka-消息有序性">3. Kafka 消息有序性</h2><p>Kafka 的消息处理方式：</p><ul><li><strong>不同分区的消息是并行处理的</strong>，因此 Kafka <strong>全局上不保证消息的有序性</strong>。</li><li><strong>同一分区内的消息是严格有序的</strong>，消费者会按照 <code>offset</code> 依次消费。</li></ul><hr><h2 id="4-Offset（偏移量）">4. Offset（偏移量）</h2><ul><li>Kafka 中的每条消息都有唯一的 <strong>Offset</strong>（偏移量），从 <code>0</code> 开始递增。</li><li>Offset 用于追踪消息消费进度，每个消费者组都会维护自己的 Offset。</li></ul><hr><h2 id="5-Consumer-Group（消费者组）">5. Consumer Group（消费者组）</h2><ul><li><p><strong>一个分区（Partition）只能由一个组员消费</strong>，保证分区数据不会被组内多个消费者重复消费。</p></li><li><p><strong>多个 Consumer Group 可以同时消费同一个 Topic</strong>，不同组之间不会相互影响。例如：</p><ul><li><code>Group A</code> 读取 <code>Topic X</code> 的消息一次。</li><li><code>Group B</code> 也可以独立读取 <code>Topic X</code> 的消息一次。</li></ul></li></ul><p>这样，每个组都可以独立处理相同的消息，实现多用途消费。</p><hr><h2 id="6-总结">6. 总结</h2><ul><li>Kafka 适用于消息队列、日志收集、流计算、事件溯源等场景。</li><li>核心组件包括 Producer、Consumer、Broker、Zookeeper、Topic、Partition 等。</li><li>消息的全局有序性无法保证，但 <strong>同一分区内是有序的</strong>。</li><li>Offset 记录消息的消费进度，每个 Consumer Group 维护自己的 Offset。</li><li>通过 Consumer Group 机制，可以控制消息的分发和重复消费。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Kafka-应用场景&quot;&gt;1. Kafka 应用场景&lt;/h2&gt;
&lt;p&gt;Kafka 作为一款高吞吐的分布式消息系统，适用于多种应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;消息队列&lt;/strong&gt;：用于解耦生产者和消费者，提高系统的伸缩性。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="分布式系统" scheme="https://eatbreads.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Kafka" scheme="https://eatbreads.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Kafka/"/>
    
    
    <category term="消息队列" scheme="https://eatbreads.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="实时流处理" scheme="https://eatbreads.github.io/tags/%E5%AE%9E%E6%97%B6%E6%B5%81%E5%A4%84%E7%90%86/"/>
    
    <category term="大数据" scheme="https://eatbreads.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>docker一点小记录</title>
    <link href="https://eatbreads.github.io/posts/bc68fe1f.html"/>
    <id>https://eatbreads.github.io/posts/bc68fe1f.html</id>
    <published>2025-03-13T14:21:56.000Z</published>
    <updated>2025-03-21T16:02:18.702Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker 基础使用</h1><h2 id="1-Docker-组件">1. Docker 组件</h2><p>Docker 主要由以下三个核心组件组成：</p><ul><li><strong>镜像（Image）</strong>：类似于软件的 <strong>蓝图</strong>，定义了容器运行所需的环境。</li><li><strong>容器（Container）</strong>：基于镜像创建的 <strong>实例</strong>，可以运行应用。</li><li><strong>引擎（Engine）</strong>：Docker 的 <strong>核心管理组件</strong>，负责容器的创建、运行、管理等。</li></ul><hr><h2 id="2-如何构建镜像（Blueprint）">2. 如何构建镜像（Blueprint）</h2><ol><li><strong>编写 <code>Dockerfile</code></strong> 定义镜像构建过程。</li><li><strong>构建镜像</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my_image .</span><br></pre></td></tr></table></figure></li><li><strong>发布镜像</strong>：<ul><li>登录 Docker Hub：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure></li><li>推送镜像：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push my_image</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>使用镜像</strong>：<ul><li>运行容器：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my_container my_image</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="使用-Docker-执行-CI-CD">使用 Docker 执行 CI/CD</h2><p>Docker 可与 <strong>Jenkins</strong>、<strong>GitHub Actions</strong> 结合使用，实现 CI/CD：</p><ul><li><strong>Jenkins</strong> + Docker：用于企业级 CI/CD 自动化部署。</li><li><strong>GitHub Actions</strong>（适用于个人小项目/免费方案）。</li></ul><hr><h2 id="3-查看容器日志">3. 查看容器日志</h2><p>使用 <code>docker logs</code> 命令查看容器日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs my_container</span><br></pre></td></tr></table></figure><p>支持多种日志模式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f my_container  <span class="comment"># 持续查看日志（实时刷新）</span></span><br><span class="line">docker logs --<span class="built_in">tail</span> 100 my_container  <span class="comment"># 查看最后100行日志</span></span><br><span class="line">docker logs --since 10m my_container  <span class="comment"># 查看最近10分钟的日志</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-Docker-数据卷（Volume）">4. Docker 数据卷（Volume）</h2><p>Docker <strong>数据卷</strong> 主要用于持久化存储数据，容器销毁时数据不会丢失。</p><h3 id="1-创建数据卷">1. 创建数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my_data</span><br></pre></td></tr></table></figure><h3 id="2-运行容器并挂载数据卷">2. 运行容器并挂载数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name my_container -v my_data:/app/data nginx</span><br></pre></td></tr></table></figure><h3 id="3-多个容器共享数据卷">3. 多个容器共享数据卷</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name container1 -v my_data:/app/data nginx</span><br><span class="line">docker run -d --name container2 -v my_data:/app/data alpine</span><br></pre></td></tr></table></figure><h3 id="4-查看数据卷信息">4. 查看数据卷信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect my_data</span><br></pre></td></tr></table></figure><hr><h2 id="5-Docker-网络">5. Docker 网络</h2><p>Docker 提供多种 <strong>网络模式</strong>，用于管理容器间的通信：</p><h3 id="1-Bridge（桥接模式）">1. <strong>Bridge（桥接模式）</strong></h3><ul><li><strong>默认模式</strong>，适用于多个容器之间的通信。</li><li>在相同桥接网络的容器可以通过<strong>容器名</strong>互相访问。</li><li>创建桥接网络并将容器连接到该网络：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create my_bridge</span><br><span class="line">docker run -d --name container1 --network my_bridge_network nginx</span><br><span class="line">docker run -d --name container2 --network my_bridge</span><br></pre></td></tr></table></figure></li><li>使用 <strong>Docker Compose</strong> 可以自动创建共享网络，提供<strong>基础的服务发现功能</strong>。</li></ul><h3 id="2-Host（主机模式）">2. <strong>Host（主机模式）</strong></h3><ul><li>容器直接使用 <strong>宿主机的网络</strong>，不做隔离，具有更高的网络性能。</li></ul><h3 id="3-None（无网络）">3. <strong>None（无网络）</strong></h3><ul><li>容器没有任何网络连接，适用于需要完全隔离的环境。</li></ul><h3 id="4-Overlay-网络">4. <strong>Overlay 网络</strong></h3><ul><li>用于 <strong>Docker Swarm</strong> 集群，使多个主机上的容器可相互通信。</li></ul><h3 id="5-Macvlan-模式">5. <strong>Macvlan 模式</strong></h3><ul><li>允许容器直接与宿主机的网络通信，适用于需要独立 <strong>IP 地址</strong> 的场景。</li></ul><hr><h2 id="6-如何优化-Docker-启动时间">6. 如何优化 Docker 启动时间</h2><ol><li><strong>使用较小的基础镜像</strong>（如 <code>alpine</code> 代替 <code>ubuntu</code>）。</li><li><strong>利用构建缓存</strong>：避免每次 <code>docker build</code> 都从头开始构建。</li><li><strong>减少容器层数</strong>：使用多阶段构建来减少镜像大小。</li><li><strong>本地缓存镜像</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull my_image</span><br></pre></td></tr></table></figure></li><li><strong>优化应用启动方式</strong>：如 <strong>多阶段构建</strong>，减少不必要的运行时依赖。</li></ol><hr><h2 id="6-使用-docker-compose">6. 使用 <code>docker-compose</code></h2><p><code>docker-compose</code> 允许用 <strong>YAML 配置文件</strong> 定义多个容器，并通过一个命令启动所有容器：</p><ol><li><strong>编写 <code>docker-compose.yml</code> 文件</strong>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure></li><li><strong>使用 <code>docker-compose</code> 启动容器</strong>：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="6-使用多阶段构建优化镜像体积">6. 使用多阶段构建优化镜像体积</h2><p>多阶段构建可减少最终镜像的大小：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一阶段：构建应用</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.18</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二阶段：创建更小的最终镜像</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /app/mybinary .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./mybinary&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li><strong>第一阶段</strong>：使用完整的 Golang 环境构建二进制文件。</li><li><strong>第二阶段</strong>：使用 <code>alpine</code> 作为基础镜像，仅复制最终生成的二进制文件，减少体积。</li></ul><hr><h2 id="6-Docker-Swarm（集群）">6. Docker Swarm（集群）</h2><p>Docker Swarm 是 Docker 官方提供的 <strong>轻量级容器编排工具</strong>：</p><ul><li>允许将多个 Docker 主机集合成一个<strong>虚拟</strong> Docker 主机。</li><li>适用于 <strong>轻量级的集群管理</strong>，相比 Kubernetes 更加简单易用。</li></ul><hr><h2 id="7-总结">7. 总结</h2><ul><li>Docker 提供了<strong>镜像、容器、网络</strong>等组件，简化应用的<strong>打包、分发、部署</strong>。</li><li>通过 <strong>Dockerfile</strong> 构建自定义镜像，并使用 <strong>Docker Hub</strong> 分发。</li><li>利用 <strong>Docker + CI/CD 工具</strong>（如 <strong>Jenkins</strong>、<strong>GitHub Actions</strong>），可实现自动化部署。</li><li>通过 <strong>Docker Compose</strong> 快速启动多容器应用，简化管理。</li><li>使用 <strong>多阶段构建</strong> 可 <strong>优化镜像体积</strong>，提高拉取与启动速度。</li><li><strong>优化启动时间</strong> 可以通过：<ul><li>选择较小的基础镜像。</li><li>减少不必要的层数。</li><li>使用本地缓存提高构建效率。</li></ul></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Docker 基础使用&lt;/h1&gt;
&lt;h2 id=&quot;1-Docker-组件&quot;&gt;1. Docker 组件&lt;/h2&gt;
&lt;p&gt;Docker 主要由以下三个核心组件组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;镜像（Image）&lt;/strong&gt;：类似于软件的 &lt;strong&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis八股文</title>
    <link href="https://eatbreads.github.io/posts/c74dfdcd.html"/>
    <id>https://eatbreads.github.io/posts/c74dfdcd.html</id>
    <published>2025-03-13T14:11:08.000Z</published>
    <updated>2025-03-21T16:02:18.713Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Redis 基础使用</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 进入 Redis 终端</span></span><br><span class="line">使用 <span class="code">`redis-cli`</span> 进入 Redis 交互终端。</span><br><span class="line"></span><br><span class="line"><span class="section">## Redis 支持的数据类型</span></span><br><span class="line">Redis 支持五种数据类型：</span><br><span class="line"><span class="bullet">-</span> <span class="strong">**String**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Hash**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**List**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Set**</span></span><br><span class="line"><span class="bullet">-</span> <span class="strong">**Sorted Set（有序集合）**</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1. String</span></span><br><span class="line"><span class="code">```sh</span></span><br><span class="line"><span class="code">set name mike</span></span><br><span class="line"><span class="code">get name</span></span><br><span class="line"><span class="code">del name</span></span><br></pre></td></tr></table></figure><h3 id="2-Hash">2. Hash</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset user name Alice</span><br><span class="line">hget user name</span><br><span class="line">hgetall user</span><br><span class="line">hdel user name</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> <code>user</code> 在这里是表名，<code>name</code> 是 key。</p></blockquote><h3 id="3-List">3. List</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lpush queue task</span><br><span class="line">rpush queue task</span><br><span class="line">lpop queue</span><br><span class="line">rpop queue</span><br><span class="line">lrange queue 0 -1</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> <code>-1</code> 表示倒数第一个，<code>lrange queue 0 -1</code> 表示遍历从 <code>0</code> 到最后一个元素。</p></blockquote><h3 id="4-Set">4. Set</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd myset a</span><br><span class="line">sadd myset b</span><br><span class="line">sadd myset c</span><br><span class="line">smembers myset</span><br><span class="line">srem myset a</span><br></pre></td></tr></table></figure><h3 id="5-Sorted-Set">5. Sorted Set</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zadd scores 100 Alice</span><br><span class="line">zadd scores 200 Bob</span><br><span class="line">zrange scores 0 -1 withscores</span><br><span class="line">zrevrange scores 0 -1 withscores</span><br><span class="line">zrem scores Alice</span><br></pre></td></tr></table></figure><blockquote><p><strong>PS:</strong> 有序集合插入时需要提供权重值，<code>withscores</code> 表示按照权重遍历。</p></blockquote><hr><h2 id="配置文件位置">配置文件位置</h2><ul><li>配置文件路径：<code>/etc/redis/redis.conf</code></li><li>修改配置后需要重启 Redis：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart redis</span><br></pre></td></tr></table></figure></li><li>该配置文件可用于编辑 <strong>持久化</strong> 设置。</li></ul><hr><h2 id="Redis-持久化">Redis 持久化</h2><h3 id="1-RDB-快照持久化（保存数据到磁盘）">1. RDB 快照持久化（保存数据到磁盘）</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1   <span class="comment"># 900 秒（15 分钟）至少有 1 次写入操作，就保存 RDB</span></span><br><span class="line">save 300 10  <span class="comment"># 300 秒（5 分钟）至少有 10 次写入操作，就保存 RDB</span></span><br><span class="line">save 60 10000 <span class="comment"># 60 秒内有 10000 次写入操作，就保存 RDB</span></span><br></pre></td></tr></table></figure><h3 id="2-AOF-日志持久化">2. AOF 日志持久化</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span>   <span class="comment"># 启用 AOF</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>  <span class="comment"># AOF 文件名</span></span><br></pre></td></tr></table></figure><hr><h2 id="Redis-使用场景">Redis 使用场景</h2><ol><li><p><strong>缓存</strong></p><ul><li>存储常用数据，如页面渲染等。</li></ul></li><li><p><strong>实时系统</strong></p><ul><li>统计网站点击率、实时排行榜、点赞功能等。</li></ul></li><li><p><strong>消息队列</strong></p><ul><li>使用 <code>List</code> 和 <code>Pub/Sub</code> 可实现轻量级消息队列。</li></ul></li><li><p><strong>分布式锁</strong></p><ul><li>本质上与消息队列功能类似，可用于分布式环境下的锁管理。</li></ul></li><li><p><strong>计数器</strong></p><ul><li>Redis 具有原子操作能力，适合作为计数器，例如在线人数统计等。</li></ul></li></ol><hr><h2 id="Redis-为什么这么快？">Redis 为什么这么快？</h2><ol><li><strong>数据存储在内存</strong>（而非磁盘）。</li><li><strong>使用高效的数据结构</strong> 进行数据存储和查找。</li><li><strong>单线程 + I/O 多路复用</strong>，避免了多线程的上下文切换，提高性能。</li></ol><hr><h2 id="为什么-Redis-采用单线程？">为什么 Redis 采用单线程？</h2><ul><li>Redis 的瓶颈不在 <strong>CPU</strong>，而在 <strong>网络 I/O 和键值对操作</strong>，因此使用单线程处理请求。</li><li>持久化等操作由后台线程完成，并不会影响主线程的处理性能。</li></ul><hr><h2 id="Redis-跳表实现">Redis 跳表实现</h2><p>（略）</p><hr><h2 id="Redis-和-Memcached-的区别">Redis 和 Memcached 的区别</h2><table><thead><tr><th>特性</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>数据类型</td><td>丰富（String、Hash、List、Set、Sorted Set）</td><td>仅支持键值对（K-V）</td></tr><tr><td>持久化</td><td>支持（RDB、AOF）</td><td>不支持</td></tr><tr><td>事务</td><td>支持（但不支持回滚）</td><td>不支持</td></tr><tr><td>内存占用</td><td>较高</td><td>较低</td></tr><tr><td>速度</td><td>快</td><td>更快</td></tr><tr><td>使用场景</td><td>多种（缓存、队列、分布式锁等）</td><td>主要用于缓存</td></tr></tbody></table><hr><h2 id="Redis-事务-vs-MySQL-事务">Redis 事务 vs MySQL 事务</h2><ul><li>Redis 事务本质上是 <strong>多个命令的原子性执行</strong>，执行期间不会被打断。</li><li>但 Redis <strong>不支持事务回滚</strong>，一旦执行，无法撤销。</li></ul><hr><blockquote><p><strong>PS:</strong> <code>-1</code> 表示倒数第一个，范围遍历 <code>0</code> 到最后一个元素。<br><strong>PS:</strong> <code>user</code> 在这里是表名，<code>name</code> 是 key。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cl</summary>
      
    
    
    
    
  </entry>
  
</feed>
