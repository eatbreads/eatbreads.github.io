<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到小面包的小站🥝</title>
  
  
  <link href="https://eatbreads.github.io/atom.xml" rel="self"/>
  
  <link href="https://eatbreads.github.io/"/>
  <updated>2025-04-23T15:43:58.533Z</updated>
  <id>https://eatbreads.github.io/</id>
  
  <author>
    <name>小面包🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>比特币简易实现代码(一)：基础结构</title>
    <link href="https://eatbreads.github.io/posts/460941b6.html"/>
    <id>https://eatbreads.github.io/posts/460941b6.html</id>
    <published>2025-04-23T15:40:50.000Z</published>
    <updated>2025-04-23T15:43:58.533Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比特币核心结构实现"><a href="#比特币核心结构实现" class="headerlink" title="比特币核心结构实现"></a>比特币核心结构实现</h1><h3 id="1-区块结构设计"><a href="#1-区块结构设计" class="headerlink" title="1. 区块结构设计"></a>1. 区块结构设计</h3><ul><li>定义Block结构体，包含时间戳、前哈希、数据和当前哈希</li><li>实现计算当前哈希的方法</li></ul><h3 id="2-区块链设计"><a href="#2-区块链设计" class="headerlink" title="2. 区块链设计"></a>2. 区块链设计</h3><ul><li>定义Blockchain结构体，包含区块数组</li><li>实现添加区块的方法</li><li>实现创世块生成功能</li></ul><h3 id="3-工作量证明机制"><a href="#3-工作量证明机制" class="headerlink" title="3. 工作量证明机制"></a>3. 工作量证明机制</h3><ul><li>定义ProofOfWork结构体，包含区块引用和目标值</li><li>实现构造函数，设置难度目标</li><li>实现数据准备方法</li><li>实现挖矿运行方法</li><li>实现有效性验证</li></ul><p>9.修改addblock函数,在其中调用工作量证明,run成功了才执行添加</p><p>10.定义确认区块有效区块,确认一下之前Run不是因为溢出而结束</p><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> chrono::Utc;</span><br><span class="line"><span class="keyword">use</span> sha2::&#123;Sha256, Digest&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    timestamp: <span class="type">i64</span>,</span><br><span class="line">    prev_hash: <span class="type">String</span>,</span><br><span class="line">    hash: <span class="type">String</span>,</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Block</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">calculate_hash</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.timestamp, <span class="keyword">self</span>.prev_hash, <span class="keyword">self</span>.data);</span><br><span class="line">        hasher.<span class="title function_ invoke__">update</span>(data);</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, hasher.<span class="title function_ invoke__">finalize</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区块链结构"><a href="#区块链结构" class="headerlink" title="区块链结构"></a>区块链结构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Blockchain</span> &#123;</span><br><span class="line">    blocks: <span class="type">Vec</span>&lt;Block&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Blockchain</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">chain</span> = Blockchain &#123;</span><br><span class="line">            blocks: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        chain.<span class="title function_ invoke__">create_genesis_block</span>();</span><br><span class="line">        chain</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create_genesis_block</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">genesis</span> = Block &#123;</span><br><span class="line">            timestamp: Utc::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">timestamp</span>(),</span><br><span class="line">            prev_hash: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;0&quot;</span>),</span><br><span class="line">            data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Genesis Block&quot;</span>),</span><br><span class="line">            hash: <span class="type">String</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hash</span> = genesis.<span class="title function_ invoke__">calculate_hash</span>();</span><br><span class="line">        <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">push</span>(Block &#123;</span><br><span class="line">            hash,</span><br><span class="line">            ..genesis</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作量证明实现"><a href="#工作量证明实现" class="headerlink" title="工作量证明实现"></a>工作量证明实现</h2><h3 id="PoW结构"><a href="#PoW结构" class="headerlink" title="PoW结构"></a>PoW结构</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ProofOfWork</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    block: &amp;<span class="symbol">&#x27;a</span> Block,</span><br><span class="line">    target: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ProofOfWork&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(block: &amp;<span class="symbol">&#x27;a</span> Block) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="comment">// 设置难度目标：前5位为0</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">target</span> = <span class="string">&quot;00000&quot;</span>.<span class="title function_ invoke__">to_string</span>() + &amp;<span class="string">&quot;f&quot;</span>.<span class="title function_ invoke__">repeat</span>(<span class="number">59</span>);</span><br><span class="line">        ProofOfWork &#123; block, target &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">prepare_data</span>(&amp;<span class="keyword">self</span>, nonce: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.block.timestamp,</span><br><span class="line">            <span class="keyword">self</span>.block.prev_hash,</span><br><span class="line">            <span class="keyword">self</span>.block.data,</span><br><span class="line">            nonce</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> (<span class="type">i64</span>, <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">nonce</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">max_nonce</span> = <span class="type">i64</span>::MAX;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hash</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> nonce &lt; max_nonce &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_data</span>(nonce);</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">            hasher.<span class="title function_ invoke__">update</span>(data);</span><br><span class="line">            hash = <span class="built_in">format!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, hasher.<span class="title function_ invoke__">finalize</span>());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> hash &lt; <span class="keyword">self</span>.target &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nonce += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (nonce, hash)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">validate</span>(&amp;<span class="keyword">self</span>, nonce: <span class="type">i64</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_data</span>(nonce);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = Sha256::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        hasher.<span class="title function_ invoke__">update</span>(data);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hash</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, hasher.<span class="title function_ invoke__">finalize</span>());</span><br><span class="line">        hash &lt; <span class="keyword">self</span>.target</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加新区块"><a href="#添加新区块" class="headerlink" title="添加新区块"></a>添加新区块</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Blockchain</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_block</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, data: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">prev_block</span> = <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">new_block</span> = Block &#123;</span><br><span class="line">            timestamp: Utc::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">timestamp</span>(),</span><br><span class="line">            prev_hash: prev_block.hash.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">            data,</span><br><span class="line">            hash: <span class="type">String</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pow</span> = ProofOfWork::<span class="title function_ invoke__">new</span>(&amp;new_block);</span><br><span class="line">        <span class="keyword">let</span> (nonce, hash) = pow.<span class="title function_ invoke__">run</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pow.<span class="title function_ invoke__">validate</span>(nonce) &#123;</span><br><span class="line">            <span class="keyword">self</span>.blocks.<span class="title function_ invoke__">push</span>(Block &#123;</span><br><span class="line">                hash,</span><br><span class="line">                ..new_block</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现：</p><ol><li>使用Rust的类型系统确保内存安全</li><li>采用trait实现更好的代码组织</li><li>使用chrono处理时间戳</li><li>使用sha2进行哈希计算</li><li>所有字符串采用String类型，避免字符串切片的生命周期问题</li></ol><p>要使用这段代码，需要在Cargo.toml中添加以下依赖：<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">chrono</span> = <span class="string">&quot;0.4&quot;</span></span><br><span class="line"><span class="attr">sha2</span> = <span class="string">&quot;0.10&quot;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">使用Rust实现比特币的基础结构，包括区块、区块链、工作量证明等核心概念的代码实现</summary>
    
    
    
    <category term="区块链技术" scheme="https://eatbreads.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://eatbreads.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Rust" scheme="https://eatbreads.github.io/tags/Rust/"/>
    
    <category term="比特币" scheme="https://eatbreads.github.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>区块链与比特币原理简述</title>
    <link href="https://eatbreads.github.io/posts/3fc00ad7.html"/>
    <id>https://eatbreads.github.io/posts/3fc00ad7.html</id>
    <published>2025-04-23T15:38:12.000Z</published>
    <updated>2025-04-23T15:43:58.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="区块链基础知识"><a href="#区块链基础知识" class="headerlink" title="区块链基础知识"></a>区块链基础知识</h1><h2 id="区块结构"><a href="#区块结构" class="headerlink" title="区块结构"></a>区块结构</h2><p>简易版区块包含以下内容：</p><ul><li>时间戳</li><li>前哈希</li><li>当前哈希</li><li>实际data（交易信息）</li></ul><h3 id="哈希计算"><a href="#哈希计算" class="headerlink" title="哈希计算"></a>哈希计算</h3><p>当前哈希的计算方法：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当前哈希 = <span class="type">SHA256</span>(时间戳 + 前哈希 + 实际<span class="class"><span class="keyword">data</span>)</span></span><br></pre></td></tr></table></figure></p><h3 id="本质特征"><a href="#本质特征" class="headerlink" title="本质特征"></a>本质特征</h3><p>区块链本质是一个分布式数据库，每个区块通过哈希值链接到前一个区块。</p><h2 id="共识机制"><a href="#共识机制" class="headerlink" title="共识机制"></a>共识机制</h2><h3 id="为什么需要共识"><a href="#为什么需要共识" class="headerlink" title="为什么需要共识"></a>为什么需要共识</h3><ul><li>区块链是分布式数据库</li><li>没有中心化控制者</li><li>新区块的加入需要其他参与者同意</li></ul><h3 id="工作量证明-PoW"><a href="#工作量证明-PoW" class="headerlink" title="工作量证明(PoW)"></a>工作量证明(PoW)</h3><p>需要完成繁重的计算工作才能获得添加新区块的权力。</p><h2 id="哈希函数应用"><a href="#哈希函数应用" class="headerlink" title="哈希函数应用"></a>哈希函数应用</h2><p>哈希函数主要用途：</p><ul><li>检测数据一致性</li><li>验证文件完整性</li><li>建立数据与哈希值的一一对应关系</li></ul><h2 id="比特币挖矿算法"><a href="#比特币挖矿算法" class="headerlink" title="比特币挖矿算法"></a>比特币挖矿算法</h2><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><ol><li>组合数据：<ul><li>时间戳</li><li>前哈希</li><li>实际data</li></ul></li><li>使用计数器(nonce)递增</li><li>不断计算哈希值</li><li>直到找到符合条件的结果</li></ol><h3 id="难度要求"><a href="#难度要求" class="headerlink" title="难度要求"></a>难度要求</h3><ul><li>目标：哈希值前20位为0</li><li>成功概率：1/2^20</li><li>验证方法：比较哈希值是否小于0x000000…</li></ul><p>ps：nonce是一个密码学术语，在这里作为计数器使用。</p>]]></content>
    
    
    <summary type="html">简要介绍区块链基础知识和比特币工作量证明算法的核心原理</summary>
    
    
    
    <category term="区块链技术" scheme="https://eatbreads.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="区块链" scheme="https://eatbreads.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="比特币" scheme="https://eatbreads.github.io/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
    <category term="加密货币" scheme="https://eatbreads.github.io/tags/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>音视频开发常见面试题解析(一)</title>
    <link href="https://eatbreads.github.io/posts/ee93bc5b.html"/>
    <id>https://eatbreads.github.io/posts/ee93bc5b.html</id>
    <published>2025-04-20T15:37:56.000Z</published>
    <updated>2025-04-20T15:39:10.894Z</updated>
    
    <content type="html"><![CDATA[<h1>音视频开发核心问题解析</h1><h2 id="解码与渲染流程">解码与渲染流程</h2><h3 id="解码过程">解码过程</h3><ul><li>H.264解码输出：YUV420P/YUV格式</li><li>AAC解码输出：PCM格式</li></ul><h3 id="渲染实现">渲染实现</h3><ul><li>使用OpenGL将YUV分量上传为纹理</li><li>通过着色器完成YUV到RGB的转换</li></ul><h3 id="音视频同步">音视频同步</h3><ul><li>利用帧的PTS做时钟同步</li></ul><h3 id="音频帧丢失处理">音频帧丢失处理</h3><ol><li><p>视频丢帧方案</p><ul><li>丢弃部分视频帧使视频追上音频</li></ul></li><li><p>音频补偿方案</p><ul><li>填充静音或插值补足缺失片段</li><li>适用于不允许丢视频帧的场景</li></ul></li><li><p>动态速率调整</p><ul><li>通过加快或减慢视频播放重新同步</li></ul></li></ol><p>注：丢帧或填充静音是直播场景下最常用的方案</p><h2 id="花屏问题处理">花屏问题处理</h2><h3 id="产生原因">产生原因</h3><ol><li><p>关键帧丢失</p><ul><li>导致后续B帧和P帧无法显示</li></ul></li><li><p>元数据变化</p><ul><li>分辨率、帧率、编码格式等参数变化</li><li>播放器适应问题</li></ul></li><li><p>硬件兼容性</p><ul><li>主要出现在安卓设备</li></ul></li><li><p>颜色格式不一致</p><ul><li>推流和播放端格式不匹配</li></ul></li></ol><h3 id="解决方案">解决方案</h3><ol><li><p>丢帧处理优化</p><ul><li>必须丢帧时应丢弃整个GOP</li></ul></li><li><p>参数稳定性</p><ul><li>保持直播编码参数稳定</li></ul></li><li><p>解码方案调整</p><ul><li>尝试软解码对比</li><li>建立设备兼容性名单</li></ul></li><li><p>格式统一</p><ul><li>统一推流和拉流的颜色格式</li></ul></li></ol><h2 id="跳帧问题分析">跳帧问题分析</h2><h3 id="原因分析">原因分析</h3><ol><li>帧率与刷新率不匹配</li><li>解码/渲染性能不足</li><li>网络抖动影响</li><li>音视频同步机制问题</li></ol><h2 id="服务器性能评估">服务器性能评估</h2><h3 id="测试维度">测试维度</h3><ol><li><p>并发能力</p><ul><li>同时观看和推流路数</li></ul></li><li><p>带宽评估</p><ul><li>总出口带宽</li><li>CDN分发能力</li></ul></li><li><p>转码负载</p><ul><li>CPU/GPU资源评估</li></ul></li><li><p>系统稳定性</p><ul><li>端到端延迟</li><li>丢包率</li><li>故障恢复能力</li></ul></li></ol><h2 id="IPC摄像头方案">IPC摄像头方案</h2><h3 id="设备来源">设备来源</h3><ol><li>自研/ODM</li><li>第三方厂商（海康、大华等）</li></ol><h3 id="通信协议">通信协议</h3><ol><li><p>RTSP+RTP</p><ul><li>主流摄像头默认支持</li></ul></li><li><p>GB28181</p><ul><li>国内安防标准</li><li>SIP 5060端口注册</li></ul></li><li><p>ONVIF</p><ul><li>国际通用协议</li><li>支持设备发现和控制</li></ul></li></ol><h2 id="音视频平台架构">音视频平台架构</h2><h3 id="核心模块">核心模块</h3><ol><li><p>用户权限模块</p><ul><li>登录认证</li><li>鉴权管理</li><li>Token管理</li></ul></li><li><p>前端/客户端</p><ul><li>播放功能</li><li>管理交互</li></ul></li><li><p>流媒体服务</p><ul><li>推流/拉流</li><li>协议转发</li><li>转码支持</li></ul></li><li><p>存储服务</p><ul><li>录像保存</li><li>截图存储</li><li>检索回放</li></ul></li><li><p>设备管理</p><ul><li>摄像头注册</li><li>状态监控</li><li>控制命令下发</li></ul></li></ol>]]></content>
    
    
    <summary type="html">详细解析音视频开发中的常见面试题，包括解码渲染、音视频同步、花屏处理等核心问题</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="面试题" scheme="https://eatbreads.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>c++高性能定时器实现</title>
    <link href="https://eatbreads.github.io/posts/9b96a9aa.html"/>
    <id>https://eatbreads.github.io/posts/9b96a9aa.html</id>
    <published>2025-04-19T15:40:01.000Z</published>
    <updated>2025-04-19T15:43:52.439Z</updated>
    
    <content type="html"><![CDATA[<h1>直接上代码</h1><ul><li>分为两种,一种是多线程,一种是时间线</li></ul><p><img src="https://cdn-a.markji.com/files/665d1b26a552a1096b431e0a_hd.png?e=1745079714430&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:T3e2SKI2rJZDxMbrZUMOE08y7xU=" alt="图片1"><br>多线程<br><img src="https://cdn-a.markji.com/files/665d1c76a552a1096b434126_hd.png?e=1745079714430&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:aUtkOolbkxAQmAYlIALpGfsQI7E=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/665d1c856c5f0515e269b414_hd.png?e=1745079714430&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:yo_YNaaP25uc9dTjrUv40gzObRg=" alt="图片1"><br>时间线<br><img src="https://cdn-a.markji.com/files/665d1c9fa552a1096b4343fc_hd.png?e=1745079714430&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:23Ja14SqyjRKfF6hreKLzGv9OsI=" alt="图片1"><br>二更：这边大于now就会直接退出，因为multmap是递增排序，后续的肯定也是大于的</p><p>然后这个内层if是处理新加的timer是否要处理的操作</p><p><img src="https://cdn-a.markji.com/files/665d1caca552a1096b4344dd_hd.png?e=1745079714431&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:bIH2WjAE2GeEgWkSotaPDXkV4p0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/665d1cbba552a1096b434603_hd.png?e=1745079714431&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:H95QUaSiuHzo-ic0ssQCXDKcoL0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/665d1cc7a552a1096b4346b0_hd.png?e=1745079714431&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:EGFfv1vxmawSyr-fg_GFmsuZz9o=" alt="图片1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;直接上代码&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;分为两种,一种是多线程,一种是时间线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-a.markji.com/files/665d1b26a552a1096b431e0a_hd.png?e=17450797</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>WebRTC的JavaScript简单实现</title>
    <link href="https://eatbreads.github.io/posts/e8866bd2.html"/>
    <id>https://eatbreads.github.io/posts/e8866bd2.html</id>
    <published>2025-04-17T12:26:35.000Z</published>
    <updated>2025-04-17T15:28:53.308Z</updated>
    
    <content type="html"><![CDATA[<h1>WebRTC视频聊天实现</h1><h2 id="核心功能实现">核心功能实现</h2><h3 id="1-请求访问用户设备">1. 请求访问用户设备</h3><p>使用<code>navigator.mediaDevices.getUserMedia()</code>请求访问用户的摄像头和麦克风</p><h3 id="2-创建Peer连接">2. 创建Peer连接</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peer = <span class="keyword">new</span> <span class="title class_">Peer</span>();</span><br><span class="line">peer.<span class="title function_">on</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="comment">// 连接成功后获取ID</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-监听外部连接">3. 监听外部连接</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">peer.<span class="title function_">on</span>(<span class="string">&#x27;call&#x27;</span>, <span class="keyword">function</span>(<span class="params">call</span>) &#123;</span><br><span class="line">    <span class="comment">// 监听来电</span></span><br><span class="line">    call.<span class="title function_">answer</span>(localStream);  <span class="comment">// 回复并发送本地视频流</span></span><br><span class="line">    call.<span class="title function_">on</span>(<span class="string">&#x27;stream&#x27;</span>, <span class="keyword">function</span>(<span class="params">remoteStream</span>) &#123;</span><br><span class="line">        <span class="comment">// 监听对方的远程视频流</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-发起通信">4. 发起通信</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer.<span class="title function_">call</span>(remoteId, localStream);</span><br></pre></td></tr></table></figure><h2 id="完整代码实现">完整代码实现</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>视频聊天<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/peerjs/1.3.1/peerjs.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>本地视频<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;localVideo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 400px;height: 300px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: left&quot;</span>&gt;</span></span><br><span class="line">    自己ID<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myPeerid&quot;</span>/&gt;</span>(自动获取)</span><br><span class="line">    对方ID<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;youPeerid&quot;</span>/&gt;</span>(请手动输入)</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;callBtn&quot;</span>&gt;</span>聊天<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>远程视频<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;remoteVideo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 400px;height: 300px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//访问用户媒体设备的兼容方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getUserMedia</span>(<span class="params">constrains,success,error</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(navigator.<span class="property">mediaDevices</span>.<span class="property">getUserMedia</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//最新标准API</span></span></span><br><span class="line"><span class="language-javascript">            navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(constrains).<span class="title function_">then</span>(success).<span class="title function_">catch</span>(error);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.<span class="property">webkitGetUserMedia</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//webkit内核浏览器</span></span></span><br><span class="line"><span class="language-javascript">            navigator.<span class="title function_">webkitGetUserMedia</span>(constrains).<span class="title function_">then</span>(success).<span class="title function_">catch</span>(error);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.<span class="property">mozGetUserMedia</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//Firefox浏览器</span></span></span><br><span class="line"><span class="language-javascript">            navagator.<span class="title function_">mozGetUserMedia</span>(constrains).<span class="title function_">then</span>(success).<span class="title function_">catch</span>(error);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.<span class="property">getUserMedia</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//旧版API</span></span></span><br><span class="line"><span class="language-javascript">            navigator.<span class="title function_">getUserMedia</span>(constrains).<span class="title function_">then</span>(success).<span class="title function_">catch</span>(error);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> localVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video#localVideo&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> remoteVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video#remoteVideo&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> localStream = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取本地媒体流</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">getUserMedia</span>(&#123;<span class="attr">video</span>: <span class="literal">true</span>, <span class="attr">audio</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">stream</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            localStream = stream;</span></span><br><span class="line"><span class="language-javascript">            localVideo.<span class="property">srcObject</span> = stream;</span></span><br><span class="line"><span class="language-javascript">            localVideo.<span class="property">autoplay</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            localVideo.<span class="title function_">play</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Failed to get local stream&#x27;</span> ,err);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建Peer连接</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> peer = <span class="keyword">new</span> <span class="title class_">Peer</span>();</span></span><br><span class="line"><span class="language-javascript">        peer.<span class="title function_">on</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span>(<span class="params">id</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#myPeerid&quot;</span>).<span class="title function_">val</span>(id);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 监听呼叫</span></span></span><br><span class="line"><span class="language-javascript">        peer.<span class="title function_">on</span>(<span class="string">&#x27;call&#x27;</span>, <span class="keyword">function</span>(<span class="params">call</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            call.<span class="title function_">answer</span>(localStream);</span></span><br><span class="line"><span class="language-javascript">            call.<span class="title function_">on</span>(<span class="string">&#x27;stream&#x27;</span>, <span class="keyword">function</span>(<span class="params">remoteStream</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(remoteStream);</span></span><br><span class="line"><span class="language-javascript">                remoteVideo.<span class="property">srcObject</span> = remoteStream;</span></span><br><span class="line"><span class="language-javascript">                remoteVideo.<span class="property">autoplay</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 发起呼叫</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&#x27;#callBtn&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> remoteId = $(<span class="string">&quot;#youPeerid&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(remoteId == <span class="string">&quot;&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;请输入对方ID&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> call = peer.<span class="title function_">call</span>(remoteId, localStream);</span></span><br><span class="line"><span class="language-javascript">            call.<span class="title function_">on</span>(<span class="string">&#x27;stream&#x27;</span>, <span class="keyword">function</span>(<span class="params">remoteStream</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(remoteStream);</span></span><br><span class="line"><span class="language-javascript">                remoteVideo.<span class="property">srcObject</span> = remoteStream;</span></span><br><span class="line"><span class="language-javascript">                remoteVideo.<span class="property">autoplay</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            call.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;call close&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                _this.<span class="property">loading</span>.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">            call.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span></span><br><span class="line"><span class="language-javascript">                _this.<span class="property">loading</span>.<span class="title function_">close</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="功能说明">功能说明</h2><ol><li>页面加载后自动请求摄像头权限</li><li>连接成功后自动获取并显示本地ID</li><li>输入对方ID后可发起视频通话</li><li>支持接收对方视频通话请求</li><li>自动显示本地和远程视频流</li></ol><h2 id="兼容性处理">兼容性处理</h2><p>代码中包含了对不同浏览器的兼容处理：</p><ul><li>最新标准API</li><li>webkit内核浏览器</li><li>Firefox浏览器</li><li>旧版API</li></ul>]]></content>
    
    
    <summary type="html">使用JavaScript实现基于WebRTC的视频聊天功能，包括获取媒体流、建立P2P连接等核心功能</summary>
    
    
    
    <category term="前端开发" scheme="https://eatbreads.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="WebRTC" scheme="https://eatbreads.github.io/tags/WebRTC/"/>
    
    <category term="JavaScript" scheme="https://eatbreads.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>常见的封装格式mp4,flv,hls</title>
    <link href="https://eatbreads.github.io/posts/109395ab.html"/>
    <id>https://eatbreads.github.io/posts/109395ab.html</id>
    <published>2025-04-16T15:51:09.000Z</published>
    <updated>2025-04-17T06:55:21.315Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>直播协议摘要介绍RTMP-HTTP-FLV-WebRTC-RTSP等</title>
    <link href="https://eatbreads.github.io/posts/c0a1f903.html"/>
    <id>https://eatbreads.github.io/posts/c0a1f903.html</id>
    <published>2025-04-16T15:43:36.000Z</published>
    <updated>2025-04-16T15:50:05.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="音视频协议详解"><a href="#音视频协议详解" class="headerlink" title="音视频协议详解"></a>音视频协议详解</h1><h2 id="RTMP-HTTP-FLV"><a href="#RTMP-HTTP-FLV" class="headerlink" title="RTMP/HTTP-FLV"></a>RTMP/HTTP-FLV</h2><p>这两种协议都建立在FLV封装之上，且一般不写入磁盘，仅在内存中交换。</p><h3 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h3><ul><li>用于直播源推流和系统内直播流数据传递</li><li>端口号1935，建立TCP长连接</li><li>延迟一般为1~3s</li><li>推流地址和播放地址相同</li><li>存在高并发问题</li><li>因浏览器摒弃flash，主要用于直播源推流和CDN推流</li><li>强制切片以保证实时性和弱网抵抗能力，但有性能损耗</li></ul><h3 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP-FLV"></a>HTTP-FLV</h3><ul><li>主要用于客户端观看</li><li>是RTMP的HTTP版本</li><li>网页需要引入flv.js才能播放</li></ul><h2 id="WebRTC协议"><a href="#WebRTC协议" class="headerlink" title="WebRTC协议"></a>WebRTC协议</h2><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><ul><li>Web Real-Time Communication</li><li>允许浏览器之间直接连接</li><li>延迟低于1s，使用UDP通道</li><li>推拉流地址格式：<code>webrtc://127.0.0.1:8000/live</code></li></ul><h3 id="连接机制"><a href="#连接机制" class="headerlink" title="连接机制"></a>连接机制</h3><ol><li>点对点协议(PPP)</li><li>需要信令服务器作为初始中转</li><li>信令内容包括：<ul><li>媒体流元数据</li><li>网络数据信息</li></ul></li></ol><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><ol><li>本地局域网直接通信</li><li>通过STUN服务器获取公网IP</li><li>TURN服务器作为备选方案</li></ol><h3 id="多对多通信模式"><a href="#多对多通信模式" class="headerlink" title="多对多通信模式"></a>多对多通信模式</h3><ol><li><p>Mesh模式</p><ul><li>优点：实现简单</li><li>缺点：仅支持4-6人</li></ul></li><li><p>MCU模式</p><ul><li>优点：支持多人</li><li>缺点：服务器压力大</li></ul></li><li><p>SFU模式</p><ul><li>优点：服务器压力适中</li><li>缺点：带宽消耗大</li><li>适用于一对多通信</li></ul></li></ol><h2 id="RTSP协议"><a href="#RTSP协议" class="headerlink" title="RTSP协议"></a>RTSP协议</h2><ul><li>主要用于摄像头/监控设备</li><li>支持TCP/UDP切换</li><li>支持推流拉流</li><li>支持点播直播</li><li>现代浏览器不支持</li></ul><h2 id="直播系统架构"><a href="#直播系统架构" class="headerlink" title="直播系统架构"></a>直播系统架构</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直播源 -&gt; 服务器<span class="number">1</span> -&gt; 转码处理 -&gt; 服务器<span class="number">2</span> -&gt; 客户端</span><br></pre></td></tr></table></figure><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><ul><li>支持转码处理</li><li>支持水印添加</li><li>支持清晰度转换</li><li>支持码率限制</li><li>支持直播录像</li></ul><h2 id="封装格式对比"><a href="#封装格式对比" class="headerlink" title="封装格式对比"></a>封装格式对比</h2><h3 id="MP4"><a href="#MP4" class="headerlink" title="MP4"></a>MP4</h3><ul><li>支持自定义封面</li><li>树状结构数据块</li><li>主要数据块：<ul><li>ftyp：编码格式信息</li><li>moov：元数据</li><li>mdat：音视频数据</li></ul></li></ul><h3 id="FLV"><a href="#FLV" class="headerlink" title="FLV"></a>FLV</h3><ul><li>适合网络视频播放</li><li>大文件/长时间播放稳定</li><li>支持时间戳索引</li><li>需要建立I帧索引</li></ul><h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><ul><li>基于HTTP下载</li><li>由ts文件和m3u8索引组成</li><li>支持二级索引</li><li>延迟较大(5~30秒)</li></ul><h2 id="H-264编码原理"><a href="#H-264编码原理" class="headerlink" title="H.264编码原理"></a>H.264编码原理</h2><h3 id="码流分层"><a href="#码流分层" class="headerlink" title="码流分层"></a>码流分层</h3><ul><li>VAL：视频编码层</li><li>NAL：网络提取层</li></ul><h3 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h3><ul><li>I帧：完整帧</li><li>P帧：差异编码</li><li>B帧：双向参考</li><li>IDR帧：重置参考</li><li>GOP组：关键帧组</li></ul><h3 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h3><ol><li>码率控制</li><li>分辨率/帧率调整</li><li>GOP设置：<ul><li>在线播放：帧率的4-5倍</li><li>直播：帧率的1-2倍</li></ul></li></ol><h3 id="推流命令示例"><a href="#推流命令示例" class="headerlink" title="推流命令示例"></a>推流命令示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\ffmpeg -re -f dshow -i video=<span class="string">&quot;USB2.0 HD UVC WebCam&quot;</span> -vcodec libx264 -acodec aac -f flv -g 60 -bf 0 rtmp://127.0.0.1/live/test</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-re</code>：按原帧率读取</li><li><code>-f dshow</code>：Windows视频获取</li><li><code>-g 60</code>：GOP大小</li><li><code>-bf 0</code>：禁用B帧</li></ul>]]></content>
    
    
    <summary type="html">详细介绍各种音视频直播协议的特点和应用场景，包括RTMP、HTTP-FLV、WebRTC、RTSP等</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="网络协议" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="直播" scheme="https://eatbreads.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>优化ZLMediakit的直播播放</title>
    <link href="https://eatbreads.github.io/posts/1b73edcd.html"/>
    <id>https://eatbreads.github.io/posts/1b73edcd.html</id>
    <published>2025-04-15T16:26:32.000Z</published>
    <updated>2025-04-15T16:28:52.020Z</updated>
    
    <content type="html"><![CDATA[<h1>ZLMediakit直播系统优化</h1><h2 id="直播协议选择">直播协议选择</h2><h3 id="最佳实践">最佳实践</h3><ul><li>推流端：使用RTMP协议</li><li>拉流端：使用HTTP-FLV协议</li></ul><h2 id="编码参数优化">编码参数优化</h2><h3 id="关键配置">关键配置</h3><ol><li>禁用B帧</li><li>GOP大小设置为帧率的1-2倍<ul><li>防止长时间不出现I帧</li><li>有利于新观众快速加入直播</li></ul></li></ol><h2 id="实现命令">实现命令</h2><h3 id="推流命令">推流命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\ffmpeg -re -f dshow -i video=<span class="string">&quot;USB2.0 HD UVC WebCam&quot;</span> -vcodec libx264 -acodec aac -f flv -g 60 -bf 0 rtmp://127.0.0.1/live/test</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-g 60</code>: 设置GOP大小</li><li><code>-bf 0</code>: 禁用B帧</li></ul><h3 id="播放地址">播放地址</h3><ol><li>RTMP播放地址（推荐用于直播）：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="regexp">/live/</span>test</span><br></pre></td></tr></table></figure><ol start="2"><li>HTTP-FLV播放地址：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span><span class="regexp">/live/</span>test.live.flv</span><br></pre></td></tr></table></figure><p>注：两种协议都可用于拉流，但推荐使用HTTP-FLV</p>]]></content>
    
    
    <summary type="html">介绍ZLMediakit直播系统优化方案，包括推流协议选择、编码参数调优等内容</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="ZLMediakit" scheme="https://eatbreads.github.io/tags/ZLMediakit/"/>
    
    <category term="直播" scheme="https://eatbreads.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>使用ZLMediakit实现点播功能</title>
    <link href="https://eatbreads.github.io/posts/edbebd32.html"/>
    <id>https://eatbreads.github.io/posts/edbebd32.html</id>
    <published>2025-04-14T16:15:26.000Z</published>
    <updated>2025-04-14T16:20:13.616Z</updated>
    
    <content type="html"><![CDATA[<h1>ZLMediakit点播功能实现</h1><h2 id="文件访问配置">文件访问配置</h2><h3 id="URL格式">URL格式</h3><p>点播文件URL格式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span><span class="regexp">/record/</span>dd.mp4</span><br></pre></td></tr></table></figure><h3 id="挂载问题排查">挂载问题排查</h3><ol><li>文件同步问题</li></ol><ul><li>Windows Docker桥接挂载不会实时同步新增内容</li><li>文件写入晚于容器启动</li><li>解决方案：重启容器</li></ul><ol start="2"><li>挂载位置问题</li></ol><ul><li>初始挂载位置错误</li><li>修改挂载点后可以在网页执行播放</li></ul><h2 id="配置调整">配置调整</h2><h3 id="服务器配置">服务器配置</h3><ul><li>修改protocol路径</li><li>需要正确配置挂载点<br><img src="https://cdn-a.markji.com/files/67fbee472d0565736319cf54_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:gJqxn8ma3pVA1k0Em2neCyO-ues=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67fbecaf75151df2bbdde516_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:h_Ke2J4Z3Ra4WhtQH2i8ra7LSCk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67fbef0d2d0565736319db78_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:EwkA1BCeOR506p02Z6CFZX01NgI=" alt="图片1"></li></ul><h3 id="www目录处理">www目录处理</h3><p>问题：内容拷贝进www后消失<br>解决方案：</p><ol><li>创建临时容器</li><li>拷贝www目录内容</li><li>重新挂载（类似config.ini的操作）</li></ol><h2 id="播放器配置">播放器配置</h2><h3 id="VLC播放器">VLC播放器</h3><ul><li>下载安装VLC</li><li>可用于测试点播功能<br><img src="https://cdn-a.markji.com/files/67fca36c75151df2bbebfd81_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FXsagarh2L9cEnR6NUc4_u-LMIg=" alt="图片1"></li></ul><h2 id="待解决问题">待解决问题</h2><h3 id="WebAssist访问问题">WebAssist访问问题</h3><ul><li>目前无法访问</li><li>待后续更新解决方案</li></ul>]]></content>
    
    
    <summary type="html">记录使用ZLMediakit实现点播功能的过程，包括文件挂载、路径配置等问题的解决方案</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="流媒体" scheme="https://eatbreads.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    <category term="Docker" scheme="https://eatbreads.github.io/tags/Docker/"/>
    
    <category term="ZLMediakit" scheme="https://eatbreads.github.io/tags/ZLMediakit/"/>
    
  </entry>
  
  <entry>
    <title>ZLMediakit的Docker配置与使用记录</title>
    <link href="https://eatbreads.github.io/posts/ff5976c9.html"/>
    <id>https://eatbreads.github.io/posts/ff5976c9.html</id>
    <published>2025-04-14T16:03:49.000Z</published>
    <updated>2025-04-14T16:20:13.611Z</updated>
    
    <content type="html"><![CDATA[<h1>ZLMediakit配置记录</h1><h2 id="初始尝试">初始尝试</h2><h3 id="vcpkg安装">vcpkg安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install zlmediakit</span><br></pre></td></tr></table></figure><p>配置文件位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/vcpkg/i</span>nstalled<span class="regexp">/x64-linux/</span>tools<span class="regexp">/zlmediakit/</span></span><br></pre></td></tr></table></figure><h2 id="Docker部署">Docker部署</h2><h3 id="配置文件管理技巧">配置文件管理技巧</h3><ol><li>临时运行容器</li><li>使用docker cp拷贝配置文件</li><li>删除临时容器</li><li>修改配置文件</li><li>重新挂载运行</li></ol><h3 id="运行命令">运行命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> zlmediakit `</span><br><span class="line">  <span class="literal">-p</span> <span class="number">1935</span>:<span class="number">1935</span> `</span><br><span class="line">  <span class="literal">-p</span> <span class="number">8080</span>:<span class="number">80</span> `</span><br><span class="line">  <span class="literal">-p</span> <span class="number">554</span>:<span class="number">554</span> `</span><br><span class="line">  <span class="literal">-p</span> <span class="number">30000</span><span class="literal">-30500</span>:<span class="number">30000</span><span class="literal">-30500</span>/tcp `</span><br><span class="line">  <span class="literal">-p</span> <span class="number">30000</span><span class="literal">-30500</span>:<span class="number">30000</span><span class="literal">-30500</span>/udp `</span><br><span class="line">  <span class="literal">-v</span> C:/Users/<span class="number">18526</span>/Desktop/config/config.ini:/opt/media/conf/config.ini `</span><br><span class="line">  <span class="literal">-v</span> C:/Users/<span class="number">18526</span>/Desktop/www:/opt/media/bin/www `</span><br><span class="line">  zlmediakit/zlmediakit:master</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>PowerShell换行符是`</li><li>www需要挂载到bin下</li><li>需要先导出www目录内容</li></ul><h3 id="配置热更新">配置热更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;http://宿主机IP:8080/api/reloadConfig?secret=your_custom_secret&quot;</span></span><br></pre></td></tr></table></figure><h2 id="推拉流测试">推拉流测试</h2><h3 id="RTSP特性说明">RTSP特性说明</h3><p>RTSP是实时传输协议，类似直播，不会持久存储内容</p><h3 id="推流命令">推流命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i <span class="string">&quot;dd.mp4&quot;</span> -vcodec h264 -acodec aac -f rtsp -rtsp_transport tcp rtsp://127.0.0.1/live/test</span><br></pre></td></tr></table></figure><h3 id="拉流方式">拉流方式</h3><ol><li>RTSP拉流：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -rtsp_transport tcp rtsp://127.0.0.1/live/test</span><br></pre></td></tr></table></figure><ol start="2"><li>HLS拉流：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//i</span>p:port<span class="regexp">/live/</span>testxxx/hls.m3u8</span><br></pre></td></tr></table></figure><p>注意：live是固定路径</p><h3 id="补充说明">补充说明</h3><ul><li>支持RTSP和RTMP混用</li><li>www目录用于存放资源</li></ul>]]></content>
    
    
    <summary type="html">记录ZLMediakit在Docker环境下的配置过程，包括安装、配置文件管理和推拉流测试</summary>
    
    
    
    <category term="运维笔记" scheme="https://eatbreads.github.io/categories/%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Docker" scheme="https://eatbreads.github.io/tags/Docker/"/>
    
    <category term="ZLMediakit" scheme="https://eatbreads.github.io/tags/ZLMediakit/"/>
    
    <category term="流媒体服务器" scheme="https://eatbreads.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL多线程调试与解决方案</title>
    <link href="https://eatbreads.github.io/posts/31a16705.html"/>
    <id>https://eatbreads.github.io/posts/31a16705.html</id>
    <published>2025-04-14T15:51:18.000Z</published>
    <updated>2025-04-14T16:20:13.614Z</updated>
    
    <content type="html"><![CDATA[<h1>OpenGL多线程问题排查与解决</h1><p><img src="https://cdn-a.markji.com/files/67fa187575151df2bbad0eb6_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:0i0tese83SpqFzkut91oyoxu2oY=" alt="图片1"></p><h2 id="初始问题">初始问题</h2><p>运行时发现代码报错，原始代码中没有makeCurrent调用。添加后出现新的错误：<br><img src="https://cdn-a.markji.com/files/67fa222375151df2bbae41e0_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:CmWd37aFZHTM0K34RySbz__unW0=" alt="图片1"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot make QOpenGLContext current in a different thread</span><br></pre></td></tr></table></figure><h2 id="问题分析">问题分析</h2><h3 id="代码结构">代码结构</h3><ul><li>解码线程(ReadThread)读取数据</li><li>通过emit发送信号</li><li>Widget中注册信号与槽</li><li>调用updateImage更新<br><img src="https://cdn-a.markji.com/files/67fa1c6075151df2bbad8810_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:yZEMrUwdwFqWtmzq8L18R2kCHzY=" alt="图片1"></li></ul><h3 id="调试技巧">调试技巧</h3><ul><li>单步跳过：不进入函数体，直接到下一行</li><li>单步进入：进入函数内部</li><li>单步跳出：退出当前函数<br><img src="https://cdn-a.markji.com/files/67fa1f5f75151df2bbadf206_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:zGIUUU5ha_omPwSHyFG_IdfC0uc=" alt="图片1"></li></ul><h3 id="根本原因">根本原因</h3><ul><li>updateImage在解码线程中触发</li><li>OpenGL上下文(Context)在Qt中只能在创建线程中激活(makeCurrent)</li></ul><h2 id="解决方案">解决方案</h2><h3 id="方案一：Auto模式-深拷贝">方案一：Auto模式 + 深拷贝</h3><p><img src="https://cdn-a.markji.com/files/67fa233075151df2bbae64da_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:-yfpyons9ehsOOcbxmQlFOabt6s=" alt="图片1"><br>优点：</p><ul><li>实现简单</li></ul><p>缺点：</p><ul><li>emit(image)默认浅拷贝</li><li>可能导致主线程和解码线程访问冲突</li><li>解码线程处理速度快于主线程时可能崩溃</li></ul><p>改进：</p><ul><li>在发送信号时使用image.copy()</li><li>避免修改同一份image</li></ul><h3 id="方案二：使用阻塞方式">方案二：使用阻塞方式</h3><p><img src="https://cdn-a.markji.com/files/67fa256275151df2bbaef138_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:_x8HnTqg5OPILeNFkR8791dGpy0=" alt="图片1"><br>特点：</p><ul><li>控制同时访问</li><li>保证线程安全</li></ul><h2 id="补充说明">补充说明</h2><p>之前使用QPainter没问题的原因：</p><ul><li>没有OpenGL的同线程要求</li><li>可以使用Direct模式</li><li>不需要拷贝image(因为在同一线程)</li></ul>]]></content>
    
    
    <summary type="html">记录OpenGL在多线程环境下遇到的问题及解决方案，包括上下文切换、线程同步等内容</summary>
    
    
    
    <category term="图形编程" scheme="https://eatbreads.github.io/categories/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://eatbreads.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="调试" scheme="https://eatbreads.github.io/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PlayImage使用OpenGL实现视频渲染</title>
    <link href="https://eatbreads.github.io/posts/74e5f723.html"/>
    <id>https://eatbreads.github.io/posts/74e5f723.html</id>
    <published>2025-04-14T15:46:32.000Z</published>
    <updated>2025-04-14T15:50:50.346Z</updated>
    
    <content type="html"><![CDATA[<h1>PlayImage的OpenGL实现</h1><h2 id="基础架构">基础架构</h2><p><img src="https://cdn-a.markji.com/files/67f8ca1ceb27578088b6e53c_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FNznTp5nnhoXjDIZXuZOGN2282Q=" alt="图片1"></p><h3 id="类继承">类继承</h3><ul><li>继承QOpenGLWidget和QOpenGLFunctions_3_3</li><li>新版本OpenGL(&gt;2.0)从固定管线转向可编程管线</li></ul><h3 id="缓冲区概念">缓冲区概念</h3><ul><li>VBO：保存单个顶点数据（数据集）</li><li>VAO：保存如何使用这些VBO的数据（使用说明）</li></ul><h3 id="资源管理">资源管理</h3><ul><li>添加资源文件：通过Qt的resource系统</li><li>GLSL文件需要添加到资源系统中</li></ul><h2 id="OpenGL渲染流程类比">OpenGL渲染流程类比</h2><p>整个流程类似于布置电影院：</p><ol><li>摆放设备</li><li>调整投影仪滤镜（着色器）</li><li>准备海报并裁剪（texture）</li><li>播放时绑定海报（texture.bind()）</li><li>执行播放<br><img src="https://cdn-a.markji.com/files/67f8cb28c7682418c31519ff_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:QNAYSqKEJEjBgCyT0Uc9d8_k5Sc=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f940acc7682418c32441de_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:SgWrSGa6iuhbQ506zT-eMbHyKKQ=" alt="图片1"></li></ol><h2 id="着色器工作原理">着色器工作原理</h2><h3 id="着色器特点">着色器特点</h3><ul><li>每份着色器代码只是单个像素的绘制蓝图</li><li>GPU中多个工作单元并行处理</li><li>每个工作单元负责一个像素的绘制</li><li>着色器是工作单元的执行指南</li></ul><h3 id="着色器类型">着色器类型</h3><ol><li>顶点着色器：确定位置</li><li>片段着色器（像素着色器）：绘制颜色</li></ol><h3 id="工作流程">工作流程</h3><ol><li>顶点着色器执行（仅执行顶点次数）</li><li>图元装配（组合成三角形/线段）</li><li>光栅化（填充像素块）</li><li>片段着色器处理每个fragment（执行像素数量次）<br><img src="https://cdn-a.markji.com/files/67f9412ac7682418c32449ec_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:HNqm3Atyp4YM3vWyNkjdxyszr7U=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67fa0ba875151df2bbab74ed_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:OBn53mQm0j8uiGbdmz_xskuSVXY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67fa278f75151df2bbaf3551_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:jlImCTf9A5kJcKHYi8IaLukQCOE=" alt="图片1"></li></ol><h2 id="实现注意事项">实现注意事项</h2><h3 id="OpenGL封装选择">OpenGL封装选择</h3><ul><li>放弃Qt封装的OpenGL</li><li>直接使用原生句柄操作VAO/VBO</li></ul><h3 id="位置管理">位置管理</h3><ul><li>m_pos使用QPoint类型<br><img src="https://cdn-a.markji.com/files/67fa0fd27f917e87d7bf7967_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Kk27zVoJp9jmZm8XKIDflYrTouU=" alt="图片1"></li></ul>]]></content>
    
    
    <summary type="html">详细介绍使用OpenGL实现PlayImage视频渲染的过程，包括着色器编程、缓冲区管理等核心概念</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="图形编程" scheme="https://eatbreads.github.io/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>PlayImage类的实现与窗口控件提升</title>
    <link href="https://eatbreads.github.io/posts/e486a6b2.html"/>
    <id>https://eatbreads.github.io/posts/e486a6b2.html</id>
    <published>2025-04-10T15:37:16.000Z</published>
    <updated>2025-04-10T15:38:34.219Z</updated>
    
    <content type="html"><![CDATA[<h1>PlayImage类实现与控件提升</h1><h2 id="图像处理中的线程安全">图像处理中的线程安全</h2><h3 id="QImage转QPixmap的锁问题">QImage转QPixmap的锁问题</h3><p>遇到问题：为什么image转pixmap需要加锁？</p><p>原因分析：</p><ul><li>QImage是浅拷贝</li><li>不涉及实际的内存复制</li><li>采用写时复制机制</li><li>修改时会内部创建副本并返回</li></ul><h3 id="更安全的处理方式">更安全的处理方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> image.<span class="built_in">copy</span>();  <span class="comment">// 显式创建深拷贝</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67f7ca61eb275780889db6e9_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:02Weiaf_hM3aTtDvF-oSgKQ_Iwk=" alt="图片1"></p><h2 id="信号槽执行机制">信号槽执行机制</h2><h3 id="同步执行特性">同步执行特性</h3><ul><li>同一线程中的信号和槽是同步执行的</li><li>可以理解为&quot;跳回去执行&quot;槽函数</li><li>不会产生新的线程</li></ul><h2 id="控件提升问题">控件提升问题</h2><h3 id="解决方案">解决方案</h3><p>目前已知的解决方法：</p><ul><li>使用全路径方式</li><li>确保路径正确指向控件类<br><img src="https://cdn-a.markji.com/files/67f7e11cc7682418c3010e36_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Fy9gtrXjDpwId8aJIWWzlR_jTjI=" alt="图片1"></li></ul>]]></content>
    
    
    <summary type="html">详细介绍PlayImage类的实现过程，包括图像处理、线程安全以及控件提升等内容</summary>
    
    
    
    <category term="Qt开发" scheme="https://eatbreads.github.io/categories/Qt%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="https://eatbreads.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="图形界面" scheme="https://eatbreads.github.io/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>ReadThread线程类的实现</title>
    <link href="https://eatbreads.github.io/posts/a5d7054f.html"/>
    <id>https://eatbreads.github.io/posts/a5d7054f.html</id>
    <published>2025-04-10T15:36:00.000Z</published>
    <updated>2025-04-10T15:38:34.223Z</updated>
    
    <content type="html"><![CDATA[<h1>ReadThread线程类实现</h1><h2 id="类设计要点">类设计要点</h2><h3 id="头文件优化">头文件优化</h3><ul><li>核心：头文件中不需要包含其他类的完整定义</li><li>只需要前置声明即可</li><li>可以减少编译依赖</li></ul><h3 id="线程控制">线程控制</h3><ul><li>继承QThread类</li><li>重写run函数</li><li>使用start启动线程</li><li>使用quit请求停止</li><li>使用wait等待线程结束</li></ul><h2 id="计时器兼容性问题">计时器兼容性问题</h2><h3 id="Qt6废弃QTime">Qt6废弃QTime</h3><p>第一个遇到的兼容性问题：Qt6中QTime的start()和elapsed()方法已被废弃</p><h3 id="使用QElapsedTimer">使用QElapsedTimer</h3><ul><li>Qt5就建议使用QElapsedTimer替代QTime</li><li>QTime设计初衷是表示时间和测量时间间隔</li><li>在高精度计时方面存在限制</li><li>QElapsedTimer提供更高精度的时间测量</li><li>使用系统级别的高分辨率定时器</li></ul><h3 id="计时规则">计时规则</h3><ul><li>start()时记录一次时间</li><li>elapsed()返回与当前时间的差值</li></ul><h2 id="已知问题">已知问题</h2><h3 id="暂停功能bug">暂停功能bug</h3><ul><li>elapsed在触发暂停后仍会继续计时</li><li>导致暂停后播放会快速追回当前时间</li><li>实际效果等于没有暂停</li><li>后续会更新优化方案</li></ul>]]></content>
    
    
    <summary type="html">详细介绍ReadThread线程类的实现要点，包括类的设计、线程控制以及计时器的使用</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="https://eatbreads.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>VideoPlay的核心read函数详解</title>
    <link href="https://eatbreads.github.io/posts/db8f7402.html"/>
    <id>https://eatbreads.github.io/posts/db8f7402.html</id>
    <published>2025-04-10T08:09:18.000Z</published>
    <updated>2025-04-10T15:38:34.221Z</updated>
    
    <content type="html"><![CDATA[<h1>VideoPlay的read函数详解</h1><h2 id="Qt环境问题解决">Qt环境问题解决</h2><p>当Qt频繁出现无响应或无法打开的情况，可以尝试删除以下配置文件：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">C</span>:\Users\Administrator\AppData\Roaming\QtProject</span><br></pre></td></tr></table></figure><p>该文件可能会导致Qt启动时读取配置耗时过长。删除后Qt会重新生成配置文件。</p><h2 id="像素格式处理">像素格式处理</h2><p><img src="https://cdn-a.markji.com/files/67f778deeb27578088918a61_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:LVKgqx8MCHUU2TB74efe2NXBx7g=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f77b72eb2757808891e3e3_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4PjVjFpHeeO9wY5VVNSWkb8NH_A=" alt="图片1"></p><h3 id="格式设置限制">格式设置限制</h3><p>即使我们告诉解码器想要解码出YUV420P格式的帧，在硬件解码的情况下解码器可能会返回NV12格式，忽略设置的pix_fmt参数。</p><h3 id="格式设置时机">格式设置时机</h3><p>pix_fmt是在用视频流的para赋值解码器上下文那一步进行设置的。<br><img src="https://cdn-a.markji.com/files/67f783bceb2757808893994a_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:WY4HpMocon_URRb_Kru0eDP7RXc=" alt="图片1"></p><h2 id="返回值内存管理">返回值内存管理</h2><p>二更：关于return返回的数据说明：</p><ul><li>本质上返回的是m_buffer</li><li>即使image是浅拷贝</li><li>但实际内存还在m_buffer中</li><li>因此不构成返回局部对象指针的问题</li></ul>]]></content>
    
    
    <summary type="html">详细介绍VideoPlay类中read函数的实现原理，包括像素格式设置、内存管理等关键点</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>VideoDecoder的初始化与Open函数实现</title>
    <link href="https://eatbreads.github.io/posts/5b754325.html"/>
    <id>https://eatbreads.github.io/posts/5b754325.html</id>
    <published>2025-04-09T15:48:31.000Z</published>
    <updated>2025-04-09T15:55:42.959Z</updated>
    
    <content type="html"><![CDATA[<h1>VideoDecoder初始化与Open函数实现</h1><h2 id="注意事项">注意事项</h2><ol><li>FFmpeg版本兼容</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_register_all</span>();  <span class="comment">// 在新版本中其实可省略</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67f62488c7682418c3cc7832_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:oTrBk8gkfJ-Rlyatgrju-KUFyxk=" alt="图片1"><br>2. 初始化函数调用</p><ul><li>init函数在构造函数中始终未被调用</li></ul><h2 id="CMake配置问题">CMake配置问题</h2><p>CMake设置的路径必须在add_executable()或qt_add_executable()之前配置<br><img src="https://cdn-a.markji.com/files/67f62b7ba5d66136f3e488be_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:1v6-tAQ1yC41ODKSUit7eHAEqvY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f62d0aa5d66136f3e4cbf7_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2mguVmWtWNRi5TQkVHSRyyJDh-0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f636b9c7682418c3ced832_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:21PoT4SpANxk8Puopd7r611J5mo=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f637f7c7682418c3cef861_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MdbGRzt1HMDOqokUVj1Z4JeWb-Q=" alt="图片1"></p><h2 id="视频时长计算">视频时长计算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_totalTime = m_formatContext-&gt;duration / (AV_TIME_BASE / <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ul><li>计算视频总时长（毫秒）</li><li>AV_TIME_BASE是基础时间单位</li><li>1000用于转换为毫秒单位</li></ul><h2 id="有理数转换">有理数转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">rationalToDouble</span><span class="params">(AVRational* rational)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>将AVRational结构体转换为double类型</li><li>AVRational包含分子和分母</li><li>函数执行简单的除法运算<br><img src="https://cdn-a.markji.com/files/67f63b24a5d66136f3e6ea92_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RlWC5iKi_UH6CHulmFGSR-lD3ng=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f63ce0c7682418c3cfb328_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:k__mLcJkG01gmeNAW4JXA00a58U=" alt="图片1"></li></ul><h2 id="解码器识别">解码器识别</h2><p>视频流中包含解码器ID信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videoStream-&gt;codecpar-&gt;codec_id  <span class="comment">// 例如：AV_CODEC_ID_H264</span></span><br></pre></td></tr></table></figure><ul><li>通过ID可以找到对应的解码器(如h264)</li></ul><h2 id="性能优化设置">性能优化设置</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许不符合规范的加速技巧</span></span><br><span class="line">m_codecContext-&gt;flags2 |= AV_CODEC_FLAG2_FAST;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置解码线程数</span></span><br><span class="line">m_codecContext-&gt;thread_count = <span class="number">8</span>;                 </span><br></pre></td></tr></table></figure><p>注意：线程数设置需要根据具体机器情况调整，8线程并不一定是最优选择，某些情况下单线程可能更快。<br><img src="https://cdn-a.markji.com/files/67f6415ea5d66136f3e79dae_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:zkWzRHXHGqC5Tm1PlePkEmoNX-M=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">详细介绍VideoDecoder类的初始化过程和open函数的实现，包括FFmpeg相关配置和注意事项</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>rpc远程过程调用实现</title>
    <link href="https://eatbreads.github.io/posts/1a8fdb43.html"/>
    <id>https://eatbreads.github.io/posts/1a8fdb43.html</id>
    <published>2025-04-08T16:24:50.000Z</published>
    <updated>2025-04-08T16:32:36.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rpc远程调用实现"><a href="#rpc远程调用实现" class="headerlink" title="rpc远程调用实现"></a>rpc远程调用实现</h1><h2 id="bind函数-包装器"><a href="#bind函数-包装器" class="headerlink" title="bind函数(包装器)"></a>bind函数(包装器)</h2><p>就是先弄了个最顶层封装的Function,接收可调用函数和俩Datestream(里面是参数),然后用std的bind绑定wrap和fun和俩Datastream,发生如下操作(很多是编译期执行 )</p><p>包装器的第一参就是wrap,我们用模板来识别可调用函数的函数签名(返回值和参数列表),然后对args参数列表识别实际参数类型,然后使用这个些参数类型,定义出一个&lt;&gt;内部是这些的tuple</p><p>然后识别tuple模板参数个数,然后make出对应的下标列表index_sequence,然后把列表中的Id…开包,对每一个Id调用get<Id>,然后把Datestream内部的参数注入进get返回的引用</p><p>ps:bind这个操作只是生成了对应的fun和序列化的交互函数(使用std::bind),真正调用还在call,就是直接传入俩Datastream然后string名字匹配哈希表(value就是bind产生的function),然后就会去执行生成的模板函数了</p><p>ps:模板参数的命名就是函数模板就是F,返回类型就是R,元组的类型就是Tuple</p><p>二更：所以第一次wrap是bind主体，第二次wrap是为了分割出args和返回类型并且放进function，第三次wrap就是执行主体<br><img src="https://cdn-a.markji.com/files/66572f98d3cf30b45ac9b1e7_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5cVCjyDxIgcZcSXKQqj59oShaxA=" alt="图片1"><br>三更：这边function说只要两个参数，因为虽然内置的wrap还要求了一个fun,但是因为他已经被bind绑入了（包括this指针），所以确实参数就只需要那俩占位符，即这样操作bind就会生成一个function，返回类型是void且接受俩参数的<br><img src="https://cdn-a.markji.com/files/66572f98d3cf30b45ac9b1e7_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5cVCjyDxIgcZcSXKQqj59oShaxA=" alt="图片1"><br>三更：而且模板参数在传递的时候是不会发生改变的，只有一步从F函数指针变成了R和args，然后返回值的识别有一次是通过F向R转换，还有一次是手动<R>指定的<br><img src="https://cdn-a.markji.com/files/66572fb66ff0e9a10f1499b5_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:G4_7HHAE1QOQPHRApzLvn9peJiY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/66572fc2d3cf30b45ac9b655_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:i7m8vpQnjYqeltmrVPcTCSidyzY=" alt="图片1"><br>然后是客户端调用<br><img src="https://cdn-a.markji.com/files/66572fea6ff0e9a10f14a02b_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4LlAxyGHi9rP9Oc7VrBYapSphrk=" alt="图片1"><br>然后是work函数<br><img src="https://cdn-a.markji.com/files/6657303bd3cf30b45ac9c418_hd.png?e=1744131868001&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Mt3hcyEFPmnOv_hQudoD0gCqmCU=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/665730576ff0e9a10f14aadc_hd.png?e=1744131868001&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:LZ9Ers_459wz5RfrPWrkkeyCAzc=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">记录RPC远程调用实现过程中的技术细节和更新说明</summary>
    
    
    
    <category term="后端开发" scheme="https://eatbreads.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="网络编程" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="RPC" scheme="https://eatbreads.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>RPC远程过程调用C++实现</title>
    <link href="https://eatbreads.github.io/posts/63d129aa.html"/>
    <id>https://eatbreads.github.io/posts/63d129aa.html</id>
    <published>2025-04-08T16:22:24.000Z</published>
    <updated>2025-04-22T11:28:44.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC远程过程调用C-实现"><a href="#RPC远程过程调用C-实现" class="headerlink" title="RPC远程过程调用C++实现"></a>RPC远程过程调用C++实现</h1><h2 id="核心实现原理"><a href="#核心实现原理" class="headerlink" title="核心实现原理"></a>核心实现原理</h2><p>RPC框架的核心在于函数绑定和参数传递机制。当调用<code>bind</code>函数时，会：</p><ol><li>将string类型的函数名和对应的函数指针(使用function封装)存入map</li><li>自动识别参数列表并生成模板元组来适配传参</li><li>通过函数名和序列化实现函数调用的参数传递</li><li>调用function包装器执行函数并将结果序列化返回给客户端</li></ol><h2 id="特性支持"><a href="#特性支持" class="headerlink" title="特性支持"></a>特性支持</h2><ul><li>支持自定义类型的RPC调用</li><li>只需要实现序列化接口即可</li><li>参考了buttonrpc开源项目的实现<br><img src="https://cdn-a.markji.com/files/6693b2eb63e4546df5d7a66c_hd.png?e=1744131868001&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:IwWqueUBKSldTG6TVdR2peqFuoU=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6693b2fa8f51739870084132_hd.png?e=1744131868001&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cr2upfN-vsSSiume4vDUFcSdGAs=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6648498b462469d45e30440e_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ga0bTiENZ7QqsgjNIll-wWQuMIo=" alt="图片1"><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><img src="https://cdn-a.markji.com/files/66484c19462469d45e307b9b_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FF-D51l7RNwQVkl9iTQlQuJfetE=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/664850f6db29be03af40f184_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:VeFg5vaofxivt9EU1DtCxw4W7H8=" alt="图片1"><br>在服务端声明并绑定函数：</li><li>第一个参数：函数名(string类型)</li><li>第二个参数：函数指针</li></ul><p>这种设计使得RPC调用变得简单直观，同时保持了良好的扩展性。</p>]]></content>
    
    
    <summary type="html">介绍基于C++实现的RPC远程过程调用框架，包括函数绑定、参数传递和序列化等核心功能</summary>
    
    
    
    <category term="后端开发" scheme="https://eatbreads.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="网络编程" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="RPC" scheme="https://eatbreads.github.io/tags/RPC/"/>
    
    <category term="分布式系统" scheme="https://eatbreads.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>介绍一下cpu中的yuv转rgb和opengl中的yuv转rgb和直接nv12转rbg方法</title>
    <link href="https://eatbreads.github.io/posts/f4cc5b12.html"/>
    <id>https://eatbreads.github.io/posts/f4cc5b12.html</id>
    <published>2025-04-08T15:59:22.000Z</published>
    <updated>2025-04-22T11:28:19.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="YUV-NV12到RGB的转换方案"><a href="#YUV-NV12到RGB的转换方案" class="headerlink" title="YUV/NV12到RGB的转换方案"></a>YUV/NV12到RGB的转换方案</h1><h2 id="CPU中的YUV转RGB"><a href="#CPU中的YUV转RGB" class="headerlink" title="CPU中的YUV转RGB"></a>CPU中的YUV转RGB</h2><h3 id="FFmpeg方案"><a href="#FFmpeg方案" class="headerlink" title="FFmpeg方案"></a>FFmpeg方案</h3><ul><li>FFmpeg解码默认输出YUV格式</li><li>使用<code>sws_getCachedContext</code>进行格式转换</li><li>转换目标格式为<code>AV_PIX_FMT_RGBA</code></li><li>适合简单场景，但CPU消耗较大<br><img src="https://cdn-a.markji.com/files/67efabbae940a885d8a18beb_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Dr3M6vI51akx8UsbYqxDKiHGGYY=" alt="图片1"><h2 id="OpenGL中的YUV转RGB方案"><a href="#OpenGL中的YUV转RGB方案" class="headerlink" title="OpenGL中的YUV转RGB方案"></a>OpenGL中的YUV转RGB方案</h2></li></ul><h3 id="方案一：RGB纹理渲染"><a href="#方案一：RGB纹理渲染" class="headerlink" title="方案一：RGB纹理渲染"></a>方案一：RGB纹理渲染</h3><p><img src="https://cdn-a.markji.com/files/67efabe2e940a885d8a18ea2_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:jqDoEHl78m5YLERVbYFjI-pErow=" alt="图片1"></p><ol><li><p>继承关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayImage</span> : <span class="keyword">public</span> QOpenGLWidget, <span class="keyword">public</span> QOpenGLFunctions_3_3_Core</span><br></pre></td></tr></table></figure></li><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializeGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并绑定VAO/VBO/IBO</span></span><br><span class="line">    <span class="comment">// 编译连接着色器程序</span></span><br><span class="line">    <span class="comment">// 启用顶点属性数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>图像更新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 垂直翻转(OpenGL纹理Y轴相反)</span></span><br><span class="line">    m_texture = <span class="keyword">new</span> <span class="built_in">QOpenGLTexture</span>(image.<span class="built_in">mirrored</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>渲染</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定着色器程序</span></span><br><span class="line">    <span class="comment">// 绑定纹理</span></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    <span class="built_in">glDrawElements</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="方案二：直接YUV渲染"><a href="#方案二：直接YUV渲染" class="headerlink" title="方案二：直接YUV渲染"></a>方案二：直接YUV渲染</h3><p><img src="https://cdn-a.markji.com/files/67efac311137c8f4e5af9cb9_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:BvYuGOTK2QfpMlTtQ5sb0X1BJoA=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67efac3fe940a885d8a19690_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MFIybXXJT39g33YdPqRPOs2KGFA=" alt="图片1"></p><ol><li>数据传递</li></ol><ul><li>直接使用<code>AVFrame</code>传递解码数据</li><li>使用<code>BlockingQueuedConnection</code>确保数据安全</li></ul><ol><li><p>信号槽配置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册AVFrame用于信号传递</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(AVFrame)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接信号槽</span></span><br><span class="line"><span class="built_in">connect</span>(m_readThread, &amp;ReadThread::repaint,</span><br><span class="line">        playImage, &amp;PlayImage::repaint,</span><br><span class="line">        Qt::BlockingQueuedConnection);</span><br></pre></td></tr></table></figure></li><li><p>纹理处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个纹理对应YUV分量</span></span><br><span class="line">QOpenGLTexture *m_texY, *m_texU, *m_texV;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置纹理单元</span></span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_y&quot;</span>, <span class="number">0</span>);</span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_u&quot;</span>, <span class="number">1</span>);</span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_v&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>渲染实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_texY-&gt;<span class="built_in">bind</span>(<span class="number">0</span>);</span><br><span class="line">    m_texU-&gt;<span class="built_in">bind</span>(<span class="number">1</span>);</span><br><span class="line">    m_texV-&gt;<span class="built_in">bind</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行绘制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="OpenGL中直接处理NV12"><a href="#OpenGL中直接处理NV12" class="headerlink" title="OpenGL中直接处理NV12"></a>OpenGL中直接处理NV12</h2><p><img src="https://cdn-a.markji.com/files/67efac7c1137c8f4e5afa991_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FoRKl2CActfg1Z33Ow7avwu4Sdc=" alt="图片1"></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>避免CPU中的格式转换</li><li>性能提升约1/3</li><li>直接在GPU中完成转换</li></ul><h3 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a>实现要点</h3><ol><li>使用<code>av_hwframe_map</code>替代<code>av_hwframe_transfer_data</code></li><li>移除<code>sws_scale</code>相关代码</li><li>直接返回硬件帧</li></ol><h3 id="格式适配"><a href="#格式适配" class="headerlink" title="格式适配"></a>格式适配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据输入格式选择初始化方式</span></span><br><span class="line">    <span class="keyword">if</span> (format == AV_PIX_FMT_NV12) &#123;</span><br><span class="line">        <span class="built_in">initializeNV12</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">initializeYUV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_format == AV_PIX_FMT_NV12) &#123;</span><br><span class="line">        <span class="comment">// NV12渲染流程</span></span><br><span class="line">        <span class="built_in">bindNV12Textures</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// YUV渲染流程</span></span><br><span class="line">        <span class="built_in">bindYUVTextures</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行绘制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><ol><li><p>CPU转换方案</p><ul><li>实现简单</li><li>CPU占用高</li><li>适合简单场景</li></ul></li><li><p>OpenGL YUV方案</p><ul><li>中等复杂度</li><li>GPU处理</li><li>性能较好</li></ul></li><li><p>OpenGL NV12方案</p><ul><li>实现较复杂</li><li>性能最优</li><li>适合高性能需求<br>```</li></ul></li></ol>]]></content>
    
    
    <summary type="html">详细介绍在CPU和GPU中实现YUV/NV12到RGB转换的不同方案及其性能对比</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="图像处理" scheme="https://eatbreads.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>音视频软硬解码流程详解</title>
    <link href="https://eatbreads.github.io/posts/2c4a1d51.html"/>
    <id>https://eatbreads.github.io/posts/2c4a1d51.html</id>
    <published>2025-04-08T15:56:08.000Z</published>
    <updated>2025-04-08T15:57:10.126Z</updated>
    
    <content type="html"><![CDATA[<h1>音视频解码流程详解</h1><h2 id="软解码基础流程">软解码基础流程</h2><ol><li>打开输入文件</li><li>读取媒体文件信息</li><li>查询视频流</li><li>获取解码器</li><li>获取解码器上下文</li><li>使用视频流的codecpar为解码器上下文赋值</li><li>打开解码器</li><li>获取原始数据帧</li><li>将数据发送给解码器</li><li>从解码器读取解码后的数据</li><li>获取图像转换上下文</li><li>将解码的图像格式转换成QImage</li></ol><h2 id="硬解码流程">硬解码流程</h2><h3 id="基础步骤">基础步骤</h3><ol><li>打开输入文件<ul><li><code>avformat_open_input</code></li></ul></li><li>读取媒体文件信息<ul><li><code>avformat_find_stream_info</code></li></ul></li><li>查询视频流<ul><li><code>av_find_best_stream</code></li></ul></li><li>获取解码器<ul><li><code>avcodec_find_decoder</code></li></ul></li><li>获取解码器上下文<ul><li><code>avcodec_alloc_context3</code></li></ul></li><li>使用视频流的codecpar赋值<ul><li><code>avcodec_parameters_to_context</code></li></ul></li></ol><h3 id="硬件加速相关步骤">硬件加速相关步骤</h3><ol><li>检索编解码器支持的硬件配置<ul><li><code>avcodec_get_hw_config</code></li></ul></li><li>遍历支持的编解码器设备类型<ul><li><code>av_hwdevice_iterate_types</code></li><li>在构造函数中记录支持的类型到数组</li></ul></li><li>打开指定类型的编解码器设备<ul><li><code>av_hwdevice_ctx_create</code></li></ul></li><li>注册硬件像素格式回调<ul><li><code>m_codecContext-&gt;get_format = get_hw_format</code></li></ul></li></ol><h3 id="解码步骤">解码步骤</h3><ol><li>打开解码器<ul><li><code>avcodec_open2</code></li></ul></li><li>读取原始数据帧<ul><li><code>av_read_frame</code></li></ul></li><li>发送数据到解码器<ul><li><code>avcodec_send_packet</code></li></ul></li><li>读取解码后的数据<ul><li><code>avcodec_receive_frame</code></li></ul></li><li>GPU数据拷贝到CPU<ul><li><code>av_hwframe_transfer_data</code></li><li><code>av_hwframe_map(m_frameHW, m_frame, 0)</code></li></ul></li><li>获取图像转换上下文<ul><li><code>sws_getCachedContext</code></li></ul></li><li>转换为QImage格式<ul><li><code>sws_scale</code></li></ul></li></ol><h2 id="软解码显示实现-PlayImage类">软解码显示实现(PlayImage类)</h2><h3 id="基于QWidget">基于QWidget</h3><ol><li>接收图像信号并响应updateImage槽函数</li><li>转换为QPixmap</li><li>调用update触发重绘</li><li>paintEvent中绘制</li></ol><h3 id="YUV转RGB">YUV转RGB</h3><ul><li>FFmpeg默认解码为YUV格式</li><li>使用<code>sws_getCachedContext</code>转换为RGB(AV_PIX_FMT_RGBA)</li></ul><h2 id="OpenGL渲染优化">OpenGL渲染优化</h2><h3 id="软解码-OpenGL-YUV-RGB">软解码+OpenGL(YUV-&gt;RGB)</h3><ol><li>继承QOpenGLWidget和QOpenGLFunctions</li><li>initializeGL中设置VAO/VBO/IBO</li><li>updateImage中处理纹理</li><li>paintGL中执行绘制</li></ol><h3 id="软解码-OpenGL-直接YUV">软解码+OpenGL(直接YUV)</h3><ol><li>使用AVFrame直接传递</li><li>使用三个纹理处理YUV数据</li><li>在GPU中完成格式转换</li></ol><h3 id="硬解码-OpenGL-NV12">硬解码+OpenGL(NV12)</h3><ol><li>使用<code>av_hwframe_map</code>替代transfer_data</li><li>根据格式选择初始化方式</li><li>直接在GPU中完成NV12到RGB的转换</li></ol><h2 id="摄像头采集">摄像头采集</h2><ol><li>注册设备<ul><li><code>avdevice_register_all</code></li></ul></li><li>查询输入设备<ul><li><code>av_find_input_format</code></li></ul></li><li>执行标准解码流程</li><li>OpenGL中完成YUV转RGB</li></ol><h2 id="视频录制流程">视频录制流程</h2><ol><li>创建输出上下文<ul><li><code>avformat_alloc_output_context2</code></li></ul></li><li>初始化IO上下文<ul><li><code>avio_open</code></li></ul></li><li>配置编码器</li><li>创建视频流</li><li>写入头信息</li><li>编码循环</li><li>写入尾信息</li></ol>]]></content>
    
    
    <summary type="html">详细介绍音视频软解码和硬解码的实现流程，包括FFmpeg解码、OpenGL渲染等技术细节</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
  </entry>
  
</feed>
