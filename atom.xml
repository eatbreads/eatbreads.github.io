<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎来到小面包的小站🥝</title>
  
  
  <link href="https://eatbreads.github.io/atom.xml" rel="self"/>
  
  <link href="https://eatbreads.github.io/"/>
  <updated>2025-04-14T15:50:33.861Z</updated>
  <id>https://eatbreads.github.io/</id>
  
  <author>
    <name>小面包🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PlayImage使用OpenGL实现视频渲染</title>
    <link href="https://eatbreads.github.io/posts/74e5f723.html"/>
    <id>https://eatbreads.github.io/posts/74e5f723.html</id>
    <published>2025-04-14T15:46:32.000Z</published>
    <updated>2025-04-14T15:50:33.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PlayImage的OpenGL实现"><a href="#PlayImage的OpenGL实现" class="headerlink" title="PlayImage的OpenGL实现"></a>PlayImage的OpenGL实现</h1><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="https://cdn-a.markji.com/files/67f8ca1ceb27578088b6e53c_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FNznTp5nnhoXjDIZXuZOGN2282Q=" alt="图片1"></p><h3 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h3><ul><li>继承QOpenGLWidget和QOpenGLFunctions_3_3</li><li>新版本OpenGL(&gt;2.0)从固定管线转向可编程管线</li></ul><h3 id="缓冲区概念"><a href="#缓冲区概念" class="headerlink" title="缓冲区概念"></a>缓冲区概念</h3><ul><li>VBO：保存单个顶点数据（数据集）</li><li>VAO：保存如何使用这些VBO的数据（使用说明）</li></ul><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><ul><li>添加资源文件：通过Qt的resource系统</li><li>GLSL文件需要添加到资源系统中</li></ul><h2 id="OpenGL渲染流程类比"><a href="#OpenGL渲染流程类比" class="headerlink" title="OpenGL渲染流程类比"></a>OpenGL渲染流程类比</h2><p>整个流程类似于布置电影院：</p><ol><li>摆放设备</li><li>调整投影仪滤镜（着色器）</li><li>准备海报并裁剪（texture）</li><li>播放时绑定海报（texture.bind()）</li><li>执行播放<br><img src="https://cdn-a.markji.com/files/67f8cb28c7682418c31519ff_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:QNAYSqKEJEjBgCyT0Uc9d8_k5Sc=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f940acc7682418c32441de_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:SgWrSGa6iuhbQ506zT-eMbHyKKQ=" alt="图片1"></li></ol><h2 id="着色器工作原理"><a href="#着色器工作原理" class="headerlink" title="着色器工作原理"></a>着色器工作原理</h2><h3 id="着色器特点"><a href="#着色器特点" class="headerlink" title="着色器特点"></a>着色器特点</h3><ul><li>每份着色器代码只是单个像素的绘制蓝图</li><li>GPU中多个工作单元并行处理</li><li>每个工作单元负责一个像素的绘制</li><li>着色器是工作单元的执行指南</li></ul><h3 id="着色器类型"><a href="#着色器类型" class="headerlink" title="着色器类型"></a>着色器类型</h3><ol><li>顶点着色器：确定位置</li><li>片段着色器（像素着色器）：绘制颜色</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>顶点着色器执行（仅执行顶点次数）</li><li>图元装配（组合成三角形/线段）</li><li>光栅化（填充像素块）</li><li>片段着色器处理每个fragment（执行像素数量次）<br><img src="https://cdn-a.markji.com/files/67f9412ac7682418c32449ec_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:HNqm3Atyp4YM3vWyNkjdxyszr7U=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67fa0ba875151df2bbab74ed_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:OBn53mQm0j8uiGbdmz_xskuSVXY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67fa278f75151df2bbaf3551_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:jlImCTf9A5kJcKHYi8IaLukQCOE=" alt="图片1"><h2 id="实现注意事项"><a href="#实现注意事项" class="headerlink" title="实现注意事项"></a>实现注意事项</h2></li></ol><h3 id="OpenGL封装选择"><a href="#OpenGL封装选择" class="headerlink" title="OpenGL封装选择"></a>OpenGL封装选择</h3><ul><li>放弃Qt封装的OpenGL</li><li>直接使用原生句柄操作VAO/VBO</li></ul><h3 id="位置管理"><a href="#位置管理" class="headerlink" title="位置管理"></a>位置管理</h3><ul><li>m_pos使用QPoint类型<br><img src="https://cdn-a.markji.com/files/67fa0fd27f917e87d7bf7967_hd.png?e=1744648123046&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Kk27zVoJp9jmZm8XKIDflYrTouU=" alt="图片1"></li></ul>]]></content>
    
    
    <summary type="html">详细介绍使用OpenGL实现PlayImage视频渲染的过程，包括着色器编程、缓冲区管理等核心概念</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="图形编程" scheme="https://eatbreads.github.io/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>PlayImage类的实现与窗口控件提升</title>
    <link href="https://eatbreads.github.io/posts/e486a6b2.html"/>
    <id>https://eatbreads.github.io/posts/e486a6b2.html</id>
    <published>2025-04-10T15:37:16.000Z</published>
    <updated>2025-04-10T15:38:34.219Z</updated>
    
    <content type="html"><![CDATA[<h1>PlayImage类实现与控件提升</h1><h2 id="图像处理中的线程安全">图像处理中的线程安全</h2><h3 id="QImage转QPixmap的锁问题">QImage转QPixmap的锁问题</h3><p>遇到问题：为什么image转pixmap需要加锁？</p><p>原因分析：</p><ul><li>QImage是浅拷贝</li><li>不涉及实际的内存复制</li><li>采用写时复制机制</li><li>修改时会内部创建副本并返回</li></ul><h3 id="更安全的处理方式">更安全的处理方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> image.<span class="built_in">copy</span>();  <span class="comment">// 显式创建深拷贝</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67f7ca61eb275780889db6e9_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:02Weiaf_hM3aTtDvF-oSgKQ_Iwk=" alt="图片1"></p><h2 id="信号槽执行机制">信号槽执行机制</h2><h3 id="同步执行特性">同步执行特性</h3><ul><li>同一线程中的信号和槽是同步执行的</li><li>可以理解为&quot;跳回去执行&quot;槽函数</li><li>不会产生新的线程</li></ul><h2 id="控件提升问题">控件提升问题</h2><h3 id="解决方案">解决方案</h3><p>目前已知的解决方法：</p><ul><li>使用全路径方式</li><li>确保路径正确指向控件类<br><img src="https://cdn-a.markji.com/files/67f7e11cc7682418c3010e36_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Fy9gtrXjDpwId8aJIWWzlR_jTjI=" alt="图片1"></li></ul>]]></content>
    
    
    <summary type="html">详细介绍PlayImage类的实现过程，包括图像处理、线程安全以及控件提升等内容</summary>
    
    
    
    <category term="Qt开发" scheme="https://eatbreads.github.io/categories/Qt%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="https://eatbreads.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="图形界面" scheme="https://eatbreads.github.io/tags/%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>ReadThread线程类的实现</title>
    <link href="https://eatbreads.github.io/posts/a5d7054f.html"/>
    <id>https://eatbreads.github.io/posts/a5d7054f.html</id>
    <published>2025-04-10T15:36:00.000Z</published>
    <updated>2025-04-10T15:38:34.223Z</updated>
    
    <content type="html"><![CDATA[<h1>ReadThread线程类实现</h1><h2 id="类设计要点">类设计要点</h2><h3 id="头文件优化">头文件优化</h3><ul><li>核心：头文件中不需要包含其他类的完整定义</li><li>只需要前置声明即可</li><li>可以减少编译依赖</li></ul><h3 id="线程控制">线程控制</h3><ul><li>继承QThread类</li><li>重写run函数</li><li>使用start启动线程</li><li>使用quit请求停止</li><li>使用wait等待线程结束</li></ul><h2 id="计时器兼容性问题">计时器兼容性问题</h2><h3 id="Qt6废弃QTime">Qt6废弃QTime</h3><p>第一个遇到的兼容性问题：Qt6中QTime的start()和elapsed()方法已被废弃</p><h3 id="使用QElapsedTimer">使用QElapsedTimer</h3><ul><li>Qt5就建议使用QElapsedTimer替代QTime</li><li>QTime设计初衷是表示时间和测量时间间隔</li><li>在高精度计时方面存在限制</li><li>QElapsedTimer提供更高精度的时间测量</li><li>使用系统级别的高分辨率定时器</li></ul><h3 id="计时规则">计时规则</h3><ul><li>start()时记录一次时间</li><li>elapsed()返回与当前时间的差值</li></ul><h2 id="已知问题">已知问题</h2><h3 id="暂停功能bug">暂停功能bug</h3><ul><li>elapsed在触发暂停后仍会继续计时</li><li>导致暂停后播放会快速追回当前时间</li><li>实际效果等于没有暂停</li><li>后续会更新优化方案</li></ul>]]></content>
    
    
    <summary type="html">详细介绍ReadThread线程类的实现要点，包括类的设计、线程控制以及计时器的使用</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="多线程" scheme="https://eatbreads.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>VideoPlay的核心read函数详解</title>
    <link href="https://eatbreads.github.io/posts/db8f7402.html"/>
    <id>https://eatbreads.github.io/posts/db8f7402.html</id>
    <published>2025-04-10T08:09:18.000Z</published>
    <updated>2025-04-10T15:38:34.221Z</updated>
    
    <content type="html"><![CDATA[<h1>VideoPlay的read函数详解</h1><h2 id="Qt环境问题解决">Qt环境问题解决</h2><p>当Qt频繁出现无响应或无法打开的情况，可以尝试删除以下配置文件：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">C</span>:\Users\Administrator\AppData\Roaming\QtProject</span><br></pre></td></tr></table></figure><p>该文件可能会导致Qt启动时读取配置耗时过长。删除后Qt会重新生成配置文件。</p><h2 id="像素格式处理">像素格式处理</h2><p><img src="https://cdn-a.markji.com/files/67f778deeb27578088918a61_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:LVKgqx8MCHUU2TB74efe2NXBx7g=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f77b72eb2757808891e3e3_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4PjVjFpHeeO9wY5VVNSWkb8NH_A=" alt="图片1"></p><h3 id="格式设置限制">格式设置限制</h3><p>即使我们告诉解码器想要解码出YUV420P格式的帧，在硬件解码的情况下解码器可能会返回NV12格式，忽略设置的pix_fmt参数。</p><h3 id="格式设置时机">格式设置时机</h3><p>pix_fmt是在用视频流的para赋值解码器上下文那一步进行设置的。<br><img src="https://cdn-a.markji.com/files/67f783bceb2757808893994a_hd.png?e=1744301820167&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:WY4HpMocon_URRb_Kru0eDP7RXc=" alt="图片1"></p><h2 id="返回值内存管理">返回值内存管理</h2><p>二更：关于return返回的数据说明：</p><ul><li>本质上返回的是m_buffer</li><li>即使image是浅拷贝</li><li>但实际内存还在m_buffer中</li><li>因此不构成返回局部对象指针的问题</li></ul>]]></content>
    
    
    <summary type="html">详细介绍VideoPlay类中read函数的实现原理，包括像素格式设置、内存管理等关键点</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>VideoDecoder的初始化与Open函数实现</title>
    <link href="https://eatbreads.github.io/posts/5b754325.html"/>
    <id>https://eatbreads.github.io/posts/5b754325.html</id>
    <published>2025-04-09T15:48:31.000Z</published>
    <updated>2025-04-09T15:55:42.959Z</updated>
    
    <content type="html"><![CDATA[<h1>VideoDecoder初始化与Open函数实现</h1><h2 id="注意事项">注意事项</h2><ol><li>FFmpeg版本兼容</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">av_register_all</span>();  <span class="comment">// 在新版本中其实可省略</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67f62488c7682418c3cc7832_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:oTrBk8gkfJ-Rlyatgrju-KUFyxk=" alt="图片1"><br>2. 初始化函数调用</p><ul><li>init函数在构造函数中始终未被调用</li></ul><h2 id="CMake配置问题">CMake配置问题</h2><p>CMake设置的路径必须在add_executable()或qt_add_executable()之前配置<br><img src="https://cdn-a.markji.com/files/67f62b7ba5d66136f3e488be_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:1v6-tAQ1yC41ODKSUit7eHAEqvY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f62d0aa5d66136f3e4cbf7_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:2mguVmWtWNRi5TQkVHSRyyJDh-0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f636b9c7682418c3ced832_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:21PoT4SpANxk8Puopd7r611J5mo=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f637f7c7682418c3cef861_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MdbGRzt1HMDOqokUVj1Z4JeWb-Q=" alt="图片1"></p><h2 id="视频时长计算">视频时长计算</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_totalTime = m_formatContext-&gt;duration / (AV_TIME_BASE / <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><ul><li>计算视频总时长（毫秒）</li><li>AV_TIME_BASE是基础时间单位</li><li>1000用于转换为毫秒单位</li></ul><h2 id="有理数转换">有理数转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">qreal <span class="title">rationalToDouble</span><span class="params">(AVRational* rational)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>将AVRational结构体转换为double类型</li><li>AVRational包含分子和分母</li><li>函数执行简单的除法运算<br><img src="https://cdn-a.markji.com/files/67f63b24a5d66136f3e6ea92_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:RlWC5iKi_UH6CHulmFGSR-lD3ng=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67f63ce0c7682418c3cfb328_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:k__mLcJkG01gmeNAW4JXA00a58U=" alt="图片1"></li></ul><h2 id="解码器识别">解码器识别</h2><p>视频流中包含解码器ID信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videoStream-&gt;codecpar-&gt;codec_id  <span class="comment">// 例如：AV_CODEC_ID_H264</span></span><br></pre></td></tr></table></figure><ul><li>通过ID可以找到对应的解码器(如h264)</li></ul><h2 id="性能优化设置">性能优化设置</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许不符合规范的加速技巧</span></span><br><span class="line">m_codecContext-&gt;flags2 |= AV_CODEC_FLAG2_FAST;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置解码线程数</span></span><br><span class="line">m_codecContext-&gt;thread_count = <span class="number">8</span>;                 </span><br></pre></td></tr></table></figure><p>注意：线程数设置需要根据具体机器情况调整，8线程并不一定是最优选择，某些情况下单线程可能更快。<br><img src="https://cdn-a.markji.com/files/67f6415ea5d66136f3e79dae_hd.png?e=1744203917604&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:zkWzRHXHGqC5Tm1PlePkEmoNX-M=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">详细介绍VideoDecoder类的初始化过程和open函数的实现，包括FFmpeg相关配置和注意事项</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>rpc远程过程调用实现</title>
    <link href="https://eatbreads.github.io/posts/1a8fdb43.html"/>
    <id>https://eatbreads.github.io/posts/1a8fdb43.html</id>
    <published>2025-04-08T16:24:50.000Z</published>
    <updated>2025-04-08T16:32:36.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rpc远程调用实现"><a href="#rpc远程调用实现" class="headerlink" title="rpc远程调用实现"></a>rpc远程调用实现</h1><h2 id="bind函数-包装器"><a href="#bind函数-包装器" class="headerlink" title="bind函数(包装器)"></a>bind函数(包装器)</h2><p>就是先弄了个最顶层封装的Function,接收可调用函数和俩Datestream(里面是参数),然后用std的bind绑定wrap和fun和俩Datastream,发生如下操作(很多是编译期执行 )</p><p>包装器的第一参就是wrap,我们用模板来识别可调用函数的函数签名(返回值和参数列表),然后对args参数列表识别实际参数类型,然后使用这个些参数类型,定义出一个&lt;&gt;内部是这些的tuple</p><p>然后识别tuple模板参数个数,然后make出对应的下标列表index_sequence,然后把列表中的Id…开包,对每一个Id调用get<Id>,然后把Datestream内部的参数注入进get返回的引用</p><p>ps:bind这个操作只是生成了对应的fun和序列化的交互函数(使用std::bind),真正调用还在call,就是直接传入俩Datastream然后string名字匹配哈希表(value就是bind产生的function),然后就会去执行生成的模板函数了</p><p>ps:模板参数的命名就是函数模板就是F,返回类型就是R,元组的类型就是Tuple</p><p>二更：所以第一次wrap是bind主体，第二次wrap是为了分割出args和返回类型并且放进function，第三次wrap就是执行主体<br><img src="https://cdn-a.markji.com/files/66572f98d3cf30b45ac9b1e7_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5cVCjyDxIgcZcSXKQqj59oShaxA=" alt="图片1"><br>三更：这边function说只要两个参数，因为虽然内置的wrap还要求了一个fun,但是因为他已经被bind绑入了（包括this指针），所以确实参数就只需要那俩占位符，即这样操作bind就会生成一个function，返回类型是void且接受俩参数的<br><img src="https://cdn-a.markji.com/files/66572f98d3cf30b45ac9b1e7_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5cVCjyDxIgcZcSXKQqj59oShaxA=" alt="图片1"><br>三更：而且模板参数在传递的时候是不会发生改变的，只有一步从F函数指针变成了R和args，然后返回值的识别有一次是通过F向R转换，还有一次是手动<R>指定的<br><img src="https://cdn-a.markji.com/files/66572fb66ff0e9a10f1499b5_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:G4_7HHAE1QOQPHRApzLvn9peJiY=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/66572fc2d3cf30b45ac9b655_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:i7m8vpQnjYqeltmrVPcTCSidyzY=" alt="图片1"><br>然后是客户端调用<br><img src="https://cdn-a.markji.com/files/66572fea6ff0e9a10f14a02b_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4LlAxyGHi9rP9Oc7VrBYapSphrk=" alt="图片1"><br>然后是work函数<br><img src="https://cdn-a.markji.com/files/6657303bd3cf30b45ac9c418_hd.png?e=1744131868001&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Mt3hcyEFPmnOv_hQudoD0gCqmCU=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/665730576ff0e9a10f14aadc_hd.png?e=1744131868001&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:LZ9Ers_459wz5RfrPWrkkeyCAzc=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">记录RPC远程调用实现过程中的技术细节和更新说明</summary>
    
    
    
    <category term="后端开发" scheme="https://eatbreads.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="网络编程" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="RPC" scheme="https://eatbreads.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>RPC远程过程调用C++实现</title>
    <link href="https://eatbreads.github.io/posts/63d129aa.html"/>
    <id>https://eatbreads.github.io/posts/63d129aa.html</id>
    <published>2025-04-08T16:22:24.000Z</published>
    <updated>2025-04-08T16:32:36.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RPC远程过程调用C-实现"><a href="#RPC远程过程调用C-实现" class="headerlink" title="RPC远程过程调用C++实现"></a>RPC远程过程调用C++实现</h1><h2 id="核心实现原理"><a href="#核心实现原理" class="headerlink" title="核心实现原理"></a>核心实现原理</h2><p>RPC框架的核心在于函数绑定和参数传递机制。当调用<code>bind</code>函数时，会：</p><ol><li>将string类型的函数名和对应的函数指针(使用function封装)存入map</li><li>自动识别参数列表并生成模板元组来适配传参</li><li>通过函数名和序列化实现函数调用的参数传递</li><li>调用function包装器执行函数并将结果序列化返回给客户端</li></ol><h2 id="特性支持"><a href="#特性支持" class="headerlink" title="特性支持"></a>特性支持</h2><ul><li>支持自定义类型的RPC调用</li><li>只需要实现序列化接口即可</li><li>参考了buttonrpc开源项目的实现<br><img src="https://cdn-a.markji.com/files/6693b2eb63e4546df5d7a66c_hd.png?e=1744131868001&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:IwWqueUBKSldTG6TVdR2peqFuoU=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6693b2fa8f51739870084132_hd.png?e=1744131868001&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cr2upfN-vsSSiume4vDUFcSdGAs=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/6648498b462469d45e30440e_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ga0bTiENZ7QqsgjNIll-wWQuMIo=" alt="图片1"><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><img src="https://cdn-a.markji.com/files/66484c19462469d45e307b9b_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FF-D51l7RNwQVkl9iTQlQuJfetE=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/664850f6db29be03af40f184_hd.png?e=1744131868000&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:VeFg5vaofxivt9EU1DtCxw4W7H8=" alt="图片1"><br>在服务端声明并绑定函数：</li><li>第一个参数：函数名(string类型)</li><li>第二个参数：函数指针</li></ul><p>这种设计使得RPC调用变得简单直观，同时保持了良好的扩展性。</p>]]></content>
    
    
    <summary type="html">介绍基于C++实现的RPC远程过程调用框架，包括函数绑定、参数传递和序列化等核心功能</summary>
    
    
    
    <category term="后端开发" scheme="https://eatbreads.github.io/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="网络编程" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="RPC" scheme="https://eatbreads.github.io/tags/RPC/"/>
    
    <category term="分布式系统" scheme="https://eatbreads.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>介绍一下cpu中的yuv转rgb和opengl中的yuv转rgb和直接nv12转rbg方法</title>
    <link href="https://eatbreads.github.io/posts/f4cc5b12.html"/>
    <id>https://eatbreads.github.io/posts/f4cc5b12.html</id>
    <published>2025-04-08T15:59:22.000Z</published>
    <updated>2025-04-09T00:32:55.195Z</updated>
    
    <content type="html"><![CDATA[<h1>YUV/NV12到RGB的转换方案</h1><h2 id="CPU中的YUV转RGB">CPU中的YUV转RGB</h2><h3 id="FFmpeg方案">FFmpeg方案</h3><ul><li>FFmpeg解码默认输出YUV格式</li><li>使用<code>sws_getCachedContext</code>进行格式转换</li><li>转换目标格式为<code>AV_PIX_FMT_RGBA</code></li><li>适合简单场景，但CPU消耗较大<br><img src="https://cdn-a.markji.com/files/67efabbae940a885d8a18beb_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Dr3M6vI51akx8UsbYqxDKiHGGYY=" alt="图片1"></li></ul><h2 id="OpenGL中的YUV转RGB方案">OpenGL中的YUV转RGB方案</h2><h3 id="方案一：RGB纹理渲染">方案一：RGB纹理渲染</h3><p><img src="https://cdn-a.markji.com/files/67efabe2e940a885d8a18ea2_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:jqDoEHl78m5YLERVbYFjI-pErow=" alt="图片1"></p><ol><li>继承关系</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlayImage</span> : <span class="keyword">public</span> QOpenGLWidget, <span class="keyword">public</span> QOpenGLFunctions_3_3_Core</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializeGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并绑定VAO/VBO/IBO</span></span><br><span class="line">    <span class="comment">// 编译连接着色器程序</span></span><br><span class="line">    <span class="comment">// 启用顶点属性数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>图像更新</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateImage</span><span class="params">(<span class="type">const</span> QImage&amp; image)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 垂直翻转(OpenGL纹理Y轴相反)</span></span><br><span class="line">    m_texture = <span class="keyword">new</span> <span class="built_in">QOpenGLTexture</span>(image.<span class="built_in">mirrored</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>渲染</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定着色器程序</span></span><br><span class="line">    <span class="comment">// 绑定纹理</span></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    <span class="built_in">glDrawElements</span>(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：直接YUV渲染">方案二：直接YUV渲染</h3><p><img src="https://cdn-a.markji.com/files/67efac311137c8f4e5af9cb9_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:BvYuGOTK2QfpMlTtQ5sb0X1BJoA=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67efac3fe940a885d8a19690_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MFIybXXJT39g33YdPqRPOs2KGFA=" alt="图片1"></p><ol><li>数据传递</li></ol><ul><li>直接使用<code>AVFrame</code>传递解码数据</li><li>使用<code>BlockingQueuedConnection</code>确保数据安全</li></ul><ol start="2"><li>信号槽配置</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册AVFrame用于信号传递</span></span><br><span class="line"><span class="built_in">Q_DECLARE_METATYPE</span>(AVFrame)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接信号槽</span></span><br><span class="line"><span class="built_in">connect</span>(m_readThread, &amp;ReadThread::repaint,</span><br><span class="line">        playImage, &amp;PlayImage::repaint,</span><br><span class="line">        Qt::BlockingQueuedConnection);</span><br></pre></td></tr></table></figure><ol start="3"><li>纹理处理</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个纹理对应YUV分量</span></span><br><span class="line">QOpenGLTexture *m_texY, *m_texU, *m_texV;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置纹理单元</span></span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_y&quot;</span>, <span class="number">0</span>);</span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_u&quot;</span>, <span class="number">1</span>);</span><br><span class="line">m_program-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;tex_v&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>渲染实现</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_texY-&gt;<span class="built_in">bind</span>(<span class="number">0</span>);</span><br><span class="line">    m_texU-&gt;<span class="built_in">bind</span>(<span class="number">1</span>);</span><br><span class="line">    m_texV-&gt;<span class="built_in">bind</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行绘制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpenGL中直接处理NV12">OpenGL中直接处理NV12</h2><p><img src="https://cdn-a.markji.com/files/67efac7c1137c8f4e5afa991_hd.png?e=1744130053087&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:FoRKl2CActfg1Z33Ow7avwu4Sdc=" alt="图片1"></p><h3 id="优势">优势</h3><ul><li>避免CPU中的格式转换</li><li>性能提升约1/3</li><li>直接在GPU中完成转换</li></ul><h3 id="实现要点">实现要点</h3><ol><li>使用<code>av_hwframe_map</code>替代<code>av_hwframe_transfer_data</code></li><li>移除<code>sws_scale</code>相关代码</li><li>直接返回硬件帧</li></ol><h3 id="格式适配">格式适配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据输入格式选择初始化方式</span></span><br><span class="line">    <span class="keyword">if</span> (format == AV_PIX_FMT_NV12) &#123;</span><br><span class="line">        <span class="built_in">initializeNV12</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">initializeYUV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="渲染流程">渲染流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_format == AV_PIX_FMT_NV12) &#123;</span><br><span class="line">        <span class="comment">// NV12渲染流程</span></span><br><span class="line">        <span class="built_in">bindNV12Textures</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// YUV渲染流程</span></span><br><span class="line">        <span class="built_in">bindYUVTextures</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行绘制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能对比">性能对比</h2><ol><li><p>CPU转换方案</p><ul><li>实现简单</li><li>CPU占用高</li><li>适合简单场景</li></ul></li><li><p>OpenGL YUV方案</p><ul><li>中等复杂度</li><li>GPU处理</li><li>性能较好</li></ul></li><li><p>OpenGL NV12方案</p><ul><li>实现较复杂</li><li>性能最优</li><li>适合高性能需求</li></ul></li></ol><pre><code></code></pre>]]></content>
    
    
    <summary type="html">详细介绍在CPU和GPU中实现YUV/NV12到RGB转换的不同方案及其性能对比</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="图像处理" scheme="https://eatbreads.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>音视频软硬解码流程详解</title>
    <link href="https://eatbreads.github.io/posts/2c4a1d51.html"/>
    <id>https://eatbreads.github.io/posts/2c4a1d51.html</id>
    <published>2025-04-08T15:56:08.000Z</published>
    <updated>2025-04-08T15:57:10.126Z</updated>
    
    <content type="html"><![CDATA[<h1>音视频解码流程详解</h1><h2 id="软解码基础流程">软解码基础流程</h2><ol><li>打开输入文件</li><li>读取媒体文件信息</li><li>查询视频流</li><li>获取解码器</li><li>获取解码器上下文</li><li>使用视频流的codecpar为解码器上下文赋值</li><li>打开解码器</li><li>获取原始数据帧</li><li>将数据发送给解码器</li><li>从解码器读取解码后的数据</li><li>获取图像转换上下文</li><li>将解码的图像格式转换成QImage</li></ol><h2 id="硬解码流程">硬解码流程</h2><h3 id="基础步骤">基础步骤</h3><ol><li>打开输入文件<ul><li><code>avformat_open_input</code></li></ul></li><li>读取媒体文件信息<ul><li><code>avformat_find_stream_info</code></li></ul></li><li>查询视频流<ul><li><code>av_find_best_stream</code></li></ul></li><li>获取解码器<ul><li><code>avcodec_find_decoder</code></li></ul></li><li>获取解码器上下文<ul><li><code>avcodec_alloc_context3</code></li></ul></li><li>使用视频流的codecpar赋值<ul><li><code>avcodec_parameters_to_context</code></li></ul></li></ol><h3 id="硬件加速相关步骤">硬件加速相关步骤</h3><ol><li>检索编解码器支持的硬件配置<ul><li><code>avcodec_get_hw_config</code></li></ul></li><li>遍历支持的编解码器设备类型<ul><li><code>av_hwdevice_iterate_types</code></li><li>在构造函数中记录支持的类型到数组</li></ul></li><li>打开指定类型的编解码器设备<ul><li><code>av_hwdevice_ctx_create</code></li></ul></li><li>注册硬件像素格式回调<ul><li><code>m_codecContext-&gt;get_format = get_hw_format</code></li></ul></li></ol><h3 id="解码步骤">解码步骤</h3><ol><li>打开解码器<ul><li><code>avcodec_open2</code></li></ul></li><li>读取原始数据帧<ul><li><code>av_read_frame</code></li></ul></li><li>发送数据到解码器<ul><li><code>avcodec_send_packet</code></li></ul></li><li>读取解码后的数据<ul><li><code>avcodec_receive_frame</code></li></ul></li><li>GPU数据拷贝到CPU<ul><li><code>av_hwframe_transfer_data</code></li><li><code>av_hwframe_map(m_frameHW, m_frame, 0)</code></li></ul></li><li>获取图像转换上下文<ul><li><code>sws_getCachedContext</code></li></ul></li><li>转换为QImage格式<ul><li><code>sws_scale</code></li></ul></li></ol><h2 id="软解码显示实现-PlayImage类">软解码显示实现(PlayImage类)</h2><h3 id="基于QWidget">基于QWidget</h3><ol><li>接收图像信号并响应updateImage槽函数</li><li>转换为QPixmap</li><li>调用update触发重绘</li><li>paintEvent中绘制</li></ol><h3 id="YUV转RGB">YUV转RGB</h3><ul><li>FFmpeg默认解码为YUV格式</li><li>使用<code>sws_getCachedContext</code>转换为RGB(AV_PIX_FMT_RGBA)</li></ul><h2 id="OpenGL渲染优化">OpenGL渲染优化</h2><h3 id="软解码-OpenGL-YUV-RGB">软解码+OpenGL(YUV-&gt;RGB)</h3><ol><li>继承QOpenGLWidget和QOpenGLFunctions</li><li>initializeGL中设置VAO/VBO/IBO</li><li>updateImage中处理纹理</li><li>paintGL中执行绘制</li></ol><h3 id="软解码-OpenGL-直接YUV">软解码+OpenGL(直接YUV)</h3><ol><li>使用AVFrame直接传递</li><li>使用三个纹理处理YUV数据</li><li>在GPU中完成格式转换</li></ol><h3 id="硬解码-OpenGL-NV12">硬解码+OpenGL(NV12)</h3><ol><li>使用<code>av_hwframe_map</code>替代transfer_data</li><li>根据格式选择初始化方式</li><li>直接在GPU中完成NV12到RGB的转换</li></ol><h2 id="摄像头采集">摄像头采集</h2><ol><li>注册设备<ul><li><code>avdevice_register_all</code></li></ul></li><li>查询输入设备<ul><li><code>av_find_input_format</code></li></ul></li><li>执行标准解码流程</li><li>OpenGL中完成YUV转RGB</li></ol><h2 id="视频录制流程">视频录制流程</h2><ol><li>创建输出上下文<ul><li><code>avformat_alloc_output_context2</code></li></ul></li><li>初始化IO上下文<ul><li><code>avio_open</code></li></ul></li><li>配置编码器</li><li>创建视频流</li><li>写入头信息</li><li>编码循环</li><li>写入尾信息</li></ol>]]></content>
    
    
    <summary type="html">详细介绍音视频软解码和硬解码的实现流程，包括FFmpeg解码、OpenGL渲染等技术细节</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg命令行和API使用指南</title>
    <link href="https://eatbreads.github.io/posts/66a36265.html"/>
    <id>https://eatbreads.github.io/posts/66a36265.html</id>
    <published>2025-04-08T15:53:52.000Z</published>
    <updated>2025-04-08T15:55:01.820Z</updated>
    
    <content type="html"><![CDATA[<h1>FFmpeg使用指南</h1><h2 id="命令行参数">命令行参数</h2><h3 id="基础参数">基础参数</h3><ul><li><code>-a/vn</code>: 去掉音频或视频</li><li><code>-a/vcodec</code>: 指定音视频编码器<ul><li><code>copy</code>: 不重新编码</li><li>可指定为h264或aac等</li></ul></li></ul><h3 id="常用命令">常用命令</h3><h4 id="1-获取视频信息">1. 获取视频信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i video.avi</span><br></pre></td></tr></table></figure><h4 id="2-音视频流处理">2. 音视频流处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去掉视频流</span></span><br><span class="line">ffmpeg -i input.mp4 -an -vcodec copy output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 音频重编码为AAC</span></span><br><span class="line">ffmpeg -i input.mp4 -acodec aac output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为WAV格式</span></span><br><span class="line">ffmpeg -i input.mp4 -acodec pcm_s16le output.wav</span><br></pre></td></tr></table></figure><h4 id="3-视频截图">3. 视频截图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -ss 10 -frames:v 1 -s 1920x1080 output.jpg</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-ss &lt;时间&gt;</code>: 指定起始时间</li><li><code>-s &lt;宽度x高度&gt;</code>: 调整图片大小</li><li><code>-frames:v 1</code>: 只截取一帧</li></ul><h4 id="4-添加水印">4. 添加水印</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片水印</span></span><br><span class="line">ffmpeg -i input.mp4 -i logo.png -filter_complex <span class="string">&quot;overlay=10:10&quot;</span> output.mp4</span><br></pre></td></tr></table></figure><p>位置参数：</p><ul><li>左上角: <code>overlay=10:10</code></li><li>右上角: <code>overlay=W-w-10:10</code></li><li>左下角: <code>overlay=10:H-h-10</code></li><li>右下角: <code>overlay=W-w-10:H-h-10</code></li></ul><p>其中：</p><ul><li>W: 视频宽度</li><li>H: 视频高度</li><li>w: 水印宽度</li><li>h: 水印高度</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文字水印</span></span><br><span class="line">ffmpeg -i input.flv -vf <span class="string">&quot;drawtext=fontfile=simhei.ttf: text=&#x27;抖音&#x27;:x=100:y=10:fontsize=24:fontcolor=yellow:shadowy=2&quot;</span> drawtext.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># GIF水印</span></span><br><span class="line">ffmpeg -y -i test2.mp4 -ignore_loop 0 -i test.gif -filter_complex overlay=0:H-h test_out2.mp4</span><br></pre></td></tr></table></figure><h4 id="5-视频旋转">5. 视频旋转</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -vf <span class="string">&quot;transpose=1&quot;</span> out.mp4  <span class="comment"># 顺时针旋转90°</span></span><br></pre></td></tr></table></figure><h2 id="API使用">API使用</h2><h3 id="视频播放流程">视频播放流程</h3><h4 id="1-格式上下文-AVFormatContext">1. 格式上下文(AVFormatContext)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *pFormatCtx;</span><br><span class="line">pFormatCtx = <span class="built_in">avformat_alloc_context</span>();  <span class="comment">// 分配格式上下文</span></span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, filePath.<span class="built_in">toUtf8</span>().<span class="built_in">constData</span>(), <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// 初始化上下文</span></span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>);  <span class="comment">// 获取流信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找视频流索引</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</span><br><span class="line">        streamIndex = i;</span><br><span class="line">        isVideo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-解码器设置">2. 解码器设置</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AVCodecContext *pAVctx;  <span class="comment">// 解码器上下文</span></span><br><span class="line">AVCodec *pCodec;         <span class="comment">// 实际解码器</span></span><br><span class="line"></span><br><span class="line">pAVctx = <span class="built_in">avcodec_alloc_context3</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">avcodec_parameters_to_context</span>(pAVctx, pFormatCtx-&gt;streams[streamIndex]-&gt;codecpar);</span><br><span class="line">pCodec = <span class="built_in">avcodec_find_decoder</span>(pAVctx-&gt;codec_id);</span><br><span class="line"><span class="built_in">avcodec_open2</span>(pAVctx, pCodec, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h4 id="3-数据包和帧处理">3. 数据包和帧处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AVPacket *pAVpkt = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">AVFrame *pAVframe = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">AVFrame *pAVframeRGB = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像转换上下文</span></span><br><span class="line">SwsContext *pSwsCtx = <span class="built_in">sws_getContext</span>(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">av_read_frame</span>(pFormatCtx, pAVpkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">avcodec_send_packet</span>(pAVctx, pAVpkt);</span><br><span class="line">    <span class="built_in">avcodec_receive_frame</span>(pAVctx, pAVframe);</span><br><span class="line">    <span class="built_in">sws_scale</span>(...);  <span class="comment">// 图像转换</span></span><br><span class="line">    <span class="comment">// 显示到窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音频录制流程">音频录制流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">avdevice_register_all</span>();</span><br><span class="line"><span class="type">const</span> AVInputFormat *fmt = <span class="built_in">av_find_input_format</span>(FMT_NAME);</span><br><span class="line"><span class="built_in">avformat_open_input</span>(...);  <span class="comment">// 打开麦克风</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 录制循环</span></span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    <span class="built_in">av_read_frame</span>(ctx, &amp;pkt);  <span class="comment">// 读取PCM数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束处理</span></span><br><span class="line"><span class="built_in">writeWavHeader</span>(outputFile, <span class="number">44100</span>, <span class="number">2</span>, <span class="number">16</span>);  <span class="comment">// 更新WAV头部</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">详细介绍FFmpeg的常用命令行参数和API调用方法</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="命令行工具" scheme="https://eatbreads.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>音视频基础知识总结</title>
    <link href="https://eatbreads.github.io/posts/1a7c13c3.html"/>
    <id>https://eatbreads.github.io/posts/1a7c13c3.html</id>
    <published>2025-04-08T15:51:56.000Z</published>
    <updated>2025-04-08T15:53:16.141Z</updated>
    
    <content type="html"><![CDATA[<h1>音视频基础知识</h1><h2 id="基本概念">基本概念</h2><h3 id="码率-比特率">码率/比特率</h3><ul><li>单位时间内传输的数据量，单位为kbps(千位每秒)</li><li>分类：<ul><li>恒定码率(CBR)</li><li>动态码率(VBR)</li></ul></li></ul><h3 id="分辨率">分辨率</h3><ol><li>视频分辨率<ul><li>宽×高，如1080P、2K等</li></ul></li><li>屏幕分辨率<ul><li>单位是ppi(每英寸像素数)</li></ul></li><li>位分辨率<ul><li>每个像素点存储信息的位数</li><li>如8位、16位色彩等</li></ul></li></ol><h3 id="帧率">帧率</h3><ol><li>视频帧率<ul><li>由视频本身决定</li><li>FPS(每秒显示帧数)</li></ul></li><li>显示帧率<ul><li>由显示器决定</li><li>显示器刷新率</li></ul></li></ol><h3 id="像素格式">像素格式</h3><ol><li>RGBA<ul><li>红绿蓝和Alpha透明度</li><li>类似于已完成的成品</li></ul></li><li>YUV<ul><li>Y：亮度</li><li>U：色度</li><li>V：对比度</li><li>注：视频常用YUV，因为RGBA占用内存太大</li><li>压缩后转为h264(通过编码器)</li></ul></li></ol><h3 id="音频格式">音频格式</h3><ol><li>PCM<ul><li>原始数据</li><li>压缩后转为AAC帧(通过AAC编码器)</li></ul></li></ol><h2 id="画质相关">画质相关</h2><h3 id="画质要素">画质要素</h3><ol><li>清晰度：细节纹理和边界的清晰程度</li><li>锐度：图像边缘的锐利程度</li><li>解析度<ul><li>像素点数量</li><li>分辨率越高解析度越高</li></ul></li><li>色彩纯度：三原色在色彩中的百分比，越高越鲜艳</li></ol><h3 id="色域与HDR">色域与HDR</h3><ul><li>色域：能表达的颜色范围区域</li><li>HDR：高动态范围，可超出普通[0,1]范围</li></ul><h2 id="封装与编码">封装与编码</h2><h3 id="封装格式">封装格式</h3><p>视频封装格式就像一个包装盒，包含：</p><ol><li>格式头：类似快递单号，包含文件元数据</li><li>媒体信息：包括时长、格式、比特率等</li><li>音视频轨：实际的音频、视频、字幕数据</li><li>视频轨索引：指示播放器数据存储位置<br>常见格式：MP4、MKV、MOV等</li></ol><h3 id="编码协议">编码协议</h3><ul><li>是压缩原始视频数据的方式</li><li>h265压缩率更高但解码要求更高</li></ul><h3 id="音频相关">音频相关</h3><ol><li>采样率：每秒采样次数(人耳感知范围20Hz~20kHz)</li><li>声道：独立音频信号的采集/回放位置</li><li>音频封装格式：mp3、wav、aac等</li><li>音频编码协议：mp3、aac等</li></ol><h2 id="H264编码原理">H264编码原理</h2><h3 id="码流文件分层">码流文件分层</h3><ol><li>VAL(视频编码层)<ul><li>压缩编码后的视频数据序列</li></ul></li><li>NAL(网络提取层)<ul><li>负责网络传输打包</li><li>本地和网络播放都需要</li><li>本质是打包并按序发送给解码器</li></ul></li></ol><h3 id="帧类型">帧类型</h3><ol><li>I帧：完整压缩帧</li><li>P帧：只编码与前帧差异</li><li>B帧：参考前后帧</li><li>IDR帧：特殊I帧，用于GOP重置</li><li>GOP组：图像组，关键帧间隔</li></ol>]]></content>
    
    
    <summary type="html">详细介绍音视频开发中的基础概念，包括码率、分辨率、帧率等核心知识点</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="编解码" scheme="https://eatbreads.github.io/tags/%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>解决云服务器Docker仓库访问问题</title>
    <link href="https://eatbreads.github.io/posts/f4beb750.html"/>
    <id>https://eatbreads.github.io/posts/f4beb750.html</id>
    <published>2025-04-07T13:10:31.000Z</published>
    <updated>2025-04-07T13:11:35.728Z</updated>
    
    <content type="html"><![CDATA[<h1>云服务器运行Superset遇到的问题及解决方案</h1><h2 id="Docker镜像下载问题">Docker镜像下载问题</h2><h3 id="初始尝试">初始尝试</h3><p>在使用docker-compose部署Superset时，遇到镜像无法下载的问题。虽然通过在<code>/etc/docker/daemon.json</code>中添加国内镜像代理成功下载了redis、postgresql等镜像，但Superset本体镜像始终无法下载。</p><h3 id="解决方案">解决方案</h3><p>采用本地打包上传的方式解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地打包镜像</span></span><br><span class="line">docker save -o apache-superset.tar apachesuperset.docker.scarf.sh/apache/superset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传到服务器</span></span><br><span class="line">scp apache-superset.tar ubuntu@43.138.190.230:/home/ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器端加载镜像</span></span><br><span class="line">docker load -i /home/ubuntu/apache-superset.tar</span><br></pre></td></tr></table></figure><h2 id="访问连接问题">访问连接问题</h2><h3 id="遇到的情况">遇到的情况</h3><ol><li>直接通过公网IP访问无响应</li><li>VSCode远程连接并端口转发后，可以通过localhost:8088访问</li><li>Postman测试显示502 Bad Gateway</li></ol><h3 id="解决步骤">解决步骤</h3><ol><li>检查并配置服务器防火墙</li><li>配置后成功通过Postman连接</li><li>Superset web界面也可以正常访问<br><img src="https://cdn-a.markji.com/files/67efcd9ae940a885d8a48f83_hd.png?e=1744033979105&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:C0FkwH4dORtyDjhWTd4laK_13UU=" alt="图片1"></li></ol><h2 id="MySQL部署问题">MySQL部署问题</h2><p>同样遇到了VSCode连接问题，但最终也得到解决。</p><h2 id="总结经验">总结经验</h2><ol><li>国内环境下可能需要使用镜像打包传输的方式</li><li>注意检查防火墙配置</li><li>端口转发可以作为临时的调试方案</li></ol>]]></content>
    
    
    <summary type="html">记录在云服务器上部署Superset时遇到的Docker镜像下载和访问问题及解决方案</summary>
    
    
    
    <category term="运维笔记" scheme="https://eatbreads.github.io/categories/%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Docker" scheme="https://eatbreads.github.io/tags/Docker/"/>
    
    <category term="云服务器" scheme="https://eatbreads.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Superset" scheme="https://eatbreads.github.io/tags/Superset/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL的GLSL语法基础</title>
    <link href="https://eatbreads.github.io/posts/f4cb9256.html"/>
    <id>https://eatbreads.github.io/posts/f4cb9256.html</id>
    <published>2025-04-07T13:07:49.000Z</published>
    <updated>2025-04-07T13:09:32.365Z</updated>
    
    <content type="html"><![CDATA[<h1>OpenGL GLSL语法基础</h1><h2 id="基本类型">基本类型</h2><h3 id="sampler">sampler</h3><p>采样器类型，作为访问纹理图像的不透明句柄。</p><h3 id="类型转换">类型转换</h3><p>GLSL中变量的类型转换非常严格，没有隐式类型转换，比C++的要求更严格。不同类型间的转换需要使用类似构造函数的语法。</p><h2 id="向量和矩阵">向量和矩阵</h2><h3 id="向量特性">向量特性</h3><ul><li>向量不是数组（例如<code>float coeff[3]</code>才是数组）</li><li>OpenGL的向量使用列主序，与C/C++不同，相当于斜对角镜像</li><li>向量默认是float类型，如vec2/3/4，mat2/3/4或mat2x3，mat3x4</li><li>整型向量使用ivec前缀</li><li>布尔向量使用bvec前缀</li></ul><h3 id="矩阵表示">矩阵表示</h3><p>mat3x4表示三列四行的矩阵，对应C++中的[4][3]矩阵</p><h2 id="限定符">限定符</h2><h3 id="布局限定符-layout">布局限定符(layout)</h3><ul><li>只能用于顶点着色器的输入</li><li>顶点着色器的输出和片段着色器不可使用</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> vPosition;  <span class="comment">// 指定输入变量vPosition的绑定位置为0</span></span><br></pre></td></tr></table></figure><h3 id="数据传输">数据传输</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将顶点数组传入着色器向量</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, vVertices);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活对应位置的向量</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="类型限定符">类型限定符</h3><h4 id="in">in</h4><p>用于声明着色器的输入变量</p><h4 id="out">out</h4><p>声明着色器阶段的输出变量，这些变量会传递到下一个着色器阶段</p><h4 id="invariant">invariant</h4><p>确保多道渲染时着色器计算结果的一致性，避免因计算顺序等因素导致的误差</p><h4 id="uniform">uniform</h4><ul><li>指定uniform类型变量，其值在绘制调用间保持不变</li><li>操作uniform的方法：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(programId);</span><br><span class="line"><span class="built_in">glUniform2f</span>(offsetLocationId, fXOffset, fYOffset);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">OpenGL着色器语言GLSL的基础语法介绍</summary>
    
    
    
    <category term="图形编程" scheme="https://eatbreads.github.io/categories/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="GLSL" scheme="https://eatbreads.github.io/tags/GLSL/"/>
    
    <category term="图形编程" scheme="https://eatbreads.github.io/tags/%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Qt+OpenGL+FFmpeg实现GPU硬解码视频播放</title>
    <link href="https://eatbreads.github.io/posts/f4071fe9.html"/>
    <id>https://eatbreads.github.io/posts/f4071fe9.html</id>
    <published>2025-04-01T15:53:33.000Z</published>
    <updated>2025-04-01T15:56:50.433Z</updated>
    
    <content type="html"><![CDATA[<h1>OpenGL+FFmpeg实现GPU硬解码视频播放</h1><h2 id="OpenGL渲染流程">OpenGL渲染流程</h2><h3 id="1-着色器准备">1. 着色器准备</h3><p>需要准备:</p><ul><li>顶点着色器代码</li><li>片段着色器代码</li><li>顶点数组</li><li>索引缓冲对象(IBO)数组</li></ul><h3 id="2-缓冲区设置">2. 缓冲区设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并绑定VAO</span></span><br><span class="line">GLuint VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并绑定VBO和IBO</span></span><br><span class="line">GLuint VBO, IBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;IBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入数据</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, IBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><h3 id="3-着色器编译与链接">3. 着色器编译与链接</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译着色器</span></span><br><span class="line">program.<span class="built_in">addShaderFromSourceCode</span>(QOpenGLShader::Vertex, vertexShaderSource);</span><br><span class="line">program.<span class="built_in">addShaderFromSourceCode</span>(QOpenGLShader::Fragment, fragmentShaderSource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接程序</span></span><br><span class="line">program.<span class="built_in">link</span>();</span><br><span class="line">program.<span class="built_in">bind</span>();</span><br></pre></td></tr></table></figure><h3 id="4-属性指针设置">4. 属性指针设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应着色器中的layout (location = 0)</span></span><br><span class="line">program.<span class="built_in">enableAttributeArray</span>(<span class="number">0</span>);  <span class="comment">// 顶点位置</span></span><br><span class="line">program.<span class="built_in">enableAttributeArray</span>(<span class="number">1</span>);  <span class="comment">// 纹理坐标</span></span><br></pre></td></tr></table></figure><h3 id="5-矩阵变换">5. 矩阵变换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置MVP矩阵</span></span><br><span class="line">QMatrix4x4 model, view, projection;</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">program.<span class="built_in">setUniformValue</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br></pre></td></tr></table></figure><h2 id="FFmpeg硬解码部分">FFmpeg硬解码部分</h2><h3 id="1-初始化硬解码器">1. 初始化硬解码器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找硬解码器</span></span><br><span class="line"><span class="type">const</span> AVCodec *codec = <span class="built_in">avcodec_find_decoder_by_name</span>(<span class="string">&quot;h264_cuvid&quot;</span>); <span class="comment">// NVIDIA GPU</span></span><br><span class="line"><span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">    codec = <span class="built_in">avcodec_find_decoder_by_name</span>(<span class="string">&quot;h264_qsv&quot;</span>);  <span class="comment">// Intel GPU</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-解码并传输到GPU">2. 解码并传输到GPU</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解码后直接得到GPU纹理</span></span><br><span class="line">AVFrame *frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="built_in">avcodec_send_packet</span>(codecContext, packet);</span><br><span class="line"><span class="built_in">avcodec_receive_frame</span>(codecContext, frame);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OpenGL纹理</span></span><br><span class="line">GLuint texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><h2 id="渲染循环">渲染循环</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">paintGL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清空缓冲</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定程序和纹理</span></span><br><span class="line">    program.<span class="built_in">bind</span>();</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67ea86de8e36ed84184859cb_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:a8msW1EK2bX_E-38bWanGWW4DcI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea87b4205d5713c0bf8b46_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5JY2dB8a0x_1kstKpMmOT5jajaw=" alt="图片1"></p><h2 id="注意事项">注意事项</h2><ol><li><p>硬解码支持:</p><ul><li>需要确保GPU支持对应格式的硬解码</li><li>需要正确安装GPU驱动</li></ul></li><li><p>性能优化:</p><ul><li>使用PBO(Pixel Buffer Object)进行异步传输</li><li>考虑使用多重缓冲</li></ul></li><li><p>同步处理:</p><ul><li>注意音视频同步</li><li>控制帧率</li></ul></li></ol>]]></content>
    
    
    <summary type="html">使用OpenGL实现GPU硬解码视频播放的完整流程</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="OpenGL" scheme="https://eatbreads.github.io/tags/OpenGL/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
    <category term="GPU加速" scheme="https://eatbreads.github.io/tags/GPU%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Qt5+FFmpeg实现视频软解码播放</title>
    <link href="https://eatbreads.github.io/posts/fd1aef76.html"/>
    <id>https://eatbreads.github.io/posts/fd1aef76.html</id>
    <published>2025-04-01T15:41:20.000Z</published>
    <updated>2025-04-01T15:45:40.943Z</updated>
    
    <content type="html"><![CDATA[<h1>Qt5+FFmpeg实现视频软解码播放</h1><h2 id="基本流程">基本流程</h2><ol><li>使用FFmpeg解封装获取视频流</li><li>对视频流进行解码得到原始数据</li><li>将解码后的数据转换为Qt可显示的格式</li><li>使用Qt组件显示视频画面</li></ol><h2 id="主要步骤">主要步骤</h2><h3 id="1-初始化FFmpeg">1. 初始化FFmpeg</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册所有组件</span></span><br><span class="line"><span class="built_in">av_register_all</span>();</span><br><span class="line"><span class="comment">// 打开视频文件</span></span><br><span class="line"><span class="built_in">avformat_open_input</span>(&amp;formatContext, filename, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 获取流信息</span></span><br><span class="line"><span class="built_in">avformat_find_stream_info</span>(formatContext, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h3 id="2-查找视频解码器">2. 查找视频解码器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取视频流索引</span></span><br><span class="line">videoIndex = <span class="built_in">av_find_best_stream</span>(formatContext, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取解码器</span></span><br><span class="line">AVCodec *codec = <span class="built_in">avcodec_find_decoder</span>(formatContext-&gt;streams[videoIndex]-&gt;codecpar-&gt;codec_id);</span><br></pre></td></tr></table></figure><h3 id="3-解码并显示">3. 解码并显示</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取视频帧</span></span><br><span class="line"><span class="built_in">av_read_frame</span>(formatContext, packet);</span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="built_in">avcodec_send_packet</span>(codecContext, packet);</span><br><span class="line"><span class="built_in">avcodec_receive_frame</span>(codecContext, frame);</span><br><span class="line"><span class="comment">// 转换为RGB格式</span></span><br><span class="line"><span class="built_in">sws_scale</span>(swsContext, frame-&gt;data, frame-&gt;linesize, <span class="number">0</span>, codecContext-&gt;height,</span><br><span class="line">          frameRGB-&gt;data, frameRGB-&gt;linesize);</span><br><span class="line"><span class="comment">// 显示画面</span></span><br><span class="line"><span class="function">QImage <span class="title">image</span><span class="params">(frameRGB-&gt;data[<span class="number">0</span>], codecContext-&gt;width, codecContext-&gt;height, </span></span></span><br><span class="line"><span class="params"><span class="function">             QImage::Format_RGB32)</span></span>;</span><br><span class="line">label-&gt;<span class="built_in">setPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(image));</span><br></pre></td></tr></table></figure><h2 id="部分代码图片">部分代码图片</h2><p><img src="https://cdn-a.markji.com/files/67ea4ced8e36ed841840aef9_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:0oKoHUP8QToYpe52ZzlRFuDU4fI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea4d4c205d5713c0b740e2_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ArjYpTLoeAf_jD2eYls8bfegURI=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea4e4a8e36ed841840da6a_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:p9GWgo9KlxiCFrWDpwrGFFEOcb8=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea5167205d5713c0b7d299_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:pnGhA5vUgjOD2j1jeIcako17Ku0=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea51ea205d5713c0b7e150_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:kYBdJwcbpc9hzbyzsEt6QVNkaNQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54818e36ed8418422ffe_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:31FoxGoEK8vYqAJKDGWXS35mbSQ=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54af8e36ed8418423956_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:M65_RmAy6Z3G-i1E-F1oQbEpEDA=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea54d68e36ed8418423ff2_hd.png?e=1743524616981&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:dl3u7WCx1V5fZlwBV1tIqEvo9vs=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea56d7205d5713c0b887a0_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:wULFepBr_NTRnAr1AFkRYQDWsrk=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67ea5a08205d5713c0b92436_hd.png?e=1743524616982&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Eo7PAY6RNuLrWE9awS8bpV4Mcrc=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">记录使用Qt5和FFmpeg实现视频软解码播放的过程</summary>
    
    
    
    <category term="音视频开发" scheme="https://eatbreads.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>在Qt中使用FFmpeg</title>
    <link href="https://eatbreads.github.io/posts/9b502338.html"/>
    <id>https://eatbreads.github.io/posts/9b502338.html</id>
    <published>2025-03-30T15:57:37.000Z</published>
    <updated>2025-03-30T16:00:01.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Qt中使用FFmpeg实现播放和录音"><a href="#在Qt中使用FFmpeg实现播放和录音" class="headerlink" title="在Qt中使用FFmpeg实现播放和录音"></a>在Qt中使用FFmpeg实现播放和录音</h1><h2 id="初始尝试"><a href="#初始尝试" class="headerlink" title="初始尝试"></a>初始尝试</h2><p>从CSDN中找到了对应的库并进行修改，最终编译成功。但运行时发现没有对应的输入声音设备。</p><h2 id="查看设备"><a href="#查看设备" class="headerlink" title="查看设备"></a>查看设备</h2><p>使用FFmpeg命令查看可用设备:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -list_devices <span class="literal">true</span> -f dshow -i dummy</span><br></pre></td></tr></table></figure><br><img src="https://cdn-a.markji.com/files/67e7e6c2205d5713c080d12b_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:HlFFCuvBB0KSVXRTfKUfHs_zWYY=" alt="图片1"></p><h2 id="录制测试"><a href="#录制测试" class="headerlink" title="录制测试"></a>录制测试</h2><p>尝试直接使用FFmpeg命令录制:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f dshow -i audio=<span class="string">&quot;麦克风阵列 (Realtek(R) Audio)&quot;</span> -t 5 test.wav</span><br></pre></td></tr></table></figure><br>录制失败，最后发现是没有打开麦克风权限。解决权限问题后成功录制音频。<br><img src="https://cdn-a.markji.com/files/67e7f6222f58dfdf11a28259_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:P57m6HSucCpw477ZThLl9ycR9sE=" alt="图片1"></p><h2 id="音频播放实现"><a href="#音频播放实现" class="headerlink" title="音频播放实现"></a>音频播放实现</h2><p>在论坛找到播放代码，发现使用的是<code>&lt;QAudioFormat&gt;</code>中的<code>QAudioOutput</code>。但在Qt6中它已被<code>QAudioSink</code>取代。</p><h2 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h2><p>添加头文件后仍然报错，最终在CMakeLists.txt中添加:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Qt6::Multimedia</span><br></pre></td></tr></table></figure><br>才解决了头文件找不到的问题。<br><img src="https://cdn-a.markji.com/files/67e7fa65205d5713c08396ca_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:UVepqCC-P2xPFN7e-CcqjiRjrEU=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e80df9205d5713c086279e_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:LkbnqLWkqBpgs5XhdSxMzqpyeRk=" alt="图片1"></p><h2 id="重采样问题"><a href="#重采样问题" class="headerlink" title="重采样问题"></a>重采样问题</h2><p>重采样相关的代码编译一直不通过。</p><p>即使参考官方文档的示例也无法运行，最终不得不寻找其他解决方案。<br> <img src="https://cdn-a.markji.com/files/67e812cf205d5713c086a286_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Iidek_AwIhs3x_vdFwJcPRHMIvg=" alt="图片1"><br> <img src="https://cdn-a.markji.com/files/67e816252f58dfdf11a68af8_hd.png?e=1743352806367&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:vz8s-IeSIVWjNEB1jsY88wphH1o=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">记录在Qt中使用FFmpeg实现音视频播放和录制的过程</summary>
    
    
    
    <category term="Qt开发" scheme="https://eatbreads.github.io/categories/Qt%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="音视频" scheme="https://eatbreads.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    <category term="Qt" scheme="https://eatbreads.github.io/tags/Qt/"/>
    
    <category term="FFmpeg" scheme="https://eatbreads.github.io/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>封装一个好用的C++20协程</title>
    <link href="https://eatbreads.github.io/posts/5950a8c.html"/>
    <id>https://eatbreads.github.io/posts/5950a8c.html</id>
    <published>2025-03-27T09:52:50.000Z</published>
    <updated>2025-03-28T07:18:33.692Z</updated>
    
    <content type="html"><![CDATA[<h1>封装C++20协程</h1><h2 id="基本概念">基本概念</h2><p>在C++20中,只要函数返回值是Task类型,并使用co_return返回,该函数就自动成为一个协程函数。</p><p>Task不仅仅是一个&quot;配置文件&quot;,它还承担着协程的核心管理职责。<br><img src="https://cdn-a.markji.com/files/67e5149181bdefd1be1b48a1_hd.png?e=1743071911923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:qD4gzPadJ_pcN2NUgOz7CfrLvuA=" alt="图片1"></p><h2 id="核心原理">核心原理</h2><h3 id="协程的执行控制">协程的执行控制</h3><p>一个返回Task的函数本身就是协程,其内部代码会在以下情况下异步执行:</p><ul><li>co_await 语句控制</li><li>co_return 语句控制</li></ul><h3 id="恢复协程的两种方式">恢复协程的两种方式</h3><ol><li>内部恢复:</li></ol><ul><li>通过handle.resume()</li><li>由异步等待操作触发(如Delay的await_suspend)</li></ul><ol start="2"><li>外部恢复:</li></ol><ul><li>通过task2.resume()显式调用</li><li>主动从外部恢复协程执行</li></ul><p>这两种方式都会立即恢复协程并从挂起点继续执行,最终到达co_return。</p><h2 id="实践发现">实践发现</h2><p>在实际使用中发现一个有趣的现象:</p><ul><li>注释掉handle.resume()不影响程序运行</li><li>但注释掉main函数中的resume()会导致程序卡住<br><img src="https://cdn-a.markji.com/files/67e50d7bd5e9e782bf746323_hd.png?e=1743071911923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Bqc5H0LAPJjBWn_d_qcFVY0rLxk=" alt="图片1"></li></ul><h2 id="编译命令">编译命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">test</span> -std=c++20 test.cpp</span><br></pre></td></tr></table></figure><h2 id="完整头文集">完整头文集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        T value_;</span><br><span class="line">        std::exception_ptr exception_;</span><br><span class="line"></span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">            value_ = std::<span class="built_in">move</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            exception_ = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Awaiter 支持</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存当前等待的协程句柄</span></span><br><span class="line">        waiting_handle_ = handle;</span><br><span class="line">        <span class="comment">// 恢复当前任务的执行</span></span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_) &#123;</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(handle_.<span class="built_in">promise</span>().value_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">handle_</span>(handle) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(Task&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">handle_</span>(other.handle_) &#123;</span><br><span class="line">        other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(Task&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">            handle_ = other.handle_;</span><br><span class="line">            other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_)</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(handle_.<span class="built_in">promise</span>().value_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle_.<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; handle_;</span><br><span class="line">    <span class="keyword">mutable</span> std::coroutine_handle&lt;&gt; waiting_handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化 void 类型的 Task</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>&lt;<span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        std::exception_ptr exception_;</span><br><span class="line"></span><br><span class="line">        <span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">get_return_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Task</span>&lt;<span class="type">void</span>&gt;(std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_void</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            exception_ = std::<span class="built_in">current_exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Awaiter 支持</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        waiting_handle_ = handle;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_) &#123;</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(std::coroutine_handle&lt;promise_type&gt; handle) : <span class="built_in">handle_</span>(handle) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Task&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Task</span>(Task&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">handle_</span>(other.handle_) &#123;</span><br><span class="line">        other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Task&amp; <span class="keyword">operator</span>=(Task&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle_) handle_.<span class="built_in">destroy</span>();</span><br><span class="line">            handle_ = other.handle_;</span><br><span class="line">            other.handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handle_.<span class="built_in">promise</span>().exception_)</span><br><span class="line">            std::<span class="built_in">rethrow_exception</span>(handle_.<span class="built_in">promise</span>().exception_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        handle_.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">done</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handle_.<span class="built_in">done</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::coroutine_handle&lt;promise_type&gt; handle_;</span><br><span class="line">    <span class="keyword">mutable</span> std::coroutine_handle&lt;&gt; waiting_handle_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyCoroutine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例: 延迟执行的awaiter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delay</span> &#123;</span><br><span class="line">    std::chrono::milliseconds duration_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Delay</span><span class="params">(std::chrono::milliseconds duration)</span> : duration_(duration) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">thread</span>([handle, <span class="keyword">this</span>]() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(duration_);</span><br><span class="line">            <span class="comment">//handle.resume();</span></span><br><span class="line">        &#125;).<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Task&lt;<span class="type">int</span>&gt; <span class="title">simple_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始执行任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">42</span>;  <span class="comment">// 直接返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 带延迟的异步任务</span></span><br><span class="line"><span class="function">Task&lt;std::string&gt; <span class="title">delayed_task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;开始延迟任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">co_await</span> <span class="title">Delay</span><span class="params">(std::chrono::milliseconds(<span class="number">4000</span>))</span></span>;  <span class="comment">// 等待1秒</span></span><br><span class="line">    <span class="keyword">co_return</span> <span class="string">&quot;完成&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例3: 组合多个异步任务</span></span><br><span class="line"><span class="function">Task&lt;<span class="type">void</span>&gt; <span class="title">combined_tasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result1 = <span class="keyword">co_await</span> <span class="built_in">simple_task</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个任务结果: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> result2 = <span class="keyword">co_await</span> <span class="built_in">delayed_task</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第二个任务结果: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">co_return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行简单任务</span></span><br><span class="line">    <span class="keyword">auto</span> task1 = <span class="built_in">simple_task</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">1.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">1.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;简单任务结果: &quot;</span> &lt;&lt; task<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行延迟任务</span></span><br><span class="line">    <span class="keyword">auto</span> task2 = <span class="built_in">delayed_task</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">2.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">2.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;延迟任务结果: &quot;</span> &lt;&lt; task<span class="number">2.</span><span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行组合任务</span></span><br><span class="line">    <span class="keyword">auto</span> task3 = <span class="built_in">combined_tasks</span>();</span><br><span class="line">    <span class="keyword">while</span> (!task<span class="number">3.</span><span class="built_in">done</span>()) &#123;</span><br><span class="line">        task<span class="number">3.</span><span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    task<span class="number">3.</span><span class="built_in">get</span>();  <span class="comment">// 对于void类型的Task，仍然需要调用get()来检查异常</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>## 注意事项1. 协程函数必须:   - 返回Task类型   - 使用co_return返回值2. 恢复机制选择:   - 内部恢复适合自动触发的场景   - 外部恢复适合需要手动控制的场景3. 性能考虑:   - 协程切换有一定开销   - 适合IO密集型任务   - 不适合CPU密集型计算</code></pre>]]></content>
    
    
    <summary type="html">介绍如何封装和使用C++20协程功能</summary>
    
    
    
    <category term="C++开发" scheme="https://eatbreads.github.io/categories/C-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="协程" scheme="https://eatbreads.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="异步编程" scheme="https://eatbreads.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>回调地狱和解决方法</title>
    <link href="https://eatbreads.github.io/posts/f3d7b43c.html"/>
    <id>https://eatbreads.github.io/posts/f3d7b43c.html</id>
    <published>2025-03-27T09:48:16.000Z</published>
    <updated>2025-03-28T07:18:33.689Z</updated>
    
    <content type="html"><![CDATA[<h1>回调地狱及其解决方案</h1><h2 id="什么是回调地狱">什么是回调地狱</h2><p>回调地狱(Callback Hell)一般指的是回调函数层层嵌套的现象,这种代码结构会导致:</p><ul><li>代码难以理解</li><li>维护成本高</li><li>调试困难</li></ul><h2 id="常见场景">常见场景</h2><p>回调地狱常见于异步编程中,特别是:</p><ol><li>事件驱动模型</li><li>基于回调的异步操作</li><li>网络请求</li><li>文件读取</li><li>定时任务</li></ol><h2 id="主要问题">主要问题</h2><h3 id="1-状态传递困难">1. 状态传递困难</h3><p>多层嵌套的回调需要在不同层级间传递各种状态,导致:</p><ul><li>代码难以调试</li><li>错误追踪困难</li><li>状态管理复杂</li></ul><h3 id="2-事件依赖链">2. 事件依赖链</h3><p>典型例子是处理EPOLLIN事件时需要等待其他异步事件完成,形成复杂的事件依赖关系。<br><img src="https://cdn-a.markji.com/files/67e4f7d681bdefd1be164eb2_hd.png?e=1743071664551&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:S7s8WGObEQ7yLIBHFVNx3hy0zQ0=" alt="图片1"></p><h3 id="3-框架局限">3. 框架局限</h3><p>即使是现代框架如Qt的信号槽机制,在处理复杂的异步流程时也可能遇到类似问题。</p><h2 id="解决方案">解决方案</h2><h3 id="1-有限状态机">1. 有限状态机</h3><p>使用状态机可以:</p><ul><li>清晰地定义状态转换</li><li>简化事件处理逻辑</li><li>提高代码可维护性<br><img src="https://cdn-a.markji.com/files/67e4f9ae81bdefd1be16b2e6_hd.png?e=1743071674079&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:4qWtJeXCFx8d5jW3lGtTV0QP2fY=" alt="图片1"></li></ul><h3 id="2-协程">2. 协程</h3><p>协程提供了更优雅的解决方案:</p><ul><li>可以暂停执行中的线程</li><li>类似于给线程添加了goto能力</li><li>代码结构更清晰易读</li><li>接近同步代码的写法</li><li>避免了显式的回调嵌套</li></ul><p>协程相比传统回调的优势:</p><ul><li>线性的代码结构</li><li>更好的错误处理</li><li>更容易的状态管理</li><li>更接近人类思维方式</li></ul><h2 id="总结">总结</h2><p>回调地狱是异步编程中的常见问题,通过合适的设计模式(如状态机)或现代语言特性(如协程)可以有效避免这个问题。选择哪种解决方案需要根据具体场景和需求来决定。</p>]]></content>
    
    
    <summary type="html">回调地狱产生的原因及其解决方案</summary>
    
    
    
    <category term="编程技术" scheme="https://eatbreads.github.io/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="异步编程" scheme="https://eatbreads.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    <category term="设计模式" scheme="https://eatbreads.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>高性能服务器压力测试</title>
    <link href="https://eatbreads.github.io/posts/1c2eabf7.html"/>
    <id>https://eatbreads.github.io/posts/1c2eabf7.html</id>
    <published>2025-03-27T09:38:43.000Z</published>
    <updated>2025-03-27T09:44:48.280Z</updated>
    
    <content type="html"><![CDATA[<h1>服务器性能测试</h1><h2 id="测试类型">测试类型</h2><p>服务器性能测试主要分为两类:</p><ul><li>连接吞吐测试: 测试TCP的连接建立和断开性能</li><li>数据吞吐测试: 测试数据收发能力<br><img src="https://cdn-a.markji.com/files/67e41be2d5e9e782bf5d5c27_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:gXwKTAIzYWZ958RV0rFgeQY-lkA=" alt="图片1"></li></ul><h2 id="测试工具尝试">测试工具尝试</h2><h3 id="1-hping3测试">1. hping3测试</h3><p>hping3主要用于TCP/UDP/ICMP测试,可以用于简单的TCP并发连接测试。</p><p>测试命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -S -p 8080 -c 200 --fast 127.0.0.1</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>-S：发送SYN包(建立TCP连接)</li><li>-p 8080：目标端口8080</li><li>-c 200：发送200个连接</li><li>–fast：快速发送请求</li></ul><h3 id="2-测试问题">2. 测试问题</h3><p>hping3存在问题:只发送SYN包而不完成完整的三次握手。</p><p>尝试使用nping:</p><ul><li>可以同时发送SYN和ACK</li><li>但服务器直接返回RST拒绝连接</li><li>可能是因为同时发送导致的问题</li></ul><h3 id="3-wrk测试">3. wrk测试</h3><p>最后尝试使用http测试工具wrk:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrk -t4 -c1000 -d10s http://127.0.0.1:8082/</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>4个线程</li><li>1000并发连接</li><li>持续10秒</li></ul><p>测试结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Running 10s test @ http://127.0.0.1:8082/</span><br><span class="line">  4 threads and 1000 connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency     0.00us    0.00us   0.00us    -nan%</span><br><span class="line">    Req/Sec     0.00      0.00     0.00      -nan%</span><br><span class="line">  0 requests in 10.10s, 0.00B read</span><br><span class="line">  Socket errors: connect 0, read 221412, write 0, timeout 0</span><br><span class="line">Requests/sec:      0.00</span><br><span class="line">Transfer/sec:       0.00B</span><br></pre></td></tr></table></figure><p><img src="https://cdn-a.markji.com/files/67e4230481bdefd1be044f9c_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:5xzRSXgWiCCrw0kE2d6C8Niiro4=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e423d9d5e9e782bf5f4193_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:KqAiU6anLcQmrkLlipX43k-OgLs=" alt="图片1"></p><h3 id="4-最终方案">4. 最终方案</h3><p>虽然wrk需要解析HTTP协议会带来额外开销,但考虑到测试的完整性,最终还是选择了:</p><ul><li>使用简单的HTTP响应</li><li>通过自定义client.cpp进行压力测试</li></ul><p><img src="https://cdn-a.markji.com/files/67e4e82681bdefd1be142474_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:MsZPuHpePJdsXpwEhq9FlnU0bak=" alt="图片1"><br><img src="https://cdn-a.markji.com/files/67e4e8f981bdefd1be1437e8_hd.png?e=1743059627923&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:Sgon3GxsCZKhCSOoiSfadNtK3qo=" alt="图片1"></p>]]></content>
    
    
    <summary type="html">记录服务器性能测试的方法和经验</summary>
    
    
    
    <category term="c++开发" scheme="https://eatbreads.github.io/categories/c-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="服务器" scheme="https://eatbreads.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="性能测试" scheme="https://eatbreads.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="网络编程" scheme="https://eatbreads.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++20协程学习笔记</title>
    <link href="https://eatbreads.github.io/posts/c8e6cc4a.html"/>
    <id>https://eatbreads.github.io/posts/c8e6cc4a.html</id>
    <published>2025-03-27T09:36:43.000Z</published>
    <updated>2025-03-27T10:58:22.397Z</updated>
    
    <content type="html"><![CDATA[<h1>C++20协程学习笔记</h1><h2 id="协程基本概念">协程基本概念</h2><p>C++20引入了协程支持,提供了三个关键字:</p><h3 id="co-await">co_await</h3><p>用于等待一个异步操作完成。当遇到co_await时,协程会暂停执行并让出控制权,直到异步操作完成。</p><h3 id="co-return">co_return</h3><p>协程的返回语句,用于返回一个值并结束协程的执行。与普通函数的return不同,co_return会触发协程的清理流程。</p><h3 id="co-yield">co_yield</h3><p>暂停协程执行并返回一个值,但不会结束协程。当协程重新恢复执行时,会从co_yield的下一条语句继续执行。</p><h2 id="图片展示">图片展示</h2><p><img src="https://cdn-a.markji.com/files/67e3b3bed5e9e782bf4c5f5e_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:dm0hXEqtu0m3aIkrwD090-GKEM0=" alt="协程原理图1"></p><p><img src="https://cdn-a.markji.com/files/67e3b4c181bdefd1bef23aff_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:tiu4RI3FO9Ow1wjPMSnHm-9EJMQ=" alt="协程示例代码"></p><p><img src="https://cdn-a.markji.com/files/67e3e413d5e9e782bf530102_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:WQQWDUaan3U5TF1Q0MN4TgzVg9E=" alt="协程执行流程"></p><p><img src="https://cdn-a.markji.com/files/67e3e614d5e9e782bf533eae_hd.png?e=1743067034044&amp;token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:cBWMwkhuLg6n7m2K_L-bFA9lE3w=" alt="协程执行流程"></p>]]></content>
    
    
    <summary type="html">C++20协程的基本概念和使用方法总结</summary>
    
    
    
    <category term="C++开发" scheme="https://eatbreads.github.io/categories/C-%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C++" scheme="https://eatbreads.github.io/tags/C/"/>
    
    <category term="协程" scheme="https://eatbreads.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
    <category term="异步编程" scheme="https://eatbreads.github.io/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
